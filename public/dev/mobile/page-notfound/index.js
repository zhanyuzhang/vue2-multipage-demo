/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';\n\nvar _vue = __webpack_require__(1);\n\nvar _vue2 = _interopRequireDefault(_vue);\n\nvar _index = __webpack_require__(11);\n\nvar _index2 = _interopRequireDefault(_index);\n\nvar _remHelper = __webpack_require__(35);\n\nvar _remHelper2 = _interopRequireDefault(_remHelper);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nnew _vue2.default(_index2.default);\n_remHelper2.default.init(720);//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9FOi9naXRfcHJvL2V4cHJlc3Mtd2VicGFjay12dWUvc3JjL3BhZ2VzL21vYmlsZS9wYWdlLW5vdGZvdW5kL21haW4uanM/OWY5NiJdLCJuYW1lcyI6WyJpbml0Il0sIm1hcHBpbmdzIjoiOztBQUFBOzs7O0FBQ0E7Ozs7QUFDQTs7Ozs7O0FBQ0E7QUFDQSxvQkFBVUEsSUFBVixDQUFlLEdBQWYiLCJmaWxlIjoiMC5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBWdWUgZnJvbSAndnVlJ1xyXG5pbXBvcnQgQXBwIGZyb20gJy4vaW5kZXgudnVlJ1xyXG5pbXBvcnQgcmVtSGVscGVyIGZyb20gJy4uLy4uLy4uL3V0aWwvcmVtSGVscGVyJ1xyXG5uZXcgVnVlKEFwcClcclxucmVtSGVscGVyLmluaXQoNzIwKTtcclxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vRTovZ2l0X3Byby9leHByZXNzLXdlYnBhY2stdnVlL3NyYy9wYWdlcy9tb2JpbGUvcGFnZS1ub3Rmb3VuZC9tYWluLmpzIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	eval("/* WEBPACK VAR INJECTION */(function(process) {/*!\n * Vue.js v2.0.8\n * (c) 2014-2016 Evan You\n * Released under the MIT License.\n */\n'use strict';\n\n/*  */\n\n/**\n * Convert a value to a string that is actually rendered.\n */\nfunction _toString (val) {\n  return val == null\n    ? ''\n    : typeof val === 'object'\n      ? JSON.stringify(val, null, 2)\n      : String(val)\n}\n\n/**\n * Convert a input value to a number for persistence.\n * If the conversion fails, return original string.\n */\nfunction toNumber (val) {\n  var n = parseFloat(val, 10);\n  return (n || n === 0) ? n : val\n}\n\n/**\n * Make a map and return a function for checking if a key\n * is in that map.\n */\nfunction makeMap (\n  str,\n  expectsLowerCase\n) {\n  var map = Object.create(null);\n  var list = str.split(',');\n  for (var i = 0; i < list.length; i++) {\n    map[list[i]] = true;\n  }\n  return expectsLowerCase\n    ? function (val) { return map[val.toLowerCase()]; }\n    : function (val) { return map[val]; }\n}\n\n/**\n * Check if a tag is a built-in tag.\n */\nvar isBuiltInTag = makeMap('slot,component', true);\n\n/**\n * Remove an item from an array\n */\nfunction remove$1 (arr, item) {\n  if (arr.length) {\n    var index = arr.indexOf(item);\n    if (index > -1) {\n      return arr.splice(index, 1)\n    }\n  }\n}\n\n/**\n * Check whether the object has the property.\n */\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\nfunction hasOwn (obj, key) {\n  return hasOwnProperty.call(obj, key)\n}\n\n/**\n * Check if value is primitive\n */\nfunction isPrimitive (value) {\n  return typeof value === 'string' || typeof value === 'number'\n}\n\n/**\n * Create a cached version of a pure function.\n */\nfunction cached (fn) {\n  var cache = Object.create(null);\n  return function cachedFn (str) {\n    var hit = cache[str];\n    return hit || (cache[str] = fn(str))\n  }\n}\n\n/**\n * Camelize a hyphen-delmited string.\n */\nvar camelizeRE = /-(\\w)/g;\nvar camelize = cached(function (str) {\n  return str.replace(camelizeRE, function (_, c) { return c ? c.toUpperCase() : ''; })\n});\n\n/**\n * Capitalize a string.\n */\nvar capitalize = cached(function (str) {\n  return str.charAt(0).toUpperCase() + str.slice(1)\n});\n\n/**\n * Hyphenate a camelCase string.\n */\nvar hyphenateRE = /([^-])([A-Z])/g;\nvar hyphenate = cached(function (str) {\n  return str\n    .replace(hyphenateRE, '$1-$2')\n    .replace(hyphenateRE, '$1-$2')\n    .toLowerCase()\n});\n\n/**\n * Simple bind, faster than native\n */\nfunction bind$1 (fn, ctx) {\n  function boundFn (a) {\n    var l = arguments.length;\n    return l\n      ? l > 1\n        ? fn.apply(ctx, arguments)\n        : fn.call(ctx, a)\n      : fn.call(ctx)\n  }\n  // record original fn length\n  boundFn._length = fn.length;\n  return boundFn\n}\n\n/**\n * Convert an Array-like object to a real Array.\n */\nfunction toArray (list, start) {\n  start = start || 0;\n  var i = list.length - start;\n  var ret = new Array(i);\n  while (i--) {\n    ret[i] = list[i + start];\n  }\n  return ret\n}\n\n/**\n * Mix properties into target object.\n */\nfunction extend (to, _from) {\n  for (var key in _from) {\n    to[key] = _from[key];\n  }\n  return to\n}\n\n/**\n * Quick object check - this is primarily used to tell\n * Objects from primitive values when we know the value\n * is a JSON-compliant type.\n */\nfunction isObject (obj) {\n  return obj !== null && typeof obj === 'object'\n}\n\n/**\n * Strict object type check. Only returns true\n * for plain JavaScript objects.\n */\nvar toString = Object.prototype.toString;\nvar OBJECT_STRING = '[object Object]';\nfunction isPlainObject (obj) {\n  return toString.call(obj) === OBJECT_STRING\n}\n\n/**\n * Merge an Array of Objects into a single Object.\n */\nfunction toObject (arr) {\n  var res = {};\n  for (var i = 0; i < arr.length; i++) {\n    if (arr[i]) {\n      extend(res, arr[i]);\n    }\n  }\n  return res\n}\n\n/**\n * Perform no operation.\n */\nfunction noop () {}\n\n/**\n * Always return false.\n */\nvar no = function () { return false; };\n\n/**\n * Generate a static keys string from compiler modules.\n */\nfunction genStaticKeys (modules) {\n  return modules.reduce(function (keys, m) {\n    return keys.concat(m.staticKeys || [])\n  }, []).join(',')\n}\n\n/**\n * Check if two values are loosely equal - that is,\n * if they are plain objects, do they have the same shape?\n */\nfunction looseEqual (a, b) {\n  /* eslint-disable eqeqeq */\n  return a == b || (\n    isObject(a) && isObject(b)\n      ? JSON.stringify(a) === JSON.stringify(b)\n      : false\n  )\n  /* eslint-enable eqeqeq */\n}\n\nfunction looseIndexOf (arr, val) {\n  for (var i = 0; i < arr.length; i++) {\n    if (looseEqual(arr[i], val)) { return i }\n  }\n  return -1\n}\n\n/*  */\n\nvar config = {\n  /**\n   * Option merge strategies (used in core/util/options)\n   */\n  optionMergeStrategies: Object.create(null),\n\n  /**\n   * Whether to suppress warnings.\n   */\n  silent: false,\n\n  /**\n   * Whether to enable devtools\n   */\n  devtools: process.env.NODE_ENV !== 'production',\n\n  /**\n   * Error handler for watcher errors\n   */\n  errorHandler: null,\n\n  /**\n   * Ignore certain custom elements\n   */\n  ignoredElements: null,\n\n  /**\n   * Custom user key aliases for v-on\n   */\n  keyCodes: Object.create(null),\n\n  /**\n   * Check if a tag is reserved so that it cannot be registered as a\n   * component. This is platform-dependent and may be overwritten.\n   */\n  isReservedTag: no,\n\n  /**\n   * Check if a tag is an unknown element.\n   * Platform-dependent.\n   */\n  isUnknownElement: no,\n\n  /**\n   * Get the namespace of an element\n   */\n  getTagNamespace: noop,\n\n  /**\n   * Check if an attribute must be bound using property, e.g. value\n   * Platform-dependent.\n   */\n  mustUseProp: no,\n\n  /**\n   * List of asset types that a component can own.\n   */\n  _assetTypes: [\n    'component',\n    'directive',\n    'filter'\n  ],\n\n  /**\n   * List of lifecycle hooks.\n   */\n  _lifecycleHooks: [\n    'beforeCreate',\n    'created',\n    'beforeMount',\n    'mounted',\n    'beforeUpdate',\n    'updated',\n    'beforeDestroy',\n    'destroyed',\n    'activated',\n    'deactivated'\n  ],\n\n  /**\n   * Max circular updates allowed in a scheduler flush cycle.\n   */\n  _maxUpdateCount: 100,\n\n  /**\n   * Server rendering?\n   */\n  _isServer: process.env.VUE_ENV === 'server'\n};\n\n/*  */\n\n/**\n * Check if a string starts with $ or _\n */\nfunction isReserved (str) {\n  var c = (str + '').charCodeAt(0);\n  return c === 0x24 || c === 0x5F\n}\n\n/**\n * Define a property.\n */\nfunction def (obj, key, val, enumerable) {\n  Object.defineProperty(obj, key, {\n    value: val,\n    enumerable: !!enumerable,\n    writable: true,\n    configurable: true\n  });\n}\n\n/**\n * Parse simple path.\n */\nvar bailRE = /[^\\w.$]/;\nfunction parsePath (path) {\n  if (bailRE.test(path)) {\n    return\n  } else {\n    var segments = path.split('.');\n    return function (obj) {\n      for (var i = 0; i < segments.length; i++) {\n        if (!obj) { return }\n        obj = obj[segments[i]];\n      }\n      return obj\n    }\n  }\n}\n\n/*  */\n/* globals MutationObserver */\n\n// can we use __proto__?\nvar hasProto = '__proto__' in {};\n\n// Browser environment sniffing\nvar inBrowser =\n  typeof window !== 'undefined' &&\n  Object.prototype.toString.call(window) !== '[object Object]';\n\nvar UA = inBrowser && window.navigator.userAgent.toLowerCase();\nvar isIE = UA && /msie|trident/.test(UA);\nvar isIE9 = UA && UA.indexOf('msie 9.0') > 0;\nvar isEdge = UA && UA.indexOf('edge/') > 0;\nvar isAndroid = UA && UA.indexOf('android') > 0;\nvar isIOS = UA && /iphone|ipad|ipod|ios/.test(UA);\n\n// detect devtools\nvar devtools = inBrowser && window.__VUE_DEVTOOLS_GLOBAL_HOOK__;\n\n/* istanbul ignore next */\nfunction isNative (Ctor) {\n  return /native code/.test(Ctor.toString())\n}\n\n/**\n * Defer a task to execute it asynchronously.\n */\nvar nextTick = (function () {\n  var callbacks = [];\n  var pending = false;\n  var timerFunc;\n\n  function nextTickHandler () {\n    pending = false;\n    var copies = callbacks.slice(0);\n    callbacks.length = 0;\n    for (var i = 0; i < copies.length; i++) {\n      copies[i]();\n    }\n  }\n\n  // the nextTick behavior leverages the microtask queue, which can be accessed\n  // via either native Promise.then or MutationObserver.\n  // MutationObserver has wider support, however it is seriously bugged in\n  // UIWebView in iOS >= 9.3.3 when triggered in touch event handlers. It\n  // completely stops working after triggering a few times... so, if native\n  // Promise is available, we will use it:\n  /* istanbul ignore if */\n  if (typeof Promise !== 'undefined' && isNative(Promise)) {\n    var p = Promise.resolve();\n    timerFunc = function () {\n      p.then(nextTickHandler);\n      // in problematic UIWebViews, Promise.then doesn't completely break, but\n      // it can get stuck in a weird state where callbacks are pushed into the\n      // microtask queue but the queue isn't being flushed, until the browser\n      // needs to do some other work, e.g. handle a timer. Therefore we can\n      // \"force\" the microtask queue to be flushed by adding an empty timer.\n      if (isIOS) { setTimeout(noop); }\n    };\n  } else if (typeof MutationObserver !== 'undefined' && (\n    isNative(MutationObserver) ||\n    // PhantomJS and iOS 7.x\n    MutationObserver.toString() === '[object MutationObserverConstructor]'\n  )) {\n    // use MutationObserver where native Promise is not available,\n    // e.g. PhantomJS IE11, iOS7, Android 4.4\n    var counter = 1;\n    var observer = new MutationObserver(nextTickHandler);\n    var textNode = document.createTextNode(String(counter));\n    observer.observe(textNode, {\n      characterData: true\n    });\n    timerFunc = function () {\n      counter = (counter + 1) % 2;\n      textNode.data = String(counter);\n    };\n  } else {\n    // fallback to setTimeout\n    /* istanbul ignore next */\n    timerFunc = function () {\n      setTimeout(nextTickHandler, 0);\n    };\n  }\n\n  return function queueNextTick (cb, ctx) {\n    var func = ctx\n      ? function () { cb.call(ctx); }\n      : cb;\n    callbacks.push(func);\n    if (!pending) {\n      pending = true;\n      timerFunc();\n    }\n  }\n})();\n\nvar _Set;\n/* istanbul ignore if */\nif (typeof Set !== 'undefined' && isNative(Set)) {\n  // use native Set when available.\n  _Set = Set;\n} else {\n  // a non-standard Set polyfill that only works with primitive keys.\n  _Set = (function () {\n    function Set () {\n      this.set = Object.create(null);\n    }\n    Set.prototype.has = function has (key) {\n      return this.set[key] !== undefined\n    };\n    Set.prototype.add = function add (key) {\n      this.set[key] = 1;\n    };\n    Set.prototype.clear = function clear () {\n      this.set = Object.create(null);\n    };\n\n    return Set;\n  }());\n}\n\n/* not type checking this file because flow doesn't play well with Proxy */\n\nvar hasProxy;\nvar proxyHandlers;\nvar initProxy;\n\nif (process.env.NODE_ENV !== 'production') {\n  var allowedGlobals = makeMap(\n    'Infinity,undefined,NaN,isFinite,isNaN,' +\n    'parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,' +\n    'Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,' +\n    'require' // for Webpack/Browserify\n  );\n\n  hasProxy =\n    typeof Proxy !== 'undefined' &&\n    Proxy.toString().match(/native code/);\n\n  proxyHandlers = {\n    has: function has (target, key) {\n      var has = key in target;\n      var isAllowed = allowedGlobals(key) || key.charAt(0) === '_';\n      if (!has && !isAllowed) {\n        warn(\n          \"Property or method \\\"\" + key + \"\\\" is not defined on the instance but \" +\n          \"referenced during render. Make sure to declare reactive data \" +\n          \"properties in the data option.\",\n          target\n        );\n      }\n      return has || !isAllowed\n    }\n  };\n\n  initProxy = function initProxy (vm) {\n    if (hasProxy) {\n      vm._renderProxy = new Proxy(vm, proxyHandlers);\n    } else {\n      vm._renderProxy = vm;\n    }\n  };\n}\n\n/*  */\n\n\nvar uid$2 = 0;\n\n/**\n * A dep is an observable that can have multiple\n * directives subscribing to it.\n */\nvar Dep = function Dep () {\n  this.id = uid$2++;\n  this.subs = [];\n};\n\nDep.prototype.addSub = function addSub (sub) {\n  this.subs.push(sub);\n};\n\nDep.prototype.removeSub = function removeSub (sub) {\n  remove$1(this.subs, sub);\n};\n\nDep.prototype.depend = function depend () {\n  if (Dep.target) {\n    Dep.target.addDep(this);\n  }\n};\n\nDep.prototype.notify = function notify () {\n  // stablize the subscriber list first\n  var subs = this.subs.slice();\n  for (var i = 0, l = subs.length; i < l; i++) {\n    subs[i].update();\n  }\n};\n\n// the current target watcher being evaluated.\n// this is globally unique because there could be only one\n// watcher being evaluated at any time.\nDep.target = null;\nvar targetStack = [];\n\nfunction pushTarget (_target) {\n  if (Dep.target) { targetStack.push(Dep.target); }\n  Dep.target = _target;\n}\n\nfunction popTarget () {\n  Dep.target = targetStack.pop();\n}\n\n/*  */\n\n\nvar queue = [];\nvar has$1 = {};\nvar circular = {};\nvar waiting = false;\nvar flushing = false;\nvar index = 0;\n\n/**\n * Reset the scheduler's state.\n */\nfunction resetSchedulerState () {\n  queue.length = 0;\n  has$1 = {};\n  if (process.env.NODE_ENV !== 'production') {\n    circular = {};\n  }\n  waiting = flushing = false;\n}\n\n/**\n * Flush both queues and run the watchers.\n */\nfunction flushSchedulerQueue () {\n  flushing = true;\n\n  // Sort queue before flush.\n  // This ensures that:\n  // 1. Components are updated from parent to child. (because parent is always\n  //    created before the child)\n  // 2. A component's user watchers are run before its render watcher (because\n  //    user watchers are created before the render watcher)\n  // 3. If a component is destroyed during a parent component's watcher run,\n  //    its watchers can be skipped.\n  queue.sort(function (a, b) { return a.id - b.id; });\n\n  // do not cache length because more watchers might be pushed\n  // as we run existing watchers\n  for (index = 0; index < queue.length; index++) {\n    var watcher = queue[index];\n    var id = watcher.id;\n    has$1[id] = null;\n    watcher.run();\n    // in dev build, check and stop circular updates.\n    if (process.env.NODE_ENV !== 'production' && has$1[id] != null) {\n      circular[id] = (circular[id] || 0) + 1;\n      if (circular[id] > config._maxUpdateCount) {\n        warn(\n          'You may have an infinite update loop ' + (\n            watcher.user\n              ? (\"in watcher with expression \\\"\" + (watcher.expression) + \"\\\"\")\n              : \"in a component render function.\"\n          ),\n          watcher.vm\n        );\n        break\n      }\n    }\n  }\n\n  // devtool hook\n  /* istanbul ignore if */\n  if (devtools && config.devtools) {\n    devtools.emit('flush');\n  }\n\n  resetSchedulerState();\n}\n\n/**\n * Push a watcher into the watcher queue.\n * Jobs with duplicate IDs will be skipped unless it's\n * pushed when the queue is being flushed.\n */\nfunction queueWatcher (watcher) {\n  var id = watcher.id;\n  if (has$1[id] == null) {\n    has$1[id] = true;\n    if (!flushing) {\n      queue.push(watcher);\n    } else {\n      // if already flushing, splice the watcher based on its id\n      // if already past its id, it will be run next immediately.\n      var i = queue.length - 1;\n      while (i >= 0 && queue[i].id > watcher.id) {\n        i--;\n      }\n      queue.splice(Math.max(i, index) + 1, 0, watcher);\n    }\n    // queue the flush\n    if (!waiting) {\n      waiting = true;\n      nextTick(flushSchedulerQueue);\n    }\n  }\n}\n\n/*  */\n\nvar uid$1 = 0;\n\n/**\n * A watcher parses an expression, collects dependencies,\n * and fires callback when the expression value changes.\n * This is used for both the $watch() api and directives.\n */\nvar Watcher = function Watcher (\n  vm,\n  expOrFn,\n  cb,\n  options\n) {\n  if ( options === void 0 ) options = {};\n\n  this.vm = vm;\n  vm._watchers.push(this);\n  // options\n  this.deep = !!options.deep;\n  this.user = !!options.user;\n  this.lazy = !!options.lazy;\n  this.sync = !!options.sync;\n  this.expression = expOrFn.toString();\n  this.cb = cb;\n  this.id = ++uid$1; // uid for batching\n  this.active = true;\n  this.dirty = this.lazy; // for lazy watchers\n  this.deps = [];\n  this.newDeps = [];\n  this.depIds = new _Set();\n  this.newDepIds = new _Set();\n  // parse expression for getter\n  if (typeof expOrFn === 'function') {\n    this.getter = expOrFn;\n  } else {\n    this.getter = parsePath(expOrFn);\n    if (!this.getter) {\n      this.getter = function () {};\n      process.env.NODE_ENV !== 'production' && warn(\n        \"Failed watching path: \\\"\" + expOrFn + \"\\\" \" +\n        'Watcher only accepts simple dot-delimited paths. ' +\n        'For full control, use a function instead.',\n        vm\n      );\n    }\n  }\n  this.value = this.lazy\n    ? undefined\n    : this.get();\n};\n\n/**\n * Evaluate the getter, and re-collect dependencies.\n */\nWatcher.prototype.get = function get () {\n  pushTarget(this);\n  var value = this.getter.call(this.vm, this.vm);\n  // \"touch\" every property so they are all tracked as\n  // dependencies for deep watching\n  if (this.deep) {\n    traverse(value);\n  }\n  popTarget();\n  this.cleanupDeps();\n  return value\n};\n\n/**\n * Add a dependency to this directive.\n */\nWatcher.prototype.addDep = function addDep (dep) {\n  var id = dep.id;\n  if (!this.newDepIds.has(id)) {\n    this.newDepIds.add(id);\n    this.newDeps.push(dep);\n    if (!this.depIds.has(id)) {\n      dep.addSub(this);\n    }\n  }\n};\n\n/**\n * Clean up for dependency collection.\n */\nWatcher.prototype.cleanupDeps = function cleanupDeps () {\n    var this$1 = this;\n\n  var i = this.deps.length;\n  while (i--) {\n    var dep = this$1.deps[i];\n    if (!this$1.newDepIds.has(dep.id)) {\n      dep.removeSub(this$1);\n    }\n  }\n  var tmp = this.depIds;\n  this.depIds = this.newDepIds;\n  this.newDepIds = tmp;\n  this.newDepIds.clear();\n  tmp = this.deps;\n  this.deps = this.newDeps;\n  this.newDeps = tmp;\n  this.newDeps.length = 0;\n};\n\n/**\n * Subscriber interface.\n * Will be called when a dependency changes.\n */\nWatcher.prototype.update = function update () {\n  /* istanbul ignore else */\n  if (this.lazy) {\n    this.dirty = true;\n  } else if (this.sync) {\n    this.run();\n  } else {\n    queueWatcher(this);\n  }\n};\n\n/**\n * Scheduler job interface.\n * Will be called by the scheduler.\n */\nWatcher.prototype.run = function run () {\n  if (this.active) {\n    var value = this.get();\n      if (\n        value !== this.value ||\n      // Deep watchers and watchers on Object/Arrays should fire even\n      // when the value is the same, because the value may\n      // have mutated.\n      isObject(value) ||\n      this.deep\n    ) {\n      // set new value\n      var oldValue = this.value;\n      this.value = value;\n      if (this.user) {\n        try {\n          this.cb.call(this.vm, value, oldValue);\n        } catch (e) {\n          process.env.NODE_ENV !== 'production' && warn(\n            (\"Error in watcher \\\"\" + (this.expression) + \"\\\"\"),\n            this.vm\n          );\n          /* istanbul ignore else */\n          if (config.errorHandler) {\n            config.errorHandler.call(null, e, this.vm);\n          } else {\n            throw e\n          }\n        }\n      } else {\n        this.cb.call(this.vm, value, oldValue);\n      }\n    }\n  }\n};\n\n/**\n * Evaluate the value of the watcher.\n * This only gets called for lazy watchers.\n */\nWatcher.prototype.evaluate = function evaluate () {\n  this.value = this.get();\n  this.dirty = false;\n};\n\n/**\n * Depend on all deps collected by this watcher.\n */\nWatcher.prototype.depend = function depend () {\n    var this$1 = this;\n\n  var i = this.deps.length;\n  while (i--) {\n    this$1.deps[i].depend();\n  }\n};\n\n/**\n * Remove self from all dependencies' subscriber list.\n */\nWatcher.prototype.teardown = function teardown () {\n    var this$1 = this;\n\n  if (this.active) {\n    // remove self from vm's watcher list\n    // this is a somewhat expensive operation so we skip it\n    // if the vm is being destroyed or is performing a v-for\n    // re-render (the watcher list is then filtered by v-for).\n    if (!this.vm._isBeingDestroyed && !this.vm._vForRemoving) {\n      remove$1(this.vm._watchers, this);\n    }\n    var i = this.deps.length;\n    while (i--) {\n      this$1.deps[i].removeSub(this$1);\n    }\n    this.active = false;\n  }\n};\n\n/**\n * Recursively traverse an object to evoke all converted\n * getters, so that every nested property inside the object\n * is collected as a \"deep\" dependency.\n */\nvar seenObjects = new _Set();\nfunction traverse (val) {\n  seenObjects.clear();\n  _traverse(val, seenObjects);\n}\n\nfunction _traverse (val, seen) {\n  var i, keys;\n  var isA = Array.isArray(val);\n  if ((!isA && !isObject(val)) || !Object.isExtensible(val)) {\n    return\n  }\n  if (val.__ob__) {\n    var depId = val.__ob__.dep.id;\n    if (seen.has(depId)) {\n      return\n    }\n    seen.add(depId);\n  }\n  if (isA) {\n    i = val.length;\n    while (i--) { _traverse(val[i], seen); }\n  } else {\n    keys = Object.keys(val);\n    i = keys.length;\n    while (i--) { _traverse(val[keys[i]], seen); }\n  }\n}\n\n/*\n * not type checking this file because flow doesn't play well with\n * dynamically accessing methods on Array prototype\n */\n\nvar arrayProto = Array.prototype;\nvar arrayMethods = Object.create(arrayProto);[\n  'push',\n  'pop',\n  'shift',\n  'unshift',\n  'splice',\n  'sort',\n  'reverse'\n]\n.forEach(function (method) {\n  // cache original method\n  var original = arrayProto[method];\n  def(arrayMethods, method, function mutator () {\n    var arguments$1 = arguments;\n\n    // avoid leaking arguments:\n    // http://jsperf.com/closure-with-arguments\n    var i = arguments.length;\n    var args = new Array(i);\n    while (i--) {\n      args[i] = arguments$1[i];\n    }\n    var result = original.apply(this, args);\n    var ob = this.__ob__;\n    var inserted;\n    switch (method) {\n      case 'push':\n        inserted = args;\n        break\n      case 'unshift':\n        inserted = args;\n        break\n      case 'splice':\n        inserted = args.slice(2);\n        break\n    }\n    if (inserted) { ob.observeArray(inserted); }\n    // notify change\n    ob.dep.notify();\n    return result\n  });\n});\n\n/*  */\n\nvar arrayKeys = Object.getOwnPropertyNames(arrayMethods);\n\n/**\n * By default, when a reactive property is set, the new value is\n * also converted to become reactive. However when passing down props,\n * we don't want to force conversion because the value may be a nested value\n * under a frozen data structure. Converting it would defeat the optimization.\n */\nvar observerState = {\n  shouldConvert: true,\n  isSettingProps: false\n};\n\n/**\n * Observer class that are attached to each observed\n * object. Once attached, the observer converts target\n * object's property keys into getter/setters that\n * collect dependencies and dispatches updates.\n */\nvar Observer = function Observer (value) {\n  this.value = value;\n  this.dep = new Dep();\n  this.vmCount = 0;\n  def(value, '__ob__', this);\n  if (Array.isArray(value)) {\n    var augment = hasProto\n      ? protoAugment\n      : copyAugment;\n    augment(value, arrayMethods, arrayKeys);\n    this.observeArray(value);\n  } else {\n    this.walk(value);\n  }\n};\n\n/**\n * Walk through each property and convert them into\n * getter/setters. This method should only be called when\n * value type is Object.\n */\nObserver.prototype.walk = function walk (obj) {\n  var keys = Object.keys(obj);\n  for (var i = 0; i < keys.length; i++) {\n    defineReactive$$1(obj, keys[i], obj[keys[i]]);\n  }\n};\n\n/**\n * Observe a list of Array items.\n */\nObserver.prototype.observeArray = function observeArray (items) {\n  for (var i = 0, l = items.length; i < l; i++) {\n    observe(items[i]);\n  }\n};\n\n// helpers\n\n/**\n * Augment an target Object or Array by intercepting\n * the prototype chain using __proto__\n */\nfunction protoAugment (target, src) {\n  /* eslint-disable no-proto */\n  target.__proto__ = src;\n  /* eslint-enable no-proto */\n}\n\n/**\n * Augment an target Object or Array by defining\n * hidden properties.\n *\n * istanbul ignore next\n */\nfunction copyAugment (target, src, keys) {\n  for (var i = 0, l = keys.length; i < l; i++) {\n    var key = keys[i];\n    def(target, key, src[key]);\n  }\n}\n\n/**\n * Attempt to create an observer instance for a value,\n * returns the new observer if successfully observed,\n * or the existing observer if the value already has one.\n */\nfunction observe (value) {\n  if (!isObject(value)) {\n    return\n  }\n  var ob;\n  if (hasOwn(value, '__ob__') && value.__ob__ instanceof Observer) {\n    ob = value.__ob__;\n  } else if (\n    observerState.shouldConvert &&\n    !config._isServer &&\n    (Array.isArray(value) || isPlainObject(value)) &&\n    Object.isExtensible(value) &&\n    !value._isVue\n  ) {\n    ob = new Observer(value);\n  }\n  return ob\n}\n\n/**\n * Define a reactive property on an Object.\n */\nfunction defineReactive$$1 (\n  obj,\n  key,\n  val,\n  customSetter\n) {\n  var dep = new Dep();\n\n  var property = Object.getOwnPropertyDescriptor(obj, key);\n  if (property && property.configurable === false) {\n    return\n  }\n\n  // cater for pre-defined getter/setters\n  var getter = property && property.get;\n  var setter = property && property.set;\n\n  var childOb = observe(val);\n  Object.defineProperty(obj, key, {\n    enumerable: true,\n    configurable: true,\n    get: function reactiveGetter () {\n      var value = getter ? getter.call(obj) : val;\n      if (Dep.target) {\n        dep.depend();\n        if (childOb) {\n          childOb.dep.depend();\n        }\n        if (Array.isArray(value)) {\n          dependArray(value);\n        }\n      }\n      return value\n    },\n    set: function reactiveSetter (newVal) {\n      var value = getter ? getter.call(obj) : val;\n      /* eslint-disable no-self-compare */\n      if (newVal === value || (newVal !== newVal && value !== value)) {\n        return\n      }\n      /* eslint-enable no-self-compare */\n      if (process.env.NODE_ENV !== 'production' && customSetter) {\n        customSetter();\n      }\n      if (setter) {\n        setter.call(obj, newVal);\n      } else {\n        val = newVal;\n      }\n      childOb = observe(newVal);\n      dep.notify();\n    }\n  });\n}\n\n/**\n * Set a property on an object. Adds the new property and\n * triggers change notification if the property doesn't\n * already exist.\n */\nfunction set (obj, key, val) {\n  if (Array.isArray(obj)) {\n    obj.length = Math.max(obj.length, key);\n    obj.splice(key, 1, val);\n    return val\n  }\n  if (hasOwn(obj, key)) {\n    obj[key] = val;\n    return\n  }\n  var ob = obj.__ob__;\n  if (obj._isVue || (ob && ob.vmCount)) {\n    process.env.NODE_ENV !== 'production' && warn(\n      'Avoid adding reactive properties to a Vue instance or its root $data ' +\n      'at runtime - declare it upfront in the data option.'\n    );\n    return\n  }\n  if (!ob) {\n    obj[key] = val;\n    return\n  }\n  defineReactive$$1(ob.value, key, val);\n  ob.dep.notify();\n  return val\n}\n\n/**\n * Delete a property and trigger change if necessary.\n */\nfunction del (obj, key) {\n  var ob = obj.__ob__;\n  if (obj._isVue || (ob && ob.vmCount)) {\n    process.env.NODE_ENV !== 'production' && warn(\n      'Avoid deleting properties on a Vue instance or its root $data ' +\n      '- just set it to null.'\n    );\n    return\n  }\n  if (!hasOwn(obj, key)) {\n    return\n  }\n  delete obj[key];\n  if (!ob) {\n    return\n  }\n  ob.dep.notify();\n}\n\n/**\n * Collect dependencies on array elements when the array is touched, since\n * we cannot intercept array element access like property getters.\n */\nfunction dependArray (value) {\n  for (var e = (void 0), i = 0, l = value.length; i < l; i++) {\n    e = value[i];\n    e && e.__ob__ && e.__ob__.dep.depend();\n    if (Array.isArray(e)) {\n      dependArray(e);\n    }\n  }\n}\n\n/*  */\n\nfunction initState (vm) {\n  vm._watchers = [];\n  initProps(vm);\n  initData(vm);\n  initComputed(vm);\n  initMethods(vm);\n  initWatch(vm);\n}\n\nvar isReservedProp = makeMap('key,ref,slot');\n\nfunction initProps (vm) {\n  var props = vm.$options.props;\n  if (props) {\n    var propsData = vm.$options.propsData || {};\n    var keys = vm.$options._propKeys = Object.keys(props);\n    var isRoot = !vm.$parent;\n    // root instance props should be converted\n    observerState.shouldConvert = isRoot;\n    var loop = function ( i ) {\n      var key = keys[i];\n      /* istanbul ignore else */\n      if (process.env.NODE_ENV !== 'production') {\n        if (isReservedProp(key)) {\n          warn(\n            (\"\\\"\" + key + \"\\\" is a reserved attribute and cannot be used as component prop.\"),\n            vm\n          );\n        }\n        defineReactive$$1(vm, key, validateProp(key, props, propsData, vm), function () {\n          if (vm.$parent && !observerState.isSettingProps) {\n            warn(\n              \"Avoid mutating a prop directly since the value will be \" +\n              \"overwritten whenever the parent component re-renders. \" +\n              \"Instead, use a data or computed property based on the prop's \" +\n              \"value. Prop being mutated: \\\"\" + key + \"\\\"\",\n              vm\n            );\n          }\n        });\n      } else {\n        defineReactive$$1(vm, key, validateProp(key, props, propsData, vm));\n      }\n    };\n\n    for (var i = 0; i < keys.length; i++) loop( i );\n    observerState.shouldConvert = true;\n  }\n}\n\nfunction initData (vm) {\n  var data = vm.$options.data;\n  data = vm._data = typeof data === 'function'\n    ? data.call(vm)\n    : data || {};\n  if (!isPlainObject(data)) {\n    data = {};\n    process.env.NODE_ENV !== 'production' && warn(\n      'data functions should return an object.',\n      vm\n    );\n  }\n  // proxy data on instance\n  var keys = Object.keys(data);\n  var props = vm.$options.props;\n  var i = keys.length;\n  while (i--) {\n    if (props && hasOwn(props, keys[i])) {\n      process.env.NODE_ENV !== 'production' && warn(\n        \"The data property \\\"\" + (keys[i]) + \"\\\" is already declared as a prop. \" +\n        \"Use prop default value instead.\",\n        vm\n      );\n    } else {\n      proxy(vm, keys[i]);\n    }\n  }\n  // observe data\n  observe(data);\n  data.__ob__ && data.__ob__.vmCount++;\n}\n\nvar computedSharedDefinition = {\n  enumerable: true,\n  configurable: true,\n  get: noop,\n  set: noop\n};\n\nfunction initComputed (vm) {\n  var computed = vm.$options.computed;\n  if (computed) {\n    for (var key in computed) {\n      var userDef = computed[key];\n      if (typeof userDef === 'function') {\n        computedSharedDefinition.get = makeComputedGetter(userDef, vm);\n        computedSharedDefinition.set = noop;\n      } else {\n        computedSharedDefinition.get = userDef.get\n          ? userDef.cache !== false\n            ? makeComputedGetter(userDef.get, vm)\n            : bind$1(userDef.get, vm)\n          : noop;\n        computedSharedDefinition.set = userDef.set\n          ? bind$1(userDef.set, vm)\n          : noop;\n      }\n      Object.defineProperty(vm, key, computedSharedDefinition);\n    }\n  }\n}\n\nfunction makeComputedGetter (getter, owner) {\n  var watcher = new Watcher(owner, getter, noop, {\n    lazy: true\n  });\n  return function computedGetter () {\n    if (watcher.dirty) {\n      watcher.evaluate();\n    }\n    if (Dep.target) {\n      watcher.depend();\n    }\n    return watcher.value\n  }\n}\n\nfunction initMethods (vm) {\n  var methods = vm.$options.methods;\n  if (methods) {\n    for (var key in methods) {\n      vm[key] = methods[key] == null ? noop : bind$1(methods[key], vm);\n      if (process.env.NODE_ENV !== 'production' && methods[key] == null) {\n        warn(\n          \"method \\\"\" + key + \"\\\" has an undefined value in the component definition. \" +\n          \"Did you reference the function correctly?\",\n          vm\n        );\n      }\n    }\n  }\n}\n\nfunction initWatch (vm) {\n  var watch = vm.$options.watch;\n  if (watch) {\n    for (var key in watch) {\n      var handler = watch[key];\n      if (Array.isArray(handler)) {\n        for (var i = 0; i < handler.length; i++) {\n          createWatcher(vm, key, handler[i]);\n        }\n      } else {\n        createWatcher(vm, key, handler);\n      }\n    }\n  }\n}\n\nfunction createWatcher (vm, key, handler) {\n  var options;\n  if (isPlainObject(handler)) {\n    options = handler;\n    handler = handler.handler;\n  }\n  if (typeof handler === 'string') {\n    handler = vm[handler];\n  }\n  vm.$watch(key, handler, options);\n}\n\nfunction stateMixin (Vue) {\n  // flow somehow has problems with directly declared definition object\n  // when using Object.defineProperty, so we have to procedurally build up\n  // the object here.\n  var dataDef = {};\n  dataDef.get = function () {\n    return this._data\n  };\n  if (process.env.NODE_ENV !== 'production') {\n    dataDef.set = function (newData) {\n      warn(\n        'Avoid replacing instance root $data. ' +\n        'Use nested data properties instead.',\n        this\n      );\n    };\n  }\n  Object.defineProperty(Vue.prototype, '$data', dataDef);\n\n  Vue.prototype.$set = set;\n  Vue.prototype.$delete = del;\n\n  Vue.prototype.$watch = function (\n    expOrFn,\n    cb,\n    options\n  ) {\n    var vm = this;\n    options = options || {};\n    options.user = true;\n    var watcher = new Watcher(vm, expOrFn, cb, options);\n    if (options.immediate) {\n      cb.call(vm, watcher.value);\n    }\n    return function unwatchFn () {\n      watcher.teardown();\n    }\n  };\n}\n\nfunction proxy (vm, key) {\n  if (!isReserved(key)) {\n    Object.defineProperty(vm, key, {\n      configurable: true,\n      enumerable: true,\n      get: function proxyGetter () {\n        return vm._data[key]\n      },\n      set: function proxySetter (val) {\n        vm._data[key] = val;\n      }\n    });\n  }\n}\n\n/*  */\n\nvar VNode = function VNode (\n  tag,\n  data,\n  children,\n  text,\n  elm,\n  ns,\n  context,\n  componentOptions\n) {\n  this.tag = tag;\n  this.data = data;\n  this.children = children;\n  this.text = text;\n  this.elm = elm;\n  this.ns = ns;\n  this.context = context;\n  this.functionalContext = undefined;\n  this.key = data && data.key;\n  this.componentOptions = componentOptions;\n  this.child = undefined;\n  this.parent = undefined;\n  this.raw = false;\n  this.isStatic = false;\n  this.isRootInsert = true;\n  this.isComment = false;\n  this.isCloned = false;\n  this.isOnce = false;\n};\n\nvar emptyVNode = function () {\n  var node = new VNode();\n  node.text = '';\n  node.isComment = true;\n  return node\n};\n\n// optimized shallow clone\n// used for static nodes and slot nodes because they may be reused across\n// multiple renders, cloning them avoids errors when DOM manipulations rely\n// on their elm reference.\nfunction cloneVNode (vnode) {\n  var cloned = new VNode(\n    vnode.tag,\n    vnode.data,\n    vnode.children,\n    vnode.text,\n    vnode.elm,\n    vnode.ns,\n    vnode.context,\n    vnode.componentOptions\n  );\n  cloned.isStatic = vnode.isStatic;\n  cloned.key = vnode.key;\n  cloned.isCloned = true;\n  return cloned\n}\n\nfunction cloneVNodes (vnodes) {\n  var res = new Array(vnodes.length);\n  for (var i = 0; i < vnodes.length; i++) {\n    res[i] = cloneVNode(vnodes[i]);\n  }\n  return res\n}\n\n/*  */\n\nfunction mergeVNodeHook (def, hookKey, hook, key) {\n  key = key + hookKey;\n  var injectedHash = def.__injected || (def.__injected = {});\n  if (!injectedHash[key]) {\n    injectedHash[key] = true;\n    var oldHook = def[hookKey];\n    if (oldHook) {\n      def[hookKey] = function () {\n        oldHook.apply(this, arguments);\n        hook.apply(this, arguments);\n      };\n    } else {\n      def[hookKey] = hook;\n    }\n  }\n}\n\n/*  */\n\nfunction updateListeners (\n  on,\n  oldOn,\n  add,\n  remove$$1,\n  vm\n) {\n  var name, cur, old, fn, event, capture;\n  for (name in on) {\n    cur = on[name];\n    old = oldOn[name];\n    if (!cur) {\n      process.env.NODE_ENV !== 'production' && warn(\n        \"Invalid handler for event \\\"\" + name + \"\\\": got \" + String(cur),\n        vm\n      );\n    } else if (!old) {\n      capture = name.charAt(0) === '!';\n      event = capture ? name.slice(1) : name;\n      if (Array.isArray(cur)) {\n        add(event, (cur.invoker = arrInvoker(cur)), capture);\n      } else {\n        if (!cur.invoker) {\n          fn = cur;\n          cur = on[name] = {};\n          cur.fn = fn;\n          cur.invoker = fnInvoker(cur);\n        }\n        add(event, cur.invoker, capture);\n      }\n    } else if (cur !== old) {\n      if (Array.isArray(old)) {\n        old.length = cur.length;\n        for (var i = 0; i < old.length; i++) { old[i] = cur[i]; }\n        on[name] = old;\n      } else {\n        old.fn = cur;\n        on[name] = old;\n      }\n    }\n  }\n  for (name in oldOn) {\n    if (!on[name]) {\n      event = name.charAt(0) === '!' ? name.slice(1) : name;\n      remove$$1(event, oldOn[name].invoker);\n    }\n  }\n}\n\nfunction arrInvoker (arr) {\n  return function (ev) {\n    var arguments$1 = arguments;\n\n    var single = arguments.length === 1;\n    for (var i = 0; i < arr.length; i++) {\n      single ? arr[i](ev) : arr[i].apply(null, arguments$1);\n    }\n  }\n}\n\nfunction fnInvoker (o) {\n  return function (ev) {\n    var single = arguments.length === 1;\n    single ? o.fn(ev) : o.fn.apply(null, arguments);\n  }\n}\n\n/*  */\n\nfunction normalizeChildren (\n  children,\n  ns,\n  nestedIndex\n) {\n  if (isPrimitive(children)) {\n    return [createTextVNode(children)]\n  }\n  if (Array.isArray(children)) {\n    var res = [];\n    for (var i = 0, l = children.length; i < l; i++) {\n      var c = children[i];\n      var last = res[res.length - 1];\n      //  nested\n      if (Array.isArray(c)) {\n        res.push.apply(res, normalizeChildren(c, ns, ((nestedIndex || '') + \"_\" + i)));\n      } else if (isPrimitive(c)) {\n        if (last && last.text) {\n          last.text += String(c);\n        } else if (c !== '') {\n          // convert primitive to vnode\n          res.push(createTextVNode(c));\n        }\n      } else if (c instanceof VNode) {\n        if (c.text && last && last.text) {\n          if (!last.isCloned) {\n            last.text += c.text;\n          }\n        } else {\n          // inherit parent namespace\n          if (ns) {\n            applyNS(c, ns);\n          }\n          // default key for nested array children (likely generated by v-for)\n          if (c.tag && c.key == null && nestedIndex != null) {\n            c.key = \"__vlist\" + nestedIndex + \"_\" + i + \"__\";\n          }\n          res.push(c);\n        }\n      }\n    }\n    return res\n  }\n}\n\nfunction createTextVNode (val) {\n  return new VNode(undefined, undefined, undefined, String(val))\n}\n\nfunction applyNS (vnode, ns) {\n  if (vnode.tag && !vnode.ns) {\n    vnode.ns = ns;\n    if (vnode.children) {\n      for (var i = 0, l = vnode.children.length; i < l; i++) {\n        applyNS(vnode.children[i], ns);\n      }\n    }\n  }\n}\n\n/*  */\n\nfunction getFirstComponentChild (children) {\n  return children && children.filter(function (c) { return c && c.componentOptions; })[0]\n}\n\n/*  */\n\nvar activeInstance = null;\n\nfunction initLifecycle (vm) {\n  var options = vm.$options;\n\n  // locate first non-abstract parent\n  var parent = options.parent;\n  if (parent && !options.abstract) {\n    while (parent.$options.abstract && parent.$parent) {\n      parent = parent.$parent;\n    }\n    parent.$children.push(vm);\n  }\n\n  vm.$parent = parent;\n  vm.$root = parent ? parent.$root : vm;\n\n  vm.$children = [];\n  vm.$refs = {};\n\n  vm._watcher = null;\n  vm._inactive = false;\n  vm._isMounted = false;\n  vm._isDestroyed = false;\n  vm._isBeingDestroyed = false;\n}\n\nfunction lifecycleMixin (Vue) {\n  Vue.prototype._mount = function (\n    el,\n    hydrating\n  ) {\n    var vm = this;\n    vm.$el = el;\n    if (!vm.$options.render) {\n      vm.$options.render = emptyVNode;\n      if (process.env.NODE_ENV !== 'production') {\n        /* istanbul ignore if */\n        if (vm.$options.template && vm.$options.template.charAt(0) !== '#') {\n          warn(\n            'You are using the runtime-only build of Vue where the template ' +\n            'option is not available. Either pre-compile the templates into ' +\n            'render functions, or use the compiler-included build.',\n            vm\n          );\n        } else {\n          warn(\n            'Failed to mount component: template or render function not defined.',\n            vm\n          );\n        }\n      }\n    }\n    callHook(vm, 'beforeMount');\n    vm._watcher = new Watcher(vm, function () {\n      vm._update(vm._render(), hydrating);\n    }, noop);\n    hydrating = false;\n    // manually mounted instance, call mounted on self\n    // mounted is called for render-created child components in its inserted hook\n    if (vm.$vnode == null) {\n      vm._isMounted = true;\n      callHook(vm, 'mounted');\n    }\n    return vm\n  };\n\n  Vue.prototype._update = function (vnode, hydrating) {\n    var vm = this;\n    if (vm._isMounted) {\n      callHook(vm, 'beforeUpdate');\n    }\n    var prevEl = vm.$el;\n    var prevActiveInstance = activeInstance;\n    activeInstance = vm;\n    var prevVnode = vm._vnode;\n    vm._vnode = vnode;\n    if (!prevVnode) {\n      // Vue.prototype.__patch__ is injected in entry points\n      // based on the rendering backend used.\n      vm.$el = vm.__patch__(vm.$el, vnode, hydrating);\n    } else {\n      vm.$el = vm.__patch__(prevVnode, vnode);\n    }\n    activeInstance = prevActiveInstance;\n    // update __vue__ reference\n    if (prevEl) {\n      prevEl.__vue__ = null;\n    }\n    if (vm.$el) {\n      vm.$el.__vue__ = vm;\n    }\n    // if parent is an HOC, update its $el as well\n    if (vm.$vnode && vm.$parent && vm.$vnode === vm.$parent._vnode) {\n      vm.$parent.$el = vm.$el;\n    }\n    if (vm._isMounted) {\n      callHook(vm, 'updated');\n    }\n  };\n\n  Vue.prototype._updateFromParent = function (\n    propsData,\n    listeners,\n    parentVnode,\n    renderChildren\n  ) {\n    var vm = this;\n    var hasChildren = !!(vm.$options._renderChildren || renderChildren);\n    vm.$options._parentVnode = parentVnode;\n    vm.$options._renderChildren = renderChildren;\n    // update props\n    if (propsData && vm.$options.props) {\n      observerState.shouldConvert = false;\n      if (process.env.NODE_ENV !== 'production') {\n        observerState.isSettingProps = true;\n      }\n      var propKeys = vm.$options._propKeys || [];\n      for (var i = 0; i < propKeys.length; i++) {\n        var key = propKeys[i];\n        vm[key] = validateProp(key, vm.$options.props, propsData, vm);\n      }\n      observerState.shouldConvert = true;\n      if (process.env.NODE_ENV !== 'production') {\n        observerState.isSettingProps = false;\n      }\n      vm.$options.propsData = propsData;\n    }\n    // update listeners\n    if (listeners) {\n      var oldListeners = vm.$options._parentListeners;\n      vm.$options._parentListeners = listeners;\n      vm._updateListeners(listeners, oldListeners);\n    }\n    // resolve slots + force update if has children\n    if (hasChildren) {\n      vm.$slots = resolveSlots(renderChildren, vm._renderContext);\n      vm.$forceUpdate();\n    }\n  };\n\n  Vue.prototype.$forceUpdate = function () {\n    var vm = this;\n    if (vm._watcher) {\n      vm._watcher.update();\n    }\n  };\n\n  Vue.prototype.$destroy = function () {\n    var vm = this;\n    if (vm._isBeingDestroyed) {\n      return\n    }\n    callHook(vm, 'beforeDestroy');\n    vm._isBeingDestroyed = true;\n    // remove self from parent\n    var parent = vm.$parent;\n    if (parent && !parent._isBeingDestroyed && !vm.$options.abstract) {\n      remove$1(parent.$children, vm);\n    }\n    // teardown watchers\n    if (vm._watcher) {\n      vm._watcher.teardown();\n    }\n    var i = vm._watchers.length;\n    while (i--) {\n      vm._watchers[i].teardown();\n    }\n    // remove reference from data ob\n    // frozen object may not have observer.\n    if (vm._data.__ob__) {\n      vm._data.__ob__.vmCount--;\n    }\n    // call the last hook...\n    vm._isDestroyed = true;\n    callHook(vm, 'destroyed');\n    // turn off all instance listeners.\n    vm.$off();\n    // remove __vue__ reference\n    if (vm.$el) {\n      vm.$el.__vue__ = null;\n    }\n    // invoke destroy hooks on current rendered tree\n    vm.__patch__(vm._vnode, null);\n  };\n}\n\nfunction callHook (vm, hook) {\n  var handlers = vm.$options[hook];\n  if (handlers) {\n    for (var i = 0, j = handlers.length; i < j; i++) {\n      handlers[i].call(vm);\n    }\n  }\n  vm.$emit('hook:' + hook);\n}\n\n/*  */\n\nvar hooks = { init: init, prepatch: prepatch, insert: insert, destroy: destroy$1 };\nvar hooksToMerge = Object.keys(hooks);\n\nfunction createComponent (\n  Ctor,\n  data,\n  context,\n  children,\n  tag\n) {\n  if (!Ctor) {\n    return\n  }\n\n  var baseCtor = context.$options._base;\n  if (isObject(Ctor)) {\n    Ctor = baseCtor.extend(Ctor);\n  }\n\n  if (typeof Ctor !== 'function') {\n    if (process.env.NODE_ENV !== 'production') {\n      warn((\"Invalid Component definition: \" + (String(Ctor))), context);\n    }\n    return\n  }\n\n  // async component\n  if (!Ctor.cid) {\n    if (Ctor.resolved) {\n      Ctor = Ctor.resolved;\n    } else {\n      Ctor = resolveAsyncComponent(Ctor, baseCtor, function () {\n        // it's ok to queue this on every render because\n        // $forceUpdate is buffered by the scheduler.\n        context.$forceUpdate();\n      });\n      if (!Ctor) {\n        // return nothing if this is indeed an async component\n        // wait for the callback to trigger parent update.\n        return\n      }\n    }\n  }\n\n  // resolve constructor options in case global mixins are applied after\n  // component constructor creation\n  resolveConstructorOptions(Ctor);\n\n  data = data || {};\n\n  // extract props\n  var propsData = extractProps(data, Ctor);\n\n  // functional component\n  if (Ctor.options.functional) {\n    return createFunctionalComponent(Ctor, propsData, data, context, children)\n  }\n\n  // extract listeners, since these needs to be treated as\n  // child component listeners instead of DOM listeners\n  var listeners = data.on;\n  // replace with listeners with .native modifier\n  data.on = data.nativeOn;\n\n  if (Ctor.options.abstract) {\n    // abstract components do not keep anything\n    // other than props & listeners\n    data = {};\n  }\n\n  // merge component management hooks onto the placeholder node\n  mergeHooks(data);\n\n  // return a placeholder vnode\n  var name = Ctor.options.name || tag;\n  var vnode = new VNode(\n    (\"vue-component-\" + (Ctor.cid) + (name ? (\"-\" + name) : '')),\n    data, undefined, undefined, undefined, undefined, context,\n    { Ctor: Ctor, propsData: propsData, listeners: listeners, tag: tag, children: children }\n  );\n  return vnode\n}\n\nfunction createFunctionalComponent (\n  Ctor,\n  propsData,\n  data,\n  context,\n  children\n) {\n  var props = {};\n  var propOptions = Ctor.options.props;\n  if (propOptions) {\n    for (var key in propOptions) {\n      props[key] = validateProp(key, propOptions, propsData);\n    }\n  }\n  var vnode = Ctor.options.render.call(\n    null,\n    // ensure the createElement function in functional components\n    // gets a unique context - this is necessary for correct named slot check\n    bind$1(createElement, { _self: Object.create(context) }),\n    {\n      props: props,\n      data: data,\n      parent: context,\n      children: normalizeChildren(children),\n      slots: function () { return resolveSlots(children, context); }\n    }\n  );\n  if (vnode instanceof VNode) {\n    vnode.functionalContext = context;\n    if (data.slot) {\n      (vnode.data || (vnode.data = {})).slot = data.slot;\n    }\n  }\n  return vnode\n}\n\nfunction createComponentInstanceForVnode (\n  vnode, // we know it's MountedComponentVNode but flow doesn't\n  parent // activeInstance in lifecycle state\n) {\n  var vnodeComponentOptions = vnode.componentOptions;\n  var options = {\n    _isComponent: true,\n    parent: parent,\n    propsData: vnodeComponentOptions.propsData,\n    _componentTag: vnodeComponentOptions.tag,\n    _parentVnode: vnode,\n    _parentListeners: vnodeComponentOptions.listeners,\n    _renderChildren: vnodeComponentOptions.children\n  };\n  // check inline-template render functions\n  var inlineTemplate = vnode.data.inlineTemplate;\n  if (inlineTemplate) {\n    options.render = inlineTemplate.render;\n    options.staticRenderFns = inlineTemplate.staticRenderFns;\n  }\n  return new vnodeComponentOptions.Ctor(options)\n}\n\nfunction init (vnode, hydrating) {\n  if (!vnode.child || vnode.child._isDestroyed) {\n    var child = vnode.child = createComponentInstanceForVnode(vnode, activeInstance);\n    child.$mount(hydrating ? vnode.elm : undefined, hydrating);\n  } else if (vnode.data.keepAlive) {\n    // kept-alive components, treat as a patch\n    var mountedNode = vnode; // work around flow\n    prepatch(mountedNode, mountedNode);\n  }\n}\n\nfunction prepatch (\n  oldVnode,\n  vnode\n) {\n  var options = vnode.componentOptions;\n  var child = vnode.child = oldVnode.child;\n  child._updateFromParent(\n    options.propsData, // updated props\n    options.listeners, // updated listeners\n    vnode, // new parent vnode\n    options.children // new children\n  );\n}\n\nfunction insert (vnode) {\n  if (!vnode.child._isMounted) {\n    vnode.child._isMounted = true;\n    callHook(vnode.child, 'mounted');\n  }\n  if (vnode.data.keepAlive) {\n    vnode.child._inactive = false;\n    callHook(vnode.child, 'activated');\n  }\n}\n\nfunction destroy$1 (vnode) {\n  if (!vnode.child._isDestroyed) {\n    if (!vnode.data.keepAlive) {\n      vnode.child.$destroy();\n    } else {\n      vnode.child._inactive = true;\n      callHook(vnode.child, 'deactivated');\n    }\n  }\n}\n\nfunction resolveAsyncComponent (\n  factory,\n  baseCtor,\n  cb\n) {\n  if (factory.requested) {\n    // pool callbacks\n    factory.pendingCallbacks.push(cb);\n  } else {\n    factory.requested = true;\n    var cbs = factory.pendingCallbacks = [cb];\n    var sync = true;\n\n    var resolve = function (res) {\n      if (isObject(res)) {\n        res = baseCtor.extend(res);\n      }\n      // cache resolved\n      factory.resolved = res;\n      // invoke callbacks only if this is not a synchronous resolve\n      // (async resolves are shimmed as synchronous during SSR)\n      if (!sync) {\n        for (var i = 0, l = cbs.length; i < l; i++) {\n          cbs[i](res);\n        }\n      }\n    };\n\n    var reject = function (reason) {\n      process.env.NODE_ENV !== 'production' && warn(\n        \"Failed to resolve async component: \" + (String(factory)) +\n        (reason ? (\"\\nReason: \" + reason) : '')\n      );\n    };\n\n    var res = factory(resolve, reject);\n\n    // handle promise\n    if (res && typeof res.then === 'function' && !factory.resolved) {\n      res.then(resolve, reject);\n    }\n\n    sync = false;\n    // return in case resolved synchronously\n    return factory.resolved\n  }\n}\n\nfunction extractProps (data, Ctor) {\n  // we are only extracting raw values here.\n  // validation and default values are handled in the child\n  // component itself.\n  var propOptions = Ctor.options.props;\n  if (!propOptions) {\n    return\n  }\n  var res = {};\n  var attrs = data.attrs;\n  var props = data.props;\n  var domProps = data.domProps;\n  if (attrs || props || domProps) {\n    for (var key in propOptions) {\n      var altKey = hyphenate(key);\n      checkProp(res, props, key, altKey, true) ||\n      checkProp(res, attrs, key, altKey) ||\n      checkProp(res, domProps, key, altKey);\n    }\n  }\n  return res\n}\n\nfunction checkProp (\n  res,\n  hash,\n  key,\n  altKey,\n  preserve\n) {\n  if (hash) {\n    if (hasOwn(hash, key)) {\n      res[key] = hash[key];\n      if (!preserve) {\n        delete hash[key];\n      }\n      return true\n    } else if (hasOwn(hash, altKey)) {\n      res[key] = hash[altKey];\n      if (!preserve) {\n        delete hash[altKey];\n      }\n      return true\n    }\n  }\n  return false\n}\n\nfunction mergeHooks (data) {\n  if (!data.hook) {\n    data.hook = {};\n  }\n  for (var i = 0; i < hooksToMerge.length; i++) {\n    var key = hooksToMerge[i];\n    var fromParent = data.hook[key];\n    var ours = hooks[key];\n    data.hook[key] = fromParent ? mergeHook$1(ours, fromParent) : ours;\n  }\n}\n\nfunction mergeHook$1 (a, b) {\n  // since all hooks have at most two args, use fixed args\n  // to avoid having to use fn.apply().\n  return function (_, __) {\n    a(_, __);\n    b(_, __);\n  }\n}\n\n/*  */\n\n// wrapper function for providing a more flexible interface\n// without getting yelled at by flow\nfunction createElement (\n  tag,\n  data,\n  children\n) {\n  if (data && (Array.isArray(data) || typeof data !== 'object')) {\n    children = data;\n    data = undefined;\n  }\n  // make sure to use real instance instead of proxy as context\n  return _createElement(this._self, tag, data, children)\n}\n\nfunction _createElement (\n  context,\n  tag,\n  data,\n  children\n) {\n  if (data && data.__ob__) {\n    process.env.NODE_ENV !== 'production' && warn(\n      \"Avoid using observed data object as vnode data: \" + (JSON.stringify(data)) + \"\\n\" +\n      'Always create fresh vnode data objects in each render!',\n      context\n    );\n    return\n  }\n  if (!tag) {\n    // in case of component :is set to falsy value\n    return emptyVNode()\n  }\n  if (typeof tag === 'string') {\n    var Ctor;\n    var ns = config.getTagNamespace(tag);\n    if (config.isReservedTag(tag)) {\n      // platform built-in elements\n      return new VNode(\n        tag, data, normalizeChildren(children, ns),\n        undefined, undefined, ns, context\n      )\n    } else if ((Ctor = resolveAsset(context.$options, 'components', tag))) {\n      // component\n      return createComponent(Ctor, data, context, children, tag)\n    } else {\n      // unknown or unlisted namespaced elements\n      // check at runtime because it may get assigned a namespace when its\n      // parent normalizes children\n      var childNs = tag === 'foreignObject' ? 'xhtml' : ns;\n      return new VNode(\n        tag, data, normalizeChildren(children, childNs),\n        undefined, undefined, ns, context\n      )\n    }\n  } else {\n    // direct component options / constructor\n    return createComponent(tag, data, context, children)\n  }\n}\n\n/*  */\n\nfunction initRender (vm) {\n  vm.$vnode = null; // the placeholder node in parent tree\n  vm._vnode = null; // the root of the child tree\n  vm._staticTrees = null;\n  vm._renderContext = vm.$options._parentVnode && vm.$options._parentVnode.context;\n  vm.$slots = resolveSlots(vm.$options._renderChildren, vm._renderContext);\n  // bind the public createElement fn to this instance\n  // so that we get proper render context inside it.\n  vm.$createElement = bind$1(createElement, vm);\n  if (vm.$options.el) {\n    vm.$mount(vm.$options.el);\n  }\n}\n\nfunction renderMixin (Vue) {\n  Vue.prototype.$nextTick = function (fn) {\n    nextTick(fn, this);\n  };\n\n  Vue.prototype._render = function () {\n    var vm = this;\n    var ref = vm.$options;\n    var render = ref.render;\n    var staticRenderFns = ref.staticRenderFns;\n    var _parentVnode = ref._parentVnode;\n\n    if (vm._isMounted) {\n      // clone slot nodes on re-renders\n      for (var key in vm.$slots) {\n        vm.$slots[key] = cloneVNodes(vm.$slots[key]);\n      }\n    }\n\n    if (staticRenderFns && !vm._staticTrees) {\n      vm._staticTrees = [];\n    }\n    // set parent vnode. this allows render functions to have access\n    // to the data on the placeholder node.\n    vm.$vnode = _parentVnode;\n    // render self\n    var vnode;\n    try {\n      vnode = render.call(vm._renderProxy, vm.$createElement);\n    } catch (e) {\n      if (process.env.NODE_ENV !== 'production') {\n        warn((\"Error when rendering \" + (formatComponentName(vm)) + \":\"));\n      }\n      /* istanbul ignore else */\n      if (config.errorHandler) {\n        config.errorHandler.call(null, e, vm);\n      } else {\n        if (config._isServer) {\n          throw e\n        } else {\n          console.error(e);\n        }\n      }\n      // return previous vnode to prevent render error causing blank component\n      vnode = vm._vnode;\n    }\n    // return empty vnode in case the render function errored out\n    if (!(vnode instanceof VNode)) {\n      if (process.env.NODE_ENV !== 'production' && Array.isArray(vnode)) {\n        warn(\n          'Multiple root nodes returned from render function. Render function ' +\n          'should return a single root node.',\n          vm\n        );\n      }\n      vnode = emptyVNode();\n    }\n    // set parent\n    vnode.parent = _parentVnode;\n    return vnode\n  };\n\n  // shorthands used in render functions\n  Vue.prototype._h = createElement;\n  // toString for mustaches\n  Vue.prototype._s = _toString;\n  // number conversion\n  Vue.prototype._n = toNumber;\n  // empty vnode\n  Vue.prototype._e = emptyVNode;\n  // loose equal\n  Vue.prototype._q = looseEqual;\n  // loose indexOf\n  Vue.prototype._i = looseIndexOf;\n\n  // render static tree by index\n  Vue.prototype._m = function renderStatic (\n    index,\n    isInFor\n  ) {\n    var tree = this._staticTrees[index];\n    // if has already-rendered static tree and not inside v-for,\n    // we can reuse the same tree by doing a shallow clone.\n    if (tree && !isInFor) {\n      return Array.isArray(tree)\n        ? cloneVNodes(tree)\n        : cloneVNode(tree)\n    }\n    // otherwise, render a fresh tree.\n    tree = this._staticTrees[index] = this.$options.staticRenderFns[index].call(this._renderProxy);\n    markStatic(tree, (\"__static__\" + index), false);\n    return tree\n  };\n\n  // mark node as static (v-once)\n  Vue.prototype._o = function markOnce (\n    tree,\n    index,\n    key\n  ) {\n    markStatic(tree, (\"__once__\" + index + (key ? (\"_\" + key) : \"\")), true);\n    return tree\n  };\n\n  function markStatic (tree, key, isOnce) {\n    if (Array.isArray(tree)) {\n      for (var i = 0; i < tree.length; i++) {\n        if (tree[i] && typeof tree[i] !== 'string') {\n          markStaticNode(tree[i], (key + \"_\" + i), isOnce);\n        }\n      }\n    } else {\n      markStaticNode(tree, key, isOnce);\n    }\n  }\n\n  function markStaticNode (node, key, isOnce) {\n    node.isStatic = true;\n    node.key = key;\n    node.isOnce = isOnce;\n  }\n\n  // filter resolution helper\n  var identity = function (_) { return _; };\n  Vue.prototype._f = function resolveFilter (id) {\n    return resolveAsset(this.$options, 'filters', id, true) || identity\n  };\n\n  // render v-for\n  Vue.prototype._l = function renderList (\n    val,\n    render\n  ) {\n    var ret, i, l, keys, key;\n    if (Array.isArray(val)) {\n      ret = new Array(val.length);\n      for (i = 0, l = val.length; i < l; i++) {\n        ret[i] = render(val[i], i);\n      }\n    } else if (typeof val === 'number') {\n      ret = new Array(val);\n      for (i = 0; i < val; i++) {\n        ret[i] = render(i + 1, i);\n      }\n    } else if (isObject(val)) {\n      keys = Object.keys(val);\n      ret = new Array(keys.length);\n      for (i = 0, l = keys.length; i < l; i++) {\n        key = keys[i];\n        ret[i] = render(val[key], key, i);\n      }\n    }\n    return ret\n  };\n\n  // renderSlot\n  Vue.prototype._t = function (\n    name,\n    fallback\n  ) {\n    var slotNodes = this.$slots[name];\n    // warn duplicate slot usage\n    if (slotNodes && process.env.NODE_ENV !== 'production') {\n      slotNodes._rendered && warn(\n        \"Duplicate presence of slot \\\"\" + name + \"\\\" found in the same render tree \" +\n        \"- this will likely cause render errors.\",\n        this\n      );\n      slotNodes._rendered = true;\n    }\n    return slotNodes || fallback\n  };\n\n  // apply v-bind object\n  Vue.prototype._b = function bindProps (\n    data,\n    tag,\n    value,\n    asProp\n  ) {\n    if (value) {\n      if (!isObject(value)) {\n        process.env.NODE_ENV !== 'production' && warn(\n          'v-bind without argument expects an Object or Array value',\n          this\n        );\n      } else {\n        if (Array.isArray(value)) {\n          value = toObject(value);\n        }\n        for (var key in value) {\n          if (key === 'class' || key === 'style') {\n            data[key] = value[key];\n          } else {\n            var hash = asProp || config.mustUseProp(tag, key)\n              ? data.domProps || (data.domProps = {})\n              : data.attrs || (data.attrs = {});\n            hash[key] = value[key];\n          }\n        }\n      }\n    }\n    return data\n  };\n\n  // expose v-on keyCodes\n  Vue.prototype._k = function getKeyCodes (key) {\n    return config.keyCodes[key]\n  };\n}\n\nfunction resolveSlots (\n  renderChildren,\n  context\n) {\n  var slots = {};\n  if (!renderChildren) {\n    return slots\n  }\n  var children = normalizeChildren(renderChildren) || [];\n  var defaultSlot = [];\n  var name, child;\n  for (var i = 0, l = children.length; i < l; i++) {\n    child = children[i];\n    // named slots should only be respected if the vnode was rendered in the\n    // same context.\n    if ((child.context === context || child.functionalContext === context) &&\n        child.data && (name = child.data.slot)) {\n      var slot = (slots[name] || (slots[name] = []));\n      if (child.tag === 'template') {\n        slot.push.apply(slot, child.children);\n      } else {\n        slot.push(child);\n      }\n    } else {\n      defaultSlot.push(child);\n    }\n  }\n  // ignore single whitespace\n  if (defaultSlot.length && !(\n    defaultSlot.length === 1 &&\n    (defaultSlot[0].text === ' ' || defaultSlot[0].isComment)\n  )) {\n    slots.default = defaultSlot;\n  }\n  return slots\n}\n\n/*  */\n\nfunction initEvents (vm) {\n  vm._events = Object.create(null);\n  // init parent attached events\n  var listeners = vm.$options._parentListeners;\n  var on = bind$1(vm.$on, vm);\n  var off = bind$1(vm.$off, vm);\n  vm._updateListeners = function (listeners, oldListeners) {\n    updateListeners(listeners, oldListeners || {}, on, off, vm);\n  };\n  if (listeners) {\n    vm._updateListeners(listeners);\n  }\n}\n\nfunction eventsMixin (Vue) {\n  Vue.prototype.$on = function (event, fn) {\n    var vm = this;(vm._events[event] || (vm._events[event] = [])).push(fn);\n    return vm\n  };\n\n  Vue.prototype.$once = function (event, fn) {\n    var vm = this;\n    function on () {\n      vm.$off(event, on);\n      fn.apply(vm, arguments);\n    }\n    on.fn = fn;\n    vm.$on(event, on);\n    return vm\n  };\n\n  Vue.prototype.$off = function (event, fn) {\n    var vm = this;\n    // all\n    if (!arguments.length) {\n      vm._events = Object.create(null);\n      return vm\n    }\n    // specific event\n    var cbs = vm._events[event];\n    if (!cbs) {\n      return vm\n    }\n    if (arguments.length === 1) {\n      vm._events[event] = null;\n      return vm\n    }\n    // specific handler\n    var cb;\n    var i = cbs.length;\n    while (i--) {\n      cb = cbs[i];\n      if (cb === fn || cb.fn === fn) {\n        cbs.splice(i, 1);\n        break\n      }\n    }\n    return vm\n  };\n\n  Vue.prototype.$emit = function (event) {\n    var vm = this;\n    var cbs = vm._events[event];\n    if (cbs) {\n      cbs = cbs.length > 1 ? toArray(cbs) : cbs;\n      var args = toArray(arguments, 1);\n      for (var i = 0, l = cbs.length; i < l; i++) {\n        cbs[i].apply(vm, args);\n      }\n    }\n    return vm\n  };\n}\n\n/*  */\n\nvar uid = 0;\n\nfunction initMixin (Vue) {\n  Vue.prototype._init = function (options) {\n    var vm = this;\n    // a uid\n    vm._uid = uid++;\n    // a flag to avoid this being observed\n    vm._isVue = true;\n    // merge options\n    if (options && options._isComponent) {\n      // optimize internal component instantiation\n      // since dynamic options merging is pretty slow, and none of the\n      // internal component options needs special treatment.\n      initInternalComponent(vm, options);\n    } else {\n      vm.$options = mergeOptions(\n        resolveConstructorOptions(vm.constructor),\n        options || {},\n        vm\n      );\n    }\n    /* istanbul ignore else */\n    if (process.env.NODE_ENV !== 'production') {\n      initProxy(vm);\n    } else {\n      vm._renderProxy = vm;\n    }\n    // expose real self\n    vm._self = vm;\n    initLifecycle(vm);\n    initEvents(vm);\n    callHook(vm, 'beforeCreate');\n    initState(vm);\n    callHook(vm, 'created');\n    initRender(vm);\n  };\n}\n\nfunction initInternalComponent (vm, options) {\n  var opts = vm.$options = Object.create(vm.constructor.options);\n  // doing this because it's faster than dynamic enumeration.\n  opts.parent = options.parent;\n  opts.propsData = options.propsData;\n  opts._parentVnode = options._parentVnode;\n  opts._parentListeners = options._parentListeners;\n  opts._renderChildren = options._renderChildren;\n  opts._componentTag = options._componentTag;\n  if (options.render) {\n    opts.render = options.render;\n    opts.staticRenderFns = options.staticRenderFns;\n  }\n}\n\nfunction resolveConstructorOptions (Ctor) {\n  var options = Ctor.options;\n  if (Ctor.super) {\n    var superOptions = Ctor.super.options;\n    var cachedSuperOptions = Ctor.superOptions;\n    var extendOptions = Ctor.extendOptions;\n    if (superOptions !== cachedSuperOptions) {\n      // super option changed\n      Ctor.superOptions = superOptions;\n      extendOptions.render = options.render;\n      extendOptions.staticRenderFns = options.staticRenderFns;\n      options = Ctor.options = mergeOptions(superOptions, extendOptions);\n      if (options.name) {\n        options.components[options.name] = Ctor;\n      }\n    }\n  }\n  return options\n}\n\nfunction Vue$2 (options) {\n  if (process.env.NODE_ENV !== 'production' &&\n    !(this instanceof Vue$2)) {\n    warn('Vue is a constructor and should be called with the `new` keyword');\n  }\n  this._init(options);\n}\n\ninitMixin(Vue$2);\nstateMixin(Vue$2);\neventsMixin(Vue$2);\nlifecycleMixin(Vue$2);\nrenderMixin(Vue$2);\n\nvar warn = noop;\nvar formatComponentName;\n\nif (process.env.NODE_ENV !== 'production') {\n  var hasConsole = typeof console !== 'undefined';\n\n  warn = function (msg, vm) {\n    if (hasConsole && (!config.silent)) {\n      console.error(\"[Vue warn]: \" + msg + \" \" + (\n        vm ? formatLocation(formatComponentName(vm)) : ''\n      ));\n    }\n  };\n\n  formatComponentName = function (vm) {\n    if (vm.$root === vm) {\n      return 'root instance'\n    }\n    var name = vm._isVue\n      ? vm.$options.name || vm.$options._componentTag\n      : vm.name;\n    return (\n      (name ? (\"component <\" + name + \">\") : \"anonymous component\") +\n      (vm._isVue && vm.$options.__file ? (\" at \" + (vm.$options.__file)) : '')\n    )\n  };\n\n  var formatLocation = function (str) {\n    if (str === 'anonymous component') {\n      str += \" - use the \\\"name\\\" option for better debugging messages.\";\n    }\n    return (\"\\n(found in \" + str + \")\")\n  };\n}\n\n/*  */\n\n/**\n * Option overwriting strategies are functions that handle\n * how to merge a parent option value and a child option\n * value into the final value.\n */\nvar strats = config.optionMergeStrategies;\n\n/**\n * Options with restrictions\n */\nif (process.env.NODE_ENV !== 'production') {\n  strats.el = strats.propsData = function (parent, child, vm, key) {\n    if (!vm) {\n      warn(\n        \"option \\\"\" + key + \"\\\" can only be used during instance \" +\n        'creation with the `new` keyword.'\n      );\n    }\n    return defaultStrat(parent, child)\n  };\n}\n\n/**\n * Helper that recursively merges two data objects together.\n */\nfunction mergeData (to, from) {\n  if (!from) { return to }\n  var key, toVal, fromVal;\n  var keys = Object.keys(from);\n  for (var i = 0; i < keys.length; i++) {\n    key = keys[i];\n    toVal = to[key];\n    fromVal = from[key];\n    if (!hasOwn(to, key)) {\n      set(to, key, fromVal);\n    } else if (isPlainObject(toVal) && isPlainObject(fromVal)) {\n      mergeData(toVal, fromVal);\n    }\n  }\n  return to\n}\n\n/**\n * Data\n */\nstrats.data = function (\n  parentVal,\n  childVal,\n  vm\n) {\n  if (!vm) {\n    // in a Vue.extend merge, both should be functions\n    if (!childVal) {\n      return parentVal\n    }\n    if (typeof childVal !== 'function') {\n      process.env.NODE_ENV !== 'production' && warn(\n        'The \"data\" option should be a function ' +\n        'that returns a per-instance value in component ' +\n        'definitions.',\n        vm\n      );\n      return parentVal\n    }\n    if (!parentVal) {\n      return childVal\n    }\n    // when parentVal & childVal are both present,\n    // we need to return a function that returns the\n    // merged result of both functions... no need to\n    // check if parentVal is a function here because\n    // it has to be a function to pass previous merges.\n    return function mergedDataFn () {\n      return mergeData(\n        childVal.call(this),\n        parentVal.call(this)\n      )\n    }\n  } else if (parentVal || childVal) {\n    return function mergedInstanceDataFn () {\n      // instance merge\n      var instanceData = typeof childVal === 'function'\n        ? childVal.call(vm)\n        : childVal;\n      var defaultData = typeof parentVal === 'function'\n        ? parentVal.call(vm)\n        : undefined;\n      if (instanceData) {\n        return mergeData(instanceData, defaultData)\n      } else {\n        return defaultData\n      }\n    }\n  }\n};\n\n/**\n * Hooks and param attributes are merged as arrays.\n */\nfunction mergeHook (\n  parentVal,\n  childVal\n) {\n  return childVal\n    ? parentVal\n      ? parentVal.concat(childVal)\n      : Array.isArray(childVal)\n        ? childVal\n        : [childVal]\n    : parentVal\n}\n\nconfig._lifecycleHooks.forEach(function (hook) {\n  strats[hook] = mergeHook;\n});\n\n/**\n * Assets\n *\n * When a vm is present (instance creation), we need to do\n * a three-way merge between constructor options, instance\n * options and parent options.\n */\nfunction mergeAssets (parentVal, childVal) {\n  var res = Object.create(parentVal || null);\n  return childVal\n    ? extend(res, childVal)\n    : res\n}\n\nconfig._assetTypes.forEach(function (type) {\n  strats[type + 's'] = mergeAssets;\n});\n\n/**\n * Watchers.\n *\n * Watchers hashes should not overwrite one\n * another, so we merge them as arrays.\n */\nstrats.watch = function (parentVal, childVal) {\n  /* istanbul ignore if */\n  if (!childVal) { return parentVal }\n  if (!parentVal) { return childVal }\n  var ret = {};\n  extend(ret, parentVal);\n  for (var key in childVal) {\n    var parent = ret[key];\n    var child = childVal[key];\n    if (parent && !Array.isArray(parent)) {\n      parent = [parent];\n    }\n    ret[key] = parent\n      ? parent.concat(child)\n      : [child];\n  }\n  return ret\n};\n\n/**\n * Other object hashes.\n */\nstrats.props =\nstrats.methods =\nstrats.computed = function (parentVal, childVal) {\n  if (!childVal) { return parentVal }\n  if (!parentVal) { return childVal }\n  var ret = Object.create(null);\n  extend(ret, parentVal);\n  extend(ret, childVal);\n  return ret\n};\n\n/**\n * Default strategy.\n */\nvar defaultStrat = function (parentVal, childVal) {\n  return childVal === undefined\n    ? parentVal\n    : childVal\n};\n\n/**\n * Validate component names\n */\nfunction checkComponents (options) {\n  for (var key in options.components) {\n    var lower = key.toLowerCase();\n    if (isBuiltInTag(lower) || config.isReservedTag(lower)) {\n      warn(\n        'Do not use built-in or reserved HTML elements as component ' +\n        'id: ' + key\n      );\n    }\n  }\n}\n\n/**\n * Ensure all props option syntax are normalized into the\n * Object-based format.\n */\nfunction normalizeProps (options) {\n  var props = options.props;\n  if (!props) { return }\n  var res = {};\n  var i, val, name;\n  if (Array.isArray(props)) {\n    i = props.length;\n    while (i--) {\n      val = props[i];\n      if (typeof val === 'string') {\n        name = camelize(val);\n        res[name] = { type: null };\n      } else if (process.env.NODE_ENV !== 'production') {\n        warn('props must be strings when using array syntax.');\n      }\n    }\n  } else if (isPlainObject(props)) {\n    for (var key in props) {\n      val = props[key];\n      name = camelize(key);\n      res[name] = isPlainObject(val)\n        ? val\n        : { type: val };\n    }\n  }\n  options.props = res;\n}\n\n/**\n * Normalize raw function directives into object format.\n */\nfunction normalizeDirectives (options) {\n  var dirs = options.directives;\n  if (dirs) {\n    for (var key in dirs) {\n      var def = dirs[key];\n      if (typeof def === 'function') {\n        dirs[key] = { bind: def, update: def };\n      }\n    }\n  }\n}\n\n/**\n * Merge two option objects into a new one.\n * Core utility used in both instantiation and inheritance.\n */\nfunction mergeOptions (\n  parent,\n  child,\n  vm\n) {\n  if (process.env.NODE_ENV !== 'production') {\n    checkComponents(child);\n  }\n  normalizeProps(child);\n  normalizeDirectives(child);\n  var extendsFrom = child.extends;\n  if (extendsFrom) {\n    parent = typeof extendsFrom === 'function'\n      ? mergeOptions(parent, extendsFrom.options, vm)\n      : mergeOptions(parent, extendsFrom, vm);\n  }\n  if (child.mixins) {\n    for (var i = 0, l = child.mixins.length; i < l; i++) {\n      var mixin = child.mixins[i];\n      if (mixin.prototype instanceof Vue$2) {\n        mixin = mixin.options;\n      }\n      parent = mergeOptions(parent, mixin, vm);\n    }\n  }\n  var options = {};\n  var key;\n  for (key in parent) {\n    mergeField(key);\n  }\n  for (key in child) {\n    if (!hasOwn(parent, key)) {\n      mergeField(key);\n    }\n  }\n  function mergeField (key) {\n    var strat = strats[key] || defaultStrat;\n    options[key] = strat(parent[key], child[key], vm, key);\n  }\n  return options\n}\n\n/**\n * Resolve an asset.\n * This function is used because child instances need access\n * to assets defined in its ancestor chain.\n */\nfunction resolveAsset (\n  options,\n  type,\n  id,\n  warnMissing\n) {\n  /* istanbul ignore if */\n  if (typeof id !== 'string') {\n    return\n  }\n  var assets = options[type];\n  var res = assets[id] ||\n    // camelCase ID\n    assets[camelize(id)] ||\n    // Pascal Case ID\n    assets[capitalize(camelize(id))];\n  if (process.env.NODE_ENV !== 'production' && warnMissing && !res) {\n    warn(\n      'Failed to resolve ' + type.slice(0, -1) + ': ' + id,\n      options\n    );\n  }\n  return res\n}\n\n/*  */\n\nfunction validateProp (\n  key,\n  propOptions,\n  propsData,\n  vm\n) {\n  var prop = propOptions[key];\n  var absent = !hasOwn(propsData, key);\n  var value = propsData[key];\n  // handle boolean props\n  if (isBooleanType(prop.type)) {\n    if (absent && !hasOwn(prop, 'default')) {\n      value = false;\n    } else if (value === '' || value === hyphenate(key)) {\n      value = true;\n    }\n  }\n  // check default value\n  if (value === undefined) {\n    value = getPropDefaultValue(vm, prop, key);\n    // since the default value is a fresh copy,\n    // make sure to observe it.\n    var prevShouldConvert = observerState.shouldConvert;\n    observerState.shouldConvert = true;\n    observe(value);\n    observerState.shouldConvert = prevShouldConvert;\n  }\n  if (process.env.NODE_ENV !== 'production') {\n    assertProp(prop, key, value, vm, absent);\n  }\n  return value\n}\n\n/**\n * Get the default value of a prop.\n */\nfunction getPropDefaultValue (vm, prop, key) {\n  // no default, return undefined\n  if (!hasOwn(prop, 'default')) {\n    return undefined\n  }\n  var def = prop.default;\n  // warn against non-factory defaults for Object & Array\n  if (isObject(def)) {\n    process.env.NODE_ENV !== 'production' && warn(\n      'Invalid default value for prop \"' + key + '\": ' +\n      'Props with type Object/Array must use a factory function ' +\n      'to return the default value.',\n      vm\n    );\n  }\n  // the raw prop value was also undefined from previous render,\n  // return previous default value to avoid unnecessary watcher trigger\n  if (vm && vm.$options.propsData &&\n    vm.$options.propsData[key] === undefined &&\n    vm[key] !== undefined) {\n    return vm[key]\n  }\n  // call factory function for non-Function types\n  return typeof def === 'function' && prop.type !== Function\n    ? def.call(vm)\n    : def\n}\n\n/**\n * Assert whether a prop is valid.\n */\nfunction assertProp (\n  prop,\n  name,\n  value,\n  vm,\n  absent\n) {\n  if (prop.required && absent) {\n    warn(\n      'Missing required prop: \"' + name + '\"',\n      vm\n    );\n    return\n  }\n  if (value == null && !prop.required) {\n    return\n  }\n  var type = prop.type;\n  var valid = !type || type === true;\n  var expectedTypes = [];\n  if (type) {\n    if (!Array.isArray(type)) {\n      type = [type];\n    }\n    for (var i = 0; i < type.length && !valid; i++) {\n      var assertedType = assertType(value, type[i]);\n      expectedTypes.push(assertedType.expectedType);\n      valid = assertedType.valid;\n    }\n  }\n  if (!valid) {\n    warn(\n      'Invalid prop: type check failed for prop \"' + name + '\".' +\n      ' Expected ' + expectedTypes.map(capitalize).join(', ') +\n      ', got ' + Object.prototype.toString.call(value).slice(8, -1) + '.',\n      vm\n    );\n    return\n  }\n  var validator = prop.validator;\n  if (validator) {\n    if (!validator(value)) {\n      warn(\n        'Invalid prop: custom validator check failed for prop \"' + name + '\".',\n        vm\n      );\n    }\n  }\n}\n\n/**\n * Assert the type of a value\n */\nfunction assertType (value, type) {\n  var valid;\n  var expectedType = getType(type);\n  if (expectedType === 'String') {\n    valid = typeof value === (expectedType = 'string');\n  } else if (expectedType === 'Number') {\n    valid = typeof value === (expectedType = 'number');\n  } else if (expectedType === 'Boolean') {\n    valid = typeof value === (expectedType = 'boolean');\n  } else if (expectedType === 'Function') {\n    valid = typeof value === (expectedType = 'function');\n  } else if (expectedType === 'Object') {\n    valid = isPlainObject(value);\n  } else if (expectedType === 'Array') {\n    valid = Array.isArray(value);\n  } else {\n    valid = value instanceof type;\n  }\n  return {\n    valid: valid,\n    expectedType: expectedType\n  }\n}\n\n/**\n * Use function string name to check built-in types,\n * because a simple equality check will fail when running\n * across different vms / iframes.\n */\nfunction getType (fn) {\n  var match = fn && fn.toString().match(/^\\s*function (\\w+)/);\n  return match && match[1]\n}\n\nfunction isBooleanType (fn) {\n  if (!Array.isArray(fn)) {\n    return getType(fn) === 'Boolean'\n  }\n  for (var i = 0, len = fn.length; i < len; i++) {\n    if (getType(fn[i]) === 'Boolean') {\n      return true\n    }\n  }\n  /* istanbul ignore next */\n  return false\n}\n\n\n\nvar util = Object.freeze({\n\tdefineReactive: defineReactive$$1,\n\t_toString: _toString,\n\ttoNumber: toNumber,\n\tmakeMap: makeMap,\n\tisBuiltInTag: isBuiltInTag,\n\tremove: remove$1,\n\thasOwn: hasOwn,\n\tisPrimitive: isPrimitive,\n\tcached: cached,\n\tcamelize: camelize,\n\tcapitalize: capitalize,\n\thyphenate: hyphenate,\n\tbind: bind$1,\n\ttoArray: toArray,\n\textend: extend,\n\tisObject: isObject,\n\tisPlainObject: isPlainObject,\n\ttoObject: toObject,\n\tnoop: noop,\n\tno: no,\n\tgenStaticKeys: genStaticKeys,\n\tlooseEqual: looseEqual,\n\tlooseIndexOf: looseIndexOf,\n\tisReserved: isReserved,\n\tdef: def,\n\tparsePath: parsePath,\n\thasProto: hasProto,\n\tinBrowser: inBrowser,\n\tUA: UA,\n\tisIE: isIE,\n\tisIE9: isIE9,\n\tisEdge: isEdge,\n\tisAndroid: isAndroid,\n\tisIOS: isIOS,\n\tdevtools: devtools,\n\tnextTick: nextTick,\n\tget _Set () { return _Set; },\n\tmergeOptions: mergeOptions,\n\tresolveAsset: resolveAsset,\n\tget warn () { return warn; },\n\tget formatComponentName () { return formatComponentName; },\n\tvalidateProp: validateProp\n});\n\n/*  */\n\nfunction initUse (Vue) {\n  Vue.use = function (plugin) {\n    /* istanbul ignore if */\n    if (plugin.installed) {\n      return\n    }\n    // additional parameters\n    var args = toArray(arguments, 1);\n    args.unshift(this);\n    if (typeof plugin.install === 'function') {\n      plugin.install.apply(plugin, args);\n    } else {\n      plugin.apply(null, args);\n    }\n    plugin.installed = true;\n    return this\n  };\n}\n\n/*  */\n\nfunction initMixin$1 (Vue) {\n  Vue.mixin = function (mixin) {\n    this.options = mergeOptions(this.options, mixin);\n  };\n}\n\n/*  */\n\nfunction initExtend (Vue) {\n  /**\n   * Each instance constructor, including Vue, has a unique\n   * cid. This enables us to create wrapped \"child\n   * constructors\" for prototypal inheritance and cache them.\n   */\n  Vue.cid = 0;\n  var cid = 1;\n\n  /**\n   * Class inheritance\n   */\n  Vue.extend = function (extendOptions) {\n    extendOptions = extendOptions || {};\n    var Super = this;\n    var SuperId = Super.cid;\n    var cachedCtors = extendOptions._Ctor || (extendOptions._Ctor = {});\n    if (cachedCtors[SuperId]) {\n      return cachedCtors[SuperId]\n    }\n    var name = extendOptions.name || Super.options.name;\n    if (process.env.NODE_ENV !== 'production') {\n      if (!/^[a-zA-Z][\\w-]*$/.test(name)) {\n        warn(\n          'Invalid component name: \"' + name + '\". Component names ' +\n          'can only contain alphanumeric characaters and the hyphen.'\n        );\n      }\n    }\n    var Sub = function VueComponent (options) {\n      this._init(options);\n    };\n    Sub.prototype = Object.create(Super.prototype);\n    Sub.prototype.constructor = Sub;\n    Sub.cid = cid++;\n    Sub.options = mergeOptions(\n      Super.options,\n      extendOptions\n    );\n    Sub['super'] = Super;\n    // allow further extension/mixin/plugin usage\n    Sub.extend = Super.extend;\n    Sub.mixin = Super.mixin;\n    Sub.use = Super.use;\n    // create asset registers, so extended classes\n    // can have their private assets too.\n    config._assetTypes.forEach(function (type) {\n      Sub[type] = Super[type];\n    });\n    // enable recursive self-lookup\n    if (name) {\n      Sub.options.components[name] = Sub;\n    }\n    // keep a reference to the super options at extension time.\n    // later at instantiation we can check if Super's options have\n    // been updated.\n    Sub.superOptions = Super.options;\n    Sub.extendOptions = extendOptions;\n    // cache constructor\n    cachedCtors[SuperId] = Sub;\n    return Sub\n  };\n}\n\n/*  */\n\nfunction initAssetRegisters (Vue) {\n  /**\n   * Create asset registration methods.\n   */\n  config._assetTypes.forEach(function (type) {\n    Vue[type] = function (\n      id,\n      definition\n    ) {\n      if (!definition) {\n        return this.options[type + 's'][id]\n      } else {\n        /* istanbul ignore if */\n        if (process.env.NODE_ENV !== 'production') {\n          if (type === 'component' && config.isReservedTag(id)) {\n            warn(\n              'Do not use built-in or reserved HTML elements as component ' +\n              'id: ' + id\n            );\n          }\n        }\n        if (type === 'component' && isPlainObject(definition)) {\n          definition.name = definition.name || id;\n          definition = this.options._base.extend(definition);\n        }\n        if (type === 'directive' && typeof definition === 'function') {\n          definition = { bind: definition, update: definition };\n        }\n        this.options[type + 's'][id] = definition;\n        return definition\n      }\n    };\n  });\n}\n\nvar KeepAlive = {\n  name: 'keep-alive',\n  abstract: true,\n  created: function created () {\n    this.cache = Object.create(null);\n  },\n  render: function render () {\n    var vnode = getFirstComponentChild(this.$slots.default);\n    if (vnode && vnode.componentOptions) {\n      var opts = vnode.componentOptions;\n      var key = vnode.key == null\n        // same constructor may get registered as different local components\n        // so cid alone is not enough (#3269)\n        ? opts.Ctor.cid + '::' + opts.tag\n        : vnode.key;\n      if (this.cache[key]) {\n        vnode.child = this.cache[key].child;\n      } else {\n        this.cache[key] = vnode;\n      }\n      vnode.data.keepAlive = true;\n    }\n    return vnode\n  },\n  destroyed: function destroyed () {\n    var this$1 = this;\n\n    for (var key in this.cache) {\n      var vnode = this$1.cache[key];\n      callHook(vnode.child, 'deactivated');\n      vnode.child.$destroy();\n    }\n  }\n};\n\nvar builtInComponents = {\n  KeepAlive: KeepAlive\n};\n\n/*  */\n\nfunction initGlobalAPI (Vue) {\n  // config\n  var configDef = {};\n  configDef.get = function () { return config; };\n  if (process.env.NODE_ENV !== 'production') {\n    configDef.set = function () {\n      warn(\n        'Do not replace the Vue.config object, set individual fields instead.'\n      );\n    };\n  }\n  Object.defineProperty(Vue, 'config', configDef);\n  Vue.util = util;\n  Vue.set = set;\n  Vue.delete = del;\n  Vue.nextTick = nextTick;\n\n  Vue.options = Object.create(null);\n  config._assetTypes.forEach(function (type) {\n    Vue.options[type + 's'] = Object.create(null);\n  });\n\n  // this is used to identify the \"base\" constructor to extend all plain-object\n  // components with in Weex's multi-instance scenarios.\n  Vue.options._base = Vue;\n\n  extend(Vue.options.components, builtInComponents);\n\n  initUse(Vue);\n  initMixin$1(Vue);\n  initExtend(Vue);\n  initAssetRegisters(Vue);\n}\n\ninitGlobalAPI(Vue$2);\n\nObject.defineProperty(Vue$2.prototype, '$isServer', {\n  get: function () { return config._isServer; }\n});\n\nVue$2.version = '2.0.8';\n\n/*  */\n\n// attributes that should be using props for binding\nvar mustUseProp = function (tag, attr) {\n  return (\n    (attr === 'value' && (tag === 'input' || tag === 'textarea' || tag === 'option')) ||\n    (attr === 'selected' && tag === 'option') ||\n    (attr === 'checked' && tag === 'input') ||\n    (attr === 'muted' && tag === 'video')\n  )\n};\n\nvar isEnumeratedAttr = makeMap('contenteditable,draggable,spellcheck');\n\nvar isBooleanAttr = makeMap(\n  'allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare,' +\n  'default,defaultchecked,defaultmuted,defaultselected,defer,disabled,' +\n  'enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple,' +\n  'muted,nohref,noresize,noshade,novalidate,nowrap,open,pauseonexit,readonly,' +\n  'required,reversed,scoped,seamless,selected,sortable,translate,' +\n  'truespeed,typemustmatch,visible'\n);\n\nvar isAttr = makeMap(\n  'accept,accept-charset,accesskey,action,align,alt,async,autocomplete,' +\n  'autofocus,autoplay,autosave,bgcolor,border,buffered,challenge,charset,' +\n  'checked,cite,class,code,codebase,color,cols,colspan,content,http-equiv,' +\n  'name,contenteditable,contextmenu,controls,coords,data,datetime,default,' +\n  'defer,dir,dirname,disabled,download,draggable,dropzone,enctype,method,for,' +\n  'form,formaction,headers,<th>,height,hidden,high,href,hreflang,http-equiv,' +\n  'icon,id,ismap,itemprop,keytype,kind,label,lang,language,list,loop,low,' +\n  'manifest,max,maxlength,media,method,GET,POST,min,multiple,email,file,' +\n  'muted,name,novalidate,open,optimum,pattern,ping,placeholder,poster,' +\n  'preload,radiogroup,readonly,rel,required,reversed,rows,rowspan,sandbox,' +\n  'scope,scoped,seamless,selected,shape,size,type,text,password,sizes,span,' +\n  'spellcheck,src,srcdoc,srclang,srcset,start,step,style,summary,tabindex,' +\n  'target,title,type,usemap,value,width,wrap'\n);\n\n\n\nvar xlinkNS = 'http://www.w3.org/1999/xlink';\n\nvar isXlink = function (name) {\n  return name.charAt(5) === ':' && name.slice(0, 5) === 'xlink'\n};\n\nvar getXlinkProp = function (name) {\n  return isXlink(name) ? name.slice(6, name.length) : ''\n};\n\nvar isFalsyAttrValue = function (val) {\n  return val == null || val === false\n};\n\n/*  */\n\nfunction genClassForVnode (vnode) {\n  var data = vnode.data;\n  var parentNode = vnode;\n  var childNode = vnode;\n  while (childNode.child) {\n    childNode = childNode.child._vnode;\n    if (childNode.data) {\n      data = mergeClassData(childNode.data, data);\n    }\n  }\n  while ((parentNode = parentNode.parent)) {\n    if (parentNode.data) {\n      data = mergeClassData(data, parentNode.data);\n    }\n  }\n  return genClassFromData(data)\n}\n\nfunction mergeClassData (child, parent) {\n  return {\n    staticClass: concat(child.staticClass, parent.staticClass),\n    class: child.class\n      ? [child.class, parent.class]\n      : parent.class\n  }\n}\n\nfunction genClassFromData (data) {\n  var dynamicClass = data.class;\n  var staticClass = data.staticClass;\n  if (staticClass || dynamicClass) {\n    return concat(staticClass, stringifyClass(dynamicClass))\n  }\n  /* istanbul ignore next */\n  return ''\n}\n\nfunction concat (a, b) {\n  return a ? b ? (a + ' ' + b) : a : (b || '')\n}\n\nfunction stringifyClass (value) {\n  var res = '';\n  if (!value) {\n    return res\n  }\n  if (typeof value === 'string') {\n    return value\n  }\n  if (Array.isArray(value)) {\n    var stringified;\n    for (var i = 0, l = value.length; i < l; i++) {\n      if (value[i]) {\n        if ((stringified = stringifyClass(value[i]))) {\n          res += stringified + ' ';\n        }\n      }\n    }\n    return res.slice(0, -1)\n  }\n  if (isObject(value)) {\n    for (var key in value) {\n      if (value[key]) { res += key + ' '; }\n    }\n    return res.slice(0, -1)\n  }\n  /* istanbul ignore next */\n  return res\n}\n\n/*  */\n\nvar namespaceMap = {\n  svg: 'http://www.w3.org/2000/svg',\n  math: 'http://www.w3.org/1998/Math/MathML',\n  xhtml: 'http://www.w3.org/1999/xhtml'\n};\n\nvar isHTMLTag = makeMap(\n  'html,body,base,head,link,meta,style,title,' +\n  'address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,' +\n  'div,dd,dl,dt,figcaption,figure,hr,img,li,main,ol,p,pre,ul,' +\n  'a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,' +\n  's,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,' +\n  'embed,object,param,source,canvas,script,noscript,del,ins,' +\n  'caption,col,colgroup,table,thead,tbody,td,th,tr,' +\n  'button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,' +\n  'output,progress,select,textarea,' +\n  'details,dialog,menu,menuitem,summary,' +\n  'content,element,shadow,template'\n);\n\nvar isUnaryTag = makeMap(\n  'area,base,br,col,embed,frame,hr,img,input,isindex,keygen,' +\n  'link,meta,param,source,track,wbr',\n  true\n);\n\n// Elements that you can, intentionally, leave open\n// (and which close themselves)\nvar canBeLeftOpenTag = makeMap(\n  'colgroup,dd,dt,li,options,p,td,tfoot,th,thead,tr,source',\n  true\n);\n\n// HTML5 tags https://html.spec.whatwg.org/multipage/indices.html#elements-3\n// Phrasing Content https://html.spec.whatwg.org/multipage/dom.html#phrasing-content\nvar isNonPhrasingTag = makeMap(\n  'address,article,aside,base,blockquote,body,caption,col,colgroup,dd,' +\n  'details,dialog,div,dl,dt,fieldset,figcaption,figure,footer,form,' +\n  'h1,h2,h3,h4,h5,h6,head,header,hgroup,hr,html,legend,li,menuitem,meta,' +\n  'optgroup,option,param,rp,rt,source,style,summary,tbody,td,tfoot,th,thead,' +\n  'title,tr,track',\n  true\n);\n\n// this map is intentionally selective, only covering SVG elements that may\n// contain child elements.\nvar isSVG = makeMap(\n  'svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,font,' +\n  'font-face,g,glyph,image,line,marker,mask,missing-glyph,path,pattern,' +\n  'polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view',\n  true\n);\n\n\n\nvar isReservedTag = function (tag) {\n  return isHTMLTag(tag) || isSVG(tag)\n};\n\nfunction getTagNamespace (tag) {\n  if (isSVG(tag)) {\n    return 'svg'\n  }\n  // basic support for MathML\n  // note it doesn't support other MathML elements being component roots\n  if (tag === 'math') {\n    return 'math'\n  }\n}\n\nvar unknownElementCache = Object.create(null);\nfunction isUnknownElement (tag) {\n  /* istanbul ignore if */\n  if (!inBrowser) {\n    return true\n  }\n  if (isReservedTag(tag)) {\n    return false\n  }\n  tag = tag.toLowerCase();\n  /* istanbul ignore if */\n  if (unknownElementCache[tag] != null) {\n    return unknownElementCache[tag]\n  }\n  var el = document.createElement(tag);\n  if (tag.indexOf('-') > -1) {\n    // http://stackoverflow.com/a/28210364/1070244\n    return (unknownElementCache[tag] = (\n      el.constructor === window.HTMLUnknownElement ||\n      el.constructor === window.HTMLElement\n    ))\n  } else {\n    return (unknownElementCache[tag] = /HTMLUnknownElement/.test(el.toString()))\n  }\n}\n\n/*  */\n\n/**\n * Query an element selector if it's not an element already.\n */\nfunction query (el) {\n  if (typeof el === 'string') {\n    var selector = el;\n    el = document.querySelector(el);\n    if (!el) {\n      process.env.NODE_ENV !== 'production' && warn(\n        'Cannot find element: ' + selector\n      );\n      return document.createElement('div')\n    }\n  }\n  return el\n}\n\n/*  */\n\nfunction createElement$1 (tagName, vnode) {\n  var elm = document.createElement(tagName);\n  if (tagName !== 'select') {\n    return elm\n  }\n  if (vnode.data && vnode.data.attrs && 'multiple' in vnode.data.attrs) {\n    elm.setAttribute('multiple', 'multiple');\n  }\n  return elm\n}\n\nfunction createElementNS (namespace, tagName) {\n  return document.createElementNS(namespaceMap[namespace], tagName)\n}\n\nfunction createTextNode (text) {\n  return document.createTextNode(text)\n}\n\nfunction createComment (text) {\n  return document.createComment(text)\n}\n\nfunction insertBefore (parentNode, newNode, referenceNode) {\n  parentNode.insertBefore(newNode, referenceNode);\n}\n\nfunction removeChild (node, child) {\n  node.removeChild(child);\n}\n\nfunction appendChild (node, child) {\n  node.appendChild(child);\n}\n\nfunction parentNode (node) {\n  return node.parentNode\n}\n\nfunction nextSibling (node) {\n  return node.nextSibling\n}\n\nfunction tagName (node) {\n  return node.tagName\n}\n\nfunction setTextContent (node, text) {\n  node.textContent = text;\n}\n\nfunction childNodes (node) {\n  return node.childNodes\n}\n\nfunction setAttribute (node, key, val) {\n  node.setAttribute(key, val);\n}\n\n\nvar nodeOps = Object.freeze({\n\tcreateElement: createElement$1,\n\tcreateElementNS: createElementNS,\n\tcreateTextNode: createTextNode,\n\tcreateComment: createComment,\n\tinsertBefore: insertBefore,\n\tremoveChild: removeChild,\n\tappendChild: appendChild,\n\tparentNode: parentNode,\n\tnextSibling: nextSibling,\n\ttagName: tagName,\n\tsetTextContent: setTextContent,\n\tchildNodes: childNodes,\n\tsetAttribute: setAttribute\n});\n\n/*  */\n\nvar ref = {\n  create: function create (_, vnode) {\n    registerRef(vnode);\n  },\n  update: function update (oldVnode, vnode) {\n    if (oldVnode.data.ref !== vnode.data.ref) {\n      registerRef(oldVnode, true);\n      registerRef(vnode);\n    }\n  },\n  destroy: function destroy (vnode) {\n    registerRef(vnode, true);\n  }\n};\n\nfunction registerRef (vnode, isRemoval) {\n  var key = vnode.data.ref;\n  if (!key) { return }\n\n  var vm = vnode.context;\n  var ref = vnode.child || vnode.elm;\n  var refs = vm.$refs;\n  if (isRemoval) {\n    if (Array.isArray(refs[key])) {\n      remove$1(refs[key], ref);\n    } else if (refs[key] === ref) {\n      refs[key] = undefined;\n    }\n  } else {\n    if (vnode.data.refInFor) {\n      if (Array.isArray(refs[key]) && refs[key].indexOf(ref) < 0) {\n        refs[key].push(ref);\n      } else {\n        refs[key] = [ref];\n      }\n    } else {\n      refs[key] = ref;\n    }\n  }\n}\n\n/**\n * Virtual DOM patching algorithm based on Snabbdom by\n * Simon Friis Vindum (@paldepind)\n * Licensed under the MIT License\n * https://github.com/paldepind/snabbdom/blob/master/LICENSE\n *\n * modified by Evan You (@yyx990803)\n *\n\n/*\n * Not type-checking this because this file is perf-critical and the cost\n * of making flow understand it is not worth it.\n */\n\nvar emptyNode = new VNode('', {}, []);\n\nvar hooks$1 = ['create', 'update', 'remove', 'destroy'];\n\nfunction isUndef (s) {\n  return s == null\n}\n\nfunction isDef (s) {\n  return s != null\n}\n\nfunction sameVnode (vnode1, vnode2) {\n  return (\n    vnode1.key === vnode2.key &&\n    vnode1.tag === vnode2.tag &&\n    vnode1.isComment === vnode2.isComment &&\n    !vnode1.data === !vnode2.data\n  )\n}\n\nfunction createKeyToOldIdx (children, beginIdx, endIdx) {\n  var i, key;\n  var map = {};\n  for (i = beginIdx; i <= endIdx; ++i) {\n    key = children[i].key;\n    if (isDef(key)) { map[key] = i; }\n  }\n  return map\n}\n\nfunction createPatchFunction (backend) {\n  var i, j;\n  var cbs = {};\n\n  var modules = backend.modules;\n  var nodeOps = backend.nodeOps;\n\n  for (i = 0; i < hooks$1.length; ++i) {\n    cbs[hooks$1[i]] = [];\n    for (j = 0; j < modules.length; ++j) {\n      if (modules[j][hooks$1[i]] !== undefined) { cbs[hooks$1[i]].push(modules[j][hooks$1[i]]); }\n    }\n  }\n\n  function emptyNodeAt (elm) {\n    return new VNode(nodeOps.tagName(elm).toLowerCase(), {}, [], undefined, elm)\n  }\n\n  function createRmCb (childElm, listeners) {\n    function remove$$1 () {\n      if (--remove$$1.listeners === 0) {\n        removeElement(childElm);\n      }\n    }\n    remove$$1.listeners = listeners;\n    return remove$$1\n  }\n\n  function removeElement (el) {\n    var parent = nodeOps.parentNode(el);\n    // element may have already been removed due to v-html\n    if (parent) {\n      nodeOps.removeChild(parent, el);\n    }\n  }\n\n  function createElm (vnode, insertedVnodeQueue, nested) {\n    var i;\n    var data = vnode.data;\n    vnode.isRootInsert = !nested;\n    if (isDef(data)) {\n      if (isDef(i = data.hook) && isDef(i = i.init)) { i(vnode); }\n      // after calling the init hook, if the vnode is a child component\n      // it should've created a child instance and mounted it. the child\n      // component also has set the placeholder vnode's elm.\n      // in that case we can just return the element and be done.\n      if (isDef(i = vnode.child)) {\n        initComponent(vnode, insertedVnodeQueue);\n        return vnode.elm\n      }\n    }\n    var children = vnode.children;\n    var tag = vnode.tag;\n    if (isDef(tag)) {\n      if (process.env.NODE_ENV !== 'production') {\n        if (\n          !vnode.ns &&\n          !(config.ignoredElements && config.ignoredElements.indexOf(tag) > -1) &&\n          config.isUnknownElement(tag)\n        ) {\n          warn(\n            'Unknown custom element: <' + tag + '> - did you ' +\n            'register the component correctly? For recursive components, ' +\n            'make sure to provide the \"name\" option.',\n            vnode.context\n          );\n        }\n      }\n      vnode.elm = vnode.ns\n        ? nodeOps.createElementNS(vnode.ns, tag)\n        : nodeOps.createElement(tag, vnode);\n      setScope(vnode);\n      createChildren(vnode, children, insertedVnodeQueue);\n      if (isDef(data)) {\n        invokeCreateHooks(vnode, insertedVnodeQueue);\n      }\n    } else if (vnode.isComment) {\n      vnode.elm = nodeOps.createComment(vnode.text);\n    } else {\n      vnode.elm = nodeOps.createTextNode(vnode.text);\n    }\n    return vnode.elm\n  }\n\n  function createChildren (vnode, children, insertedVnodeQueue) {\n    if (Array.isArray(children)) {\n      for (var i = 0; i < children.length; ++i) {\n        nodeOps.appendChild(vnode.elm, createElm(children[i], insertedVnodeQueue, true));\n      }\n    } else if (isPrimitive(vnode.text)) {\n      nodeOps.appendChild(vnode.elm, nodeOps.createTextNode(vnode.text));\n    }\n  }\n\n  function isPatchable (vnode) {\n    while (vnode.child) {\n      vnode = vnode.child._vnode;\n    }\n    return isDef(vnode.tag)\n  }\n\n  function invokeCreateHooks (vnode, insertedVnodeQueue) {\n    for (var i$1 = 0; i$1 < cbs.create.length; ++i$1) {\n      cbs.create[i$1](emptyNode, vnode);\n    }\n    i = vnode.data.hook; // Reuse variable\n    if (isDef(i)) {\n      if (i.create) { i.create(emptyNode, vnode); }\n      if (i.insert) { insertedVnodeQueue.push(vnode); }\n    }\n  }\n\n  function initComponent (vnode, insertedVnodeQueue) {\n    if (vnode.data.pendingInsert) {\n      insertedVnodeQueue.push.apply(insertedVnodeQueue, vnode.data.pendingInsert);\n    }\n    vnode.elm = vnode.child.$el;\n    if (isPatchable(vnode)) {\n      invokeCreateHooks(vnode, insertedVnodeQueue);\n      setScope(vnode);\n    } else {\n      // empty component root.\n      // skip all element-related modules except for ref (#3455)\n      registerRef(vnode);\n      // make sure to invoke the insert hook\n      insertedVnodeQueue.push(vnode);\n    }\n  }\n\n  // set scope id attribute for scoped CSS.\n  // this is implemented as a special case to avoid the overhead\n  // of going through the normal attribute patching process.\n  function setScope (vnode) {\n    var i;\n    if (isDef(i = vnode.context) && isDef(i = i.$options._scopeId)) {\n      nodeOps.setAttribute(vnode.elm, i, '');\n    }\n    if (isDef(i = activeInstance) &&\n        i !== vnode.context &&\n        isDef(i = i.$options._scopeId)) {\n      nodeOps.setAttribute(vnode.elm, i, '');\n    }\n  }\n\n  function addVnodes (parentElm, before, vnodes, startIdx, endIdx, insertedVnodeQueue) {\n    for (; startIdx <= endIdx; ++startIdx) {\n      nodeOps.insertBefore(parentElm, createElm(vnodes[startIdx], insertedVnodeQueue), before);\n    }\n  }\n\n  function invokeDestroyHook (vnode) {\n    var i, j;\n    var data = vnode.data;\n    if (isDef(data)) {\n      if (isDef(i = data.hook) && isDef(i = i.destroy)) { i(vnode); }\n      for (i = 0; i < cbs.destroy.length; ++i) { cbs.destroy[i](vnode); }\n    }\n    if (isDef(i = vnode.children)) {\n      for (j = 0; j < vnode.children.length; ++j) {\n        invokeDestroyHook(vnode.children[j]);\n      }\n    }\n  }\n\n  function removeVnodes (parentElm, vnodes, startIdx, endIdx) {\n    for (; startIdx <= endIdx; ++startIdx) {\n      var ch = vnodes[startIdx];\n      if (isDef(ch)) {\n        if (isDef(ch.tag)) {\n          removeAndInvokeRemoveHook(ch);\n          invokeDestroyHook(ch);\n        } else { // Text node\n          nodeOps.removeChild(parentElm, ch.elm);\n        }\n      }\n    }\n  }\n\n  function removeAndInvokeRemoveHook (vnode, rm) {\n    if (rm || isDef(vnode.data)) {\n      var listeners = cbs.remove.length + 1;\n      if (!rm) {\n        // directly removing\n        rm = createRmCb(vnode.elm, listeners);\n      } else {\n        // we have a recursively passed down rm callback\n        // increase the listeners count\n        rm.listeners += listeners;\n      }\n      // recursively invoke hooks on child component root node\n      if (isDef(i = vnode.child) && isDef(i = i._vnode) && isDef(i.data)) {\n        removeAndInvokeRemoveHook(i, rm);\n      }\n      for (i = 0; i < cbs.remove.length; ++i) {\n        cbs.remove[i](vnode, rm);\n      }\n      if (isDef(i = vnode.data.hook) && isDef(i = i.remove)) {\n        i(vnode, rm);\n      } else {\n        rm();\n      }\n    } else {\n      removeElement(vnode.elm);\n    }\n  }\n\n  function updateChildren (parentElm, oldCh, newCh, insertedVnodeQueue, removeOnly) {\n    var oldStartIdx = 0;\n    var newStartIdx = 0;\n    var oldEndIdx = oldCh.length - 1;\n    var oldStartVnode = oldCh[0];\n    var oldEndVnode = oldCh[oldEndIdx];\n    var newEndIdx = newCh.length - 1;\n    var newStartVnode = newCh[0];\n    var newEndVnode = newCh[newEndIdx];\n    var oldKeyToIdx, idxInOld, elmToMove, before;\n\n    // removeOnly is a special flag used only by <transition-group>\n    // to ensure removed elements stay in correct relative positions\n    // during leaving transitions\n    var canMove = !removeOnly;\n\n    while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {\n      if (isUndef(oldStartVnode)) {\n        oldStartVnode = oldCh[++oldStartIdx]; // Vnode has been moved left\n      } else if (isUndef(oldEndVnode)) {\n        oldEndVnode = oldCh[--oldEndIdx];\n      } else if (sameVnode(oldStartVnode, newStartVnode)) {\n        patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue);\n        oldStartVnode = oldCh[++oldStartIdx];\n        newStartVnode = newCh[++newStartIdx];\n      } else if (sameVnode(oldEndVnode, newEndVnode)) {\n        patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue);\n        oldEndVnode = oldCh[--oldEndIdx];\n        newEndVnode = newCh[--newEndIdx];\n      } else if (sameVnode(oldStartVnode, newEndVnode)) { // Vnode moved right\n        patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue);\n        canMove && nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm));\n        oldStartVnode = oldCh[++oldStartIdx];\n        newEndVnode = newCh[--newEndIdx];\n      } else if (sameVnode(oldEndVnode, newStartVnode)) { // Vnode moved left\n        patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue);\n        canMove && nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm);\n        oldEndVnode = oldCh[--oldEndIdx];\n        newStartVnode = newCh[++newStartIdx];\n      } else {\n        if (isUndef(oldKeyToIdx)) { oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx); }\n        idxInOld = isDef(newStartVnode.key) ? oldKeyToIdx[newStartVnode.key] : null;\n        if (isUndef(idxInOld)) { // New element\n          nodeOps.insertBefore(parentElm, createElm(newStartVnode, insertedVnodeQueue), oldStartVnode.elm);\n          newStartVnode = newCh[++newStartIdx];\n        } else {\n          elmToMove = oldCh[idxInOld];\n          /* istanbul ignore if */\n          if (process.env.NODE_ENV !== 'production' && !elmToMove) {\n            warn(\n              'It seems there are duplicate keys that is causing an update error. ' +\n              'Make sure each v-for item has a unique key.'\n            );\n          }\n          if (elmToMove.tag !== newStartVnode.tag) {\n            // same key but different element. treat as new element\n            nodeOps.insertBefore(parentElm, createElm(newStartVnode, insertedVnodeQueue), oldStartVnode.elm);\n            newStartVnode = newCh[++newStartIdx];\n          } else {\n            patchVnode(elmToMove, newStartVnode, insertedVnodeQueue);\n            oldCh[idxInOld] = undefined;\n            canMove && nodeOps.insertBefore(parentElm, newStartVnode.elm, oldStartVnode.elm);\n            newStartVnode = newCh[++newStartIdx];\n          }\n        }\n      }\n    }\n    if (oldStartIdx > oldEndIdx) {\n      before = isUndef(newCh[newEndIdx + 1]) ? null : newCh[newEndIdx + 1].elm;\n      addVnodes(parentElm, before, newCh, newStartIdx, newEndIdx, insertedVnodeQueue);\n    } else if (newStartIdx > newEndIdx) {\n      removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx);\n    }\n  }\n\n  function patchVnode (oldVnode, vnode, insertedVnodeQueue, removeOnly) {\n    if (oldVnode === vnode) {\n      return\n    }\n    // reuse element for static trees.\n    // note we only do this if the vnode is cloned -\n    // if the new node is not cloned it means the render functions have been\n    // reset by the hot-reload-api and we need to do a proper re-render.\n    if (vnode.isStatic &&\n        oldVnode.isStatic &&\n        vnode.key === oldVnode.key &&\n        (vnode.isCloned || vnode.isOnce)) {\n      vnode.elm = oldVnode.elm;\n      return\n    }\n    var i;\n    var data = vnode.data;\n    var hasData = isDef(data);\n    if (hasData && isDef(i = data.hook) && isDef(i = i.prepatch)) {\n      i(oldVnode, vnode);\n    }\n    var elm = vnode.elm = oldVnode.elm;\n    var oldCh = oldVnode.children;\n    var ch = vnode.children;\n    if (hasData && isPatchable(vnode)) {\n      for (i = 0; i < cbs.update.length; ++i) { cbs.update[i](oldVnode, vnode); }\n      if (isDef(i = data.hook) && isDef(i = i.update)) { i(oldVnode, vnode); }\n    }\n    if (isUndef(vnode.text)) {\n      if (isDef(oldCh) && isDef(ch)) {\n        if (oldCh !== ch) { updateChildren(elm, oldCh, ch, insertedVnodeQueue, removeOnly); }\n      } else if (isDef(ch)) {\n        if (isDef(oldVnode.text)) { nodeOps.setTextContent(elm, ''); }\n        addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue);\n      } else if (isDef(oldCh)) {\n        removeVnodes(elm, oldCh, 0, oldCh.length - 1);\n      } else if (isDef(oldVnode.text)) {\n        nodeOps.setTextContent(elm, '');\n      }\n    } else if (oldVnode.text !== vnode.text) {\n      nodeOps.setTextContent(elm, vnode.text);\n    }\n    if (hasData) {\n      if (isDef(i = data.hook) && isDef(i = i.postpatch)) { i(oldVnode, vnode); }\n    }\n  }\n\n  function invokeInsertHook (vnode, queue, initial) {\n    // delay insert hooks for component root nodes, invoke them after the\n    // element is really inserted\n    if (initial && vnode.parent) {\n      vnode.parent.data.pendingInsert = queue;\n    } else {\n      for (var i = 0; i < queue.length; ++i) {\n        queue[i].data.hook.insert(queue[i]);\n      }\n    }\n  }\n\n  var bailed = false;\n  function hydrate (elm, vnode, insertedVnodeQueue) {\n    if (process.env.NODE_ENV !== 'production') {\n      if (!assertNodeMatch(elm, vnode)) {\n        return false\n      }\n    }\n    vnode.elm = elm;\n    var tag = vnode.tag;\n    var data = vnode.data;\n    var children = vnode.children;\n    if (isDef(data)) {\n      if (isDef(i = data.hook) && isDef(i = i.init)) { i(vnode, true /* hydrating */); }\n      if (isDef(i = vnode.child)) {\n        // child component. it should have hydrated its own tree.\n        initComponent(vnode, insertedVnodeQueue);\n        return true\n      }\n    }\n    if (isDef(tag)) {\n      if (isDef(children)) {\n        var childNodes = nodeOps.childNodes(elm);\n        // empty element, allow client to pick up and populate children\n        if (!childNodes.length) {\n          createChildren(vnode, children, insertedVnodeQueue);\n        } else {\n          var childrenMatch = true;\n          if (childNodes.length !== children.length) {\n            childrenMatch = false;\n          } else {\n            for (var i$1 = 0; i$1 < children.length; i$1++) {\n              if (!hydrate(childNodes[i$1], children[i$1], insertedVnodeQueue)) {\n                childrenMatch = false;\n                break\n              }\n            }\n          }\n          if (!childrenMatch) {\n            if (process.env.NODE_ENV !== 'production' &&\n                typeof console !== 'undefined' &&\n                !bailed) {\n              bailed = true;\n              console.warn('Parent: ', elm);\n              console.warn('Mismatching childNodes vs. VNodes: ', childNodes, children);\n            }\n            return false\n          }\n        }\n      }\n      if (isDef(data)) {\n        invokeCreateHooks(vnode, insertedVnodeQueue);\n      }\n    }\n    return true\n  }\n\n  function assertNodeMatch (node, vnode) {\n    if (vnode.tag) {\n      return (\n        vnode.tag.indexOf('vue-component') === 0 ||\n        vnode.tag.toLowerCase() === nodeOps.tagName(node).toLowerCase()\n      )\n    } else {\n      return _toString(vnode.text) === node.data\n    }\n  }\n\n  return function patch (oldVnode, vnode, hydrating, removeOnly) {\n    if (!vnode) {\n      if (oldVnode) { invokeDestroyHook(oldVnode); }\n      return\n    }\n\n    var elm, parent;\n    var isInitialPatch = false;\n    var insertedVnodeQueue = [];\n\n    if (!oldVnode) {\n      // empty mount, create new root element\n      isInitialPatch = true;\n      createElm(vnode, insertedVnodeQueue);\n    } else {\n      var isRealElement = isDef(oldVnode.nodeType);\n      if (!isRealElement && sameVnode(oldVnode, vnode)) {\n        patchVnode(oldVnode, vnode, insertedVnodeQueue, removeOnly);\n      } else {\n        if (isRealElement) {\n          // mounting to a real element\n          // check if this is server-rendered content and if we can perform\n          // a successful hydration.\n          if (oldVnode.nodeType === 1 && oldVnode.hasAttribute('server-rendered')) {\n            oldVnode.removeAttribute('server-rendered');\n            hydrating = true;\n          }\n          if (hydrating) {\n            if (hydrate(oldVnode, vnode, insertedVnodeQueue)) {\n              invokeInsertHook(vnode, insertedVnodeQueue, true);\n              return oldVnode\n            } else if (process.env.NODE_ENV !== 'production') {\n              warn(\n                'The client-side rendered virtual DOM tree is not matching ' +\n                'server-rendered content. This is likely caused by incorrect ' +\n                'HTML markup, for example nesting block-level elements inside ' +\n                '<p>, or missing <tbody>. Bailing hydration and performing ' +\n                'full client-side render.'\n              );\n            }\n          }\n          // either not server-rendered, or hydration failed.\n          // create an empty node and replace it\n          oldVnode = emptyNodeAt(oldVnode);\n        }\n        elm = oldVnode.elm;\n        parent = nodeOps.parentNode(elm);\n\n        createElm(vnode, insertedVnodeQueue);\n\n        // component root element replaced.\n        // update parent placeholder node element.\n        if (vnode.parent) {\n          vnode.parent.elm = vnode.elm;\n          if (isPatchable(vnode)) {\n            for (var i = 0; i < cbs.create.length; ++i) {\n              cbs.create[i](emptyNode, vnode.parent);\n            }\n          }\n        }\n\n        if (parent !== null) {\n          nodeOps.insertBefore(parent, vnode.elm, nodeOps.nextSibling(elm));\n          removeVnodes(parent, [oldVnode], 0, 0);\n        } else if (isDef(oldVnode.tag)) {\n          invokeDestroyHook(oldVnode);\n        }\n      }\n    }\n\n    invokeInsertHook(vnode, insertedVnodeQueue, isInitialPatch);\n    return vnode.elm\n  }\n}\n\n/*  */\n\nvar directives = {\n  create: updateDirectives,\n  update: updateDirectives,\n  destroy: function unbindDirectives (vnode) {\n    updateDirectives(vnode, emptyNode);\n  }\n};\n\nfunction updateDirectives (\n  oldVnode,\n  vnode\n) {\n  if (!oldVnode.data.directives && !vnode.data.directives) {\n    return\n  }\n  var isCreate = oldVnode === emptyNode;\n  var oldDirs = normalizeDirectives$1(oldVnode.data.directives, oldVnode.context);\n  var newDirs = normalizeDirectives$1(vnode.data.directives, vnode.context);\n\n  var dirsWithInsert = [];\n  var dirsWithPostpatch = [];\n\n  var key, oldDir, dir;\n  for (key in newDirs) {\n    oldDir = oldDirs[key];\n    dir = newDirs[key];\n    if (!oldDir) {\n      // new directive, bind\n      callHook$1(dir, 'bind', vnode, oldVnode);\n      if (dir.def && dir.def.inserted) {\n        dirsWithInsert.push(dir);\n      }\n    } else {\n      // existing directive, update\n      dir.oldValue = oldDir.value;\n      callHook$1(dir, 'update', vnode, oldVnode);\n      if (dir.def && dir.def.componentUpdated) {\n        dirsWithPostpatch.push(dir);\n      }\n    }\n  }\n\n  if (dirsWithInsert.length) {\n    var callInsert = function () {\n      dirsWithInsert.forEach(function (dir) {\n        callHook$1(dir, 'inserted', vnode, oldVnode);\n      });\n    };\n    if (isCreate) {\n      mergeVNodeHook(vnode.data.hook || (vnode.data.hook = {}), 'insert', callInsert, 'dir-insert');\n    } else {\n      callInsert();\n    }\n  }\n\n  if (dirsWithPostpatch.length) {\n    mergeVNodeHook(vnode.data.hook || (vnode.data.hook = {}), 'postpatch', function () {\n      dirsWithPostpatch.forEach(function (dir) {\n        callHook$1(dir, 'componentUpdated', vnode, oldVnode);\n      });\n    }, 'dir-postpatch');\n  }\n\n  if (!isCreate) {\n    for (key in oldDirs) {\n      if (!newDirs[key]) {\n        // no longer present, unbind\n        callHook$1(oldDirs[key], 'unbind', oldVnode);\n      }\n    }\n  }\n}\n\nvar emptyModifiers = Object.create(null);\n\nfunction normalizeDirectives$1 (\n  dirs,\n  vm\n) {\n  var res = Object.create(null);\n  if (!dirs) {\n    return res\n  }\n  var i, dir;\n  for (i = 0; i < dirs.length; i++) {\n    dir = dirs[i];\n    if (!dir.modifiers) {\n      dir.modifiers = emptyModifiers;\n    }\n    res[getRawDirName(dir)] = dir;\n    dir.def = resolveAsset(vm.$options, 'directives', dir.name, true);\n  }\n  return res\n}\n\nfunction getRawDirName (dir) {\n  return dir.rawName || ((dir.name) + \".\" + (Object.keys(dir.modifiers || {}).join('.')))\n}\n\nfunction callHook$1 (dir, hook, vnode, oldVnode) {\n  var fn = dir.def && dir.def[hook];\n  if (fn) {\n    fn(vnode.elm, dir, vnode, oldVnode);\n  }\n}\n\nvar baseModules = [\n  ref,\n  directives\n];\n\n/*  */\n\nfunction updateAttrs (oldVnode, vnode) {\n  if (!oldVnode.data.attrs && !vnode.data.attrs) {\n    return\n  }\n  var key, cur, old;\n  var elm = vnode.elm;\n  var oldAttrs = oldVnode.data.attrs || {};\n  var attrs = vnode.data.attrs || {};\n  // clone observed objects, as the user probably wants to mutate it\n  if (attrs.__ob__) {\n    attrs = vnode.data.attrs = extend({}, attrs);\n  }\n\n  for (key in attrs) {\n    cur = attrs[key];\n    old = oldAttrs[key];\n    if (old !== cur) {\n      setAttr(elm, key, cur);\n    }\n  }\n  for (key in oldAttrs) {\n    if (attrs[key] == null) {\n      if (isXlink(key)) {\n        elm.removeAttributeNS(xlinkNS, getXlinkProp(key));\n      } else if (!isEnumeratedAttr(key)) {\n        elm.removeAttribute(key);\n      }\n    }\n  }\n}\n\nfunction setAttr (el, key, value) {\n  if (isBooleanAttr(key)) {\n    // set attribute for blank value\n    // e.g. <option disabled>Select one</option>\n    if (isFalsyAttrValue(value)) {\n      el.removeAttribute(key);\n    } else {\n      el.setAttribute(key, key);\n    }\n  } else if (isEnumeratedAttr(key)) {\n    el.setAttribute(key, isFalsyAttrValue(value) || value === 'false' ? 'false' : 'true');\n  } else if (isXlink(key)) {\n    if (isFalsyAttrValue(value)) {\n      el.removeAttributeNS(xlinkNS, getXlinkProp(key));\n    } else {\n      el.setAttributeNS(xlinkNS, key, value);\n    }\n  } else {\n    if (isFalsyAttrValue(value)) {\n      el.removeAttribute(key);\n    } else {\n      el.setAttribute(key, value);\n    }\n  }\n}\n\nvar attrs = {\n  create: updateAttrs,\n  update: updateAttrs\n};\n\n/*  */\n\nfunction updateClass (oldVnode, vnode) {\n  var el = vnode.elm;\n  var data = vnode.data;\n  var oldData = oldVnode.data;\n  if (!data.staticClass && !data.class &&\n      (!oldData || (!oldData.staticClass && !oldData.class))) {\n    return\n  }\n\n  var cls = genClassForVnode(vnode);\n\n  // handle transition classes\n  var transitionClass = el._transitionClasses;\n  if (transitionClass) {\n    cls = concat(cls, stringifyClass(transitionClass));\n  }\n\n  // set the class\n  if (cls !== el._prevClass) {\n    el.setAttribute('class', cls);\n    el._prevClass = cls;\n  }\n}\n\nvar klass = {\n  create: updateClass,\n  update: updateClass\n};\n\n// skip type checking this file because we need to attach private properties\n// to elements\n\nfunction updateDOMListeners (oldVnode, vnode) {\n  if (!oldVnode.data.on && !vnode.data.on) {\n    return\n  }\n  var on = vnode.data.on || {};\n  var oldOn = oldVnode.data.on || {};\n  var add = vnode.elm._v_add || (vnode.elm._v_add = function (event, handler, capture) {\n    vnode.elm.addEventListener(event, handler, capture);\n  });\n  var remove = vnode.elm._v_remove || (vnode.elm._v_remove = function (event, handler) {\n    vnode.elm.removeEventListener(event, handler);\n  });\n  updateListeners(on, oldOn, add, remove, vnode.context);\n}\n\nvar events = {\n  create: updateDOMListeners,\n  update: updateDOMListeners\n};\n\n/*  */\n\nfunction updateDOMProps (oldVnode, vnode) {\n  if (!oldVnode.data.domProps && !vnode.data.domProps) {\n    return\n  }\n  var key, cur;\n  var elm = vnode.elm;\n  var oldProps = oldVnode.data.domProps || {};\n  var props = vnode.data.domProps || {};\n  // clone observed objects, as the user probably wants to mutate it\n  if (props.__ob__) {\n    props = vnode.data.domProps = extend({}, props);\n  }\n\n  for (key in oldProps) {\n    if (props[key] == null) {\n      elm[key] = '';\n    }\n  }\n  for (key in props) {\n    cur = props[key];\n    // ignore children if the node has textContent or innerHTML,\n    // as these will throw away existing DOM nodes and cause removal errors\n    // on subsequent patches (#3360)\n    if (key === 'textContent' || key === 'innerHTML') {\n      if (vnode.children) { vnode.children.length = 0; }\n      if (cur === oldProps[key]) { continue }\n    }\n    if (key === 'value') {\n      // store value as _value as well since\n      // non-string values will be stringified\n      elm._value = cur;\n      // avoid resetting cursor position when value is the same\n      var strCur = cur == null ? '' : String(cur);\n      if (elm.value !== strCur && !elm.composing) {\n        elm.value = strCur;\n      }\n    } else {\n      elm[key] = cur;\n    }\n  }\n}\n\nvar domProps = {\n  create: updateDOMProps,\n  update: updateDOMProps\n};\n\n/*  */\n\nvar parseStyleText = cached(function (cssText) {\n  var res = {};\n  var hasBackground = cssText.indexOf('background') >= 0;\n  // maybe with background-image: url(http://xxx) or base64 img\n  var listDelimiter = hasBackground ? /;(?![^(]*\\))/g : ';';\n  var propertyDelimiter = hasBackground ? /:(.+)/ : ':';\n  cssText.split(listDelimiter).forEach(function (item) {\n    if (item) {\n      var tmp = item.split(propertyDelimiter);\n      tmp.length > 1 && (res[tmp[0].trim()] = tmp[1].trim());\n    }\n  });\n  return res\n});\n\n// merge static and dynamic style data on the same vnode\nfunction normalizeStyleData (data) {\n  var style = normalizeStyleBinding(data.style);\n  // static style is pre-processed into an object during compilation\n  // and is always a fresh object, so it's safe to merge into it\n  return data.staticStyle\n    ? extend(data.staticStyle, style)\n    : style\n}\n\n// normalize possible array / string values into Object\nfunction normalizeStyleBinding (bindingStyle) {\n  if (Array.isArray(bindingStyle)) {\n    return toObject(bindingStyle)\n  }\n  if (typeof bindingStyle === 'string') {\n    return parseStyleText(bindingStyle)\n  }\n  return bindingStyle\n}\n\n/**\n * parent component style should be after child's\n * so that parent component's style could override it\n */\nfunction getStyle (vnode, checkChild) {\n  var res = {};\n  var styleData;\n\n  if (checkChild) {\n    var childNode = vnode;\n    while (childNode.child) {\n      childNode = childNode.child._vnode;\n      if (childNode.data && (styleData = normalizeStyleData(childNode.data))) {\n        extend(res, styleData);\n      }\n    }\n  }\n\n  if ((styleData = normalizeStyleData(vnode.data))) {\n    extend(res, styleData);\n  }\n\n  var parentNode = vnode;\n  while ((parentNode = parentNode.parent)) {\n    if (parentNode.data && (styleData = normalizeStyleData(parentNode.data))) {\n      extend(res, styleData);\n    }\n  }\n  return res\n}\n\n/*  */\n\nvar cssVarRE = /^--/;\nvar setProp = function (el, name, val) {\n  /* istanbul ignore if */\n  if (cssVarRE.test(name)) {\n    el.style.setProperty(name, val);\n  } else {\n    el.style[normalize(name)] = val;\n  }\n};\n\nvar prefixes = ['Webkit', 'Moz', 'ms'];\n\nvar testEl;\nvar normalize = cached(function (prop) {\n  testEl = testEl || document.createElement('div');\n  prop = camelize(prop);\n  if (prop !== 'filter' && (prop in testEl.style)) {\n    return prop\n  }\n  var upper = prop.charAt(0).toUpperCase() + prop.slice(1);\n  for (var i = 0; i < prefixes.length; i++) {\n    var prefixed = prefixes[i] + upper;\n    if (prefixed in testEl.style) {\n      return prefixed\n    }\n  }\n});\n\nfunction updateStyle (oldVnode, vnode) {\n  var data = vnode.data;\n  var oldData = oldVnode.data;\n\n  if (!data.staticStyle && !data.style &&\n      !oldData.staticStyle && !oldData.style) {\n    return\n  }\n\n  var cur, name;\n  var el = vnode.elm;\n  var oldStaticStyle = oldVnode.data.staticStyle;\n  var oldStyleBinding = oldVnode.data.style || {};\n\n  // if static style exists, stylebinding already merged into it when doing normalizeStyleData\n  var oldStyle = oldStaticStyle || oldStyleBinding;\n\n  var style = normalizeStyleBinding(vnode.data.style) || {};\n\n  vnode.data.style = style.__ob__ ? extend({}, style) : style;\n\n  var newStyle = getStyle(vnode, true);\n\n  for (name in oldStyle) {\n    if (newStyle[name] == null) {\n      setProp(el, name, '');\n    }\n  }\n  for (name in newStyle) {\n    cur = newStyle[name];\n    if (cur !== oldStyle[name]) {\n      // ie9 setting to null has no effect, must use empty string\n      setProp(el, name, cur == null ? '' : cur);\n    }\n  }\n}\n\nvar style = {\n  create: updateStyle,\n  update: updateStyle\n};\n\n/*  */\n\n/**\n * Add class with compatibility for SVG since classList is not supported on\n * SVG elements in IE\n */\nfunction addClass (el, cls) {\n  /* istanbul ignore if */\n  if (!cls || !cls.trim()) {\n    return\n  }\n\n  /* istanbul ignore else */\n  if (el.classList) {\n    if (cls.indexOf(' ') > -1) {\n      cls.split(/\\s+/).forEach(function (c) { return el.classList.add(c); });\n    } else {\n      el.classList.add(cls);\n    }\n  } else {\n    var cur = ' ' + el.getAttribute('class') + ' ';\n    if (cur.indexOf(' ' + cls + ' ') < 0) {\n      el.setAttribute('class', (cur + cls).trim());\n    }\n  }\n}\n\n/**\n * Remove class with compatibility for SVG since classList is not supported on\n * SVG elements in IE\n */\nfunction removeClass (el, cls) {\n  /* istanbul ignore if */\n  if (!cls || !cls.trim()) {\n    return\n  }\n\n  /* istanbul ignore else */\n  if (el.classList) {\n    if (cls.indexOf(' ') > -1) {\n      cls.split(/\\s+/).forEach(function (c) { return el.classList.remove(c); });\n    } else {\n      el.classList.remove(cls);\n    }\n  } else {\n    var cur = ' ' + el.getAttribute('class') + ' ';\n    var tar = ' ' + cls + ' ';\n    while (cur.indexOf(tar) >= 0) {\n      cur = cur.replace(tar, ' ');\n    }\n    el.setAttribute('class', cur.trim());\n  }\n}\n\n/*  */\n\nvar hasTransition = inBrowser && !isIE9;\nvar TRANSITION = 'transition';\nvar ANIMATION = 'animation';\n\n// Transition property/event sniffing\nvar transitionProp = 'transition';\nvar transitionEndEvent = 'transitionend';\nvar animationProp = 'animation';\nvar animationEndEvent = 'animationend';\nif (hasTransition) {\n  /* istanbul ignore if */\n  if (window.ontransitionend === undefined &&\n    window.onwebkittransitionend !== undefined) {\n    transitionProp = 'WebkitTransition';\n    transitionEndEvent = 'webkitTransitionEnd';\n  }\n  if (window.onanimationend === undefined &&\n    window.onwebkitanimationend !== undefined) {\n    animationProp = 'WebkitAnimation';\n    animationEndEvent = 'webkitAnimationEnd';\n  }\n}\n\nvar raf = (inBrowser && window.requestAnimationFrame) || setTimeout;\nfunction nextFrame (fn) {\n  raf(function () {\n    raf(fn);\n  });\n}\n\nfunction addTransitionClass (el, cls) {\n  (el._transitionClasses || (el._transitionClasses = [])).push(cls);\n  addClass(el, cls);\n}\n\nfunction removeTransitionClass (el, cls) {\n  if (el._transitionClasses) {\n    remove$1(el._transitionClasses, cls);\n  }\n  removeClass(el, cls);\n}\n\nfunction whenTransitionEnds (\n  el,\n  expectedType,\n  cb\n) {\n  var ref = getTransitionInfo(el, expectedType);\n  var type = ref.type;\n  var timeout = ref.timeout;\n  var propCount = ref.propCount;\n  if (!type) { return cb() }\n  var event = type === TRANSITION ? transitionEndEvent : animationEndEvent;\n  var ended = 0;\n  var end = function () {\n    el.removeEventListener(event, onEnd);\n    cb();\n  };\n  var onEnd = function (e) {\n    if (e.target === el) {\n      if (++ended >= propCount) {\n        end();\n      }\n    }\n  };\n  setTimeout(function () {\n    if (ended < propCount) {\n      end();\n    }\n  }, timeout + 1);\n  el.addEventListener(event, onEnd);\n}\n\nvar transformRE = /\\b(transform|all)(,|$)/;\n\nfunction getTransitionInfo (el, expectedType) {\n  var styles = window.getComputedStyle(el);\n  var transitioneDelays = styles[transitionProp + 'Delay'].split(', ');\n  var transitionDurations = styles[transitionProp + 'Duration'].split(', ');\n  var transitionTimeout = getTimeout(transitioneDelays, transitionDurations);\n  var animationDelays = styles[animationProp + 'Delay'].split(', ');\n  var animationDurations = styles[animationProp + 'Duration'].split(', ');\n  var animationTimeout = getTimeout(animationDelays, animationDurations);\n\n  var type;\n  var timeout = 0;\n  var propCount = 0;\n  /* istanbul ignore if */\n  if (expectedType === TRANSITION) {\n    if (transitionTimeout > 0) {\n      type = TRANSITION;\n      timeout = transitionTimeout;\n      propCount = transitionDurations.length;\n    }\n  } else if (expectedType === ANIMATION) {\n    if (animationTimeout > 0) {\n      type = ANIMATION;\n      timeout = animationTimeout;\n      propCount = animationDurations.length;\n    }\n  } else {\n    timeout = Math.max(transitionTimeout, animationTimeout);\n    type = timeout > 0\n      ? transitionTimeout > animationTimeout\n        ? TRANSITION\n        : ANIMATION\n      : null;\n    propCount = type\n      ? type === TRANSITION\n        ? transitionDurations.length\n        : animationDurations.length\n      : 0;\n  }\n  var hasTransform =\n    type === TRANSITION &&\n    transformRE.test(styles[transitionProp + 'Property']);\n  return {\n    type: type,\n    timeout: timeout,\n    propCount: propCount,\n    hasTransform: hasTransform\n  }\n}\n\nfunction getTimeout (delays, durations) {\n  /* istanbul ignore next */\n  while (delays.length < durations.length) {\n    delays = delays.concat(delays);\n  }\n\n  return Math.max.apply(null, durations.map(function (d, i) {\n    return toMs(d) + toMs(delays[i])\n  }))\n}\n\nfunction toMs (s) {\n  return Number(s.slice(0, -1)) * 1000\n}\n\n/*  */\n\nfunction enter (vnode) {\n  var el = vnode.elm;\n\n  // call leave callback now\n  if (el._leaveCb) {\n    el._leaveCb.cancelled = true;\n    el._leaveCb();\n  }\n\n  var data = resolveTransition(vnode.data.transition);\n  if (!data) {\n    return\n  }\n\n  /* istanbul ignore if */\n  if (el._enterCb || el.nodeType !== 1) {\n    return\n  }\n\n  var css = data.css;\n  var type = data.type;\n  var enterClass = data.enterClass;\n  var enterActiveClass = data.enterActiveClass;\n  var appearClass = data.appearClass;\n  var appearActiveClass = data.appearActiveClass;\n  var beforeEnter = data.beforeEnter;\n  var enter = data.enter;\n  var afterEnter = data.afterEnter;\n  var enterCancelled = data.enterCancelled;\n  var beforeAppear = data.beforeAppear;\n  var appear = data.appear;\n  var afterAppear = data.afterAppear;\n  var appearCancelled = data.appearCancelled;\n\n  // activeInstance will always be the <transition> component managing this\n  // transition. One edge case to check is when the <transition> is placed\n  // as the root node of a child component. In that case we need to check\n  // <transition>'s parent for appear check.\n  var transitionNode = activeInstance.$vnode;\n  var context = transitionNode && transitionNode.parent\n    ? transitionNode.parent.context\n    : activeInstance;\n\n  var isAppear = !context._isMounted || !vnode.isRootInsert;\n\n  if (isAppear && !appear && appear !== '') {\n    return\n  }\n\n  var startClass = isAppear ? appearClass : enterClass;\n  var activeClass = isAppear ? appearActiveClass : enterActiveClass;\n  var beforeEnterHook = isAppear ? (beforeAppear || beforeEnter) : beforeEnter;\n  var enterHook = isAppear ? (typeof appear === 'function' ? appear : enter) : enter;\n  var afterEnterHook = isAppear ? (afterAppear || afterEnter) : afterEnter;\n  var enterCancelledHook = isAppear ? (appearCancelled || enterCancelled) : enterCancelled;\n\n  var expectsCSS = css !== false && !isIE9;\n  var userWantsControl =\n    enterHook &&\n    // enterHook may be a bound method which exposes\n    // the length of original fn as _length\n    (enterHook._length || enterHook.length) > 1;\n\n  var cb = el._enterCb = once(function () {\n    if (expectsCSS) {\n      removeTransitionClass(el, activeClass);\n    }\n    if (cb.cancelled) {\n      if (expectsCSS) {\n        removeTransitionClass(el, startClass);\n      }\n      enterCancelledHook && enterCancelledHook(el);\n    } else {\n      afterEnterHook && afterEnterHook(el);\n    }\n    el._enterCb = null;\n  });\n\n  if (!vnode.data.show) {\n    // remove pending leave element on enter by injecting an insert hook\n    mergeVNodeHook(vnode.data.hook || (vnode.data.hook = {}), 'insert', function () {\n      var parent = el.parentNode;\n      var pendingNode = parent && parent._pending && parent._pending[vnode.key];\n      if (pendingNode && pendingNode.tag === vnode.tag && pendingNode.elm._leaveCb) {\n        pendingNode.elm._leaveCb();\n      }\n      enterHook && enterHook(el, cb);\n    }, 'transition-insert');\n  }\n\n  // start enter transition\n  beforeEnterHook && beforeEnterHook(el);\n  if (expectsCSS) {\n    addTransitionClass(el, startClass);\n    addTransitionClass(el, activeClass);\n    nextFrame(function () {\n      removeTransitionClass(el, startClass);\n      if (!cb.cancelled && !userWantsControl) {\n        whenTransitionEnds(el, type, cb);\n      }\n    });\n  }\n\n  if (vnode.data.show) {\n    enterHook && enterHook(el, cb);\n  }\n\n  if (!expectsCSS && !userWantsControl) {\n    cb();\n  }\n}\n\nfunction leave (vnode, rm) {\n  var el = vnode.elm;\n\n  // call enter callback now\n  if (el._enterCb) {\n    el._enterCb.cancelled = true;\n    el._enterCb();\n  }\n\n  var data = resolveTransition(vnode.data.transition);\n  if (!data) {\n    return rm()\n  }\n\n  /* istanbul ignore if */\n  if (el._leaveCb || el.nodeType !== 1) {\n    return\n  }\n\n  var css = data.css;\n  var type = data.type;\n  var leaveClass = data.leaveClass;\n  var leaveActiveClass = data.leaveActiveClass;\n  var beforeLeave = data.beforeLeave;\n  var leave = data.leave;\n  var afterLeave = data.afterLeave;\n  var leaveCancelled = data.leaveCancelled;\n  var delayLeave = data.delayLeave;\n\n  var expectsCSS = css !== false && !isIE9;\n  var userWantsControl =\n    leave &&\n    // leave hook may be a bound method which exposes\n    // the length of original fn as _length\n    (leave._length || leave.length) > 1;\n\n  var cb = el._leaveCb = once(function () {\n    if (el.parentNode && el.parentNode._pending) {\n      el.parentNode._pending[vnode.key] = null;\n    }\n    if (expectsCSS) {\n      removeTransitionClass(el, leaveActiveClass);\n    }\n    if (cb.cancelled) {\n      if (expectsCSS) {\n        removeTransitionClass(el, leaveClass);\n      }\n      leaveCancelled && leaveCancelled(el);\n    } else {\n      rm();\n      afterLeave && afterLeave(el);\n    }\n    el._leaveCb = null;\n  });\n\n  if (delayLeave) {\n    delayLeave(performLeave);\n  } else {\n    performLeave();\n  }\n\n  function performLeave () {\n    // the delayed leave may have already been cancelled\n    if (cb.cancelled) {\n      return\n    }\n    // record leaving element\n    if (!vnode.data.show) {\n      (el.parentNode._pending || (el.parentNode._pending = {}))[vnode.key] = vnode;\n    }\n    beforeLeave && beforeLeave(el);\n    if (expectsCSS) {\n      addTransitionClass(el, leaveClass);\n      addTransitionClass(el, leaveActiveClass);\n      nextFrame(function () {\n        removeTransitionClass(el, leaveClass);\n        if (!cb.cancelled && !userWantsControl) {\n          whenTransitionEnds(el, type, cb);\n        }\n      });\n    }\n    leave && leave(el, cb);\n    if (!expectsCSS && !userWantsControl) {\n      cb();\n    }\n  }\n}\n\nfunction resolveTransition (def$$1) {\n  if (!def$$1) {\n    return\n  }\n  /* istanbul ignore else */\n  if (typeof def$$1 === 'object') {\n    var res = {};\n    if (def$$1.css !== false) {\n      extend(res, autoCssTransition(def$$1.name || 'v'));\n    }\n    extend(res, def$$1);\n    return res\n  } else if (typeof def$$1 === 'string') {\n    return autoCssTransition(def$$1)\n  }\n}\n\nvar autoCssTransition = cached(function (name) {\n  return {\n    enterClass: (name + \"-enter\"),\n    leaveClass: (name + \"-leave\"),\n    appearClass: (name + \"-enter\"),\n    enterActiveClass: (name + \"-enter-active\"),\n    leaveActiveClass: (name + \"-leave-active\"),\n    appearActiveClass: (name + \"-enter-active\")\n  }\n});\n\nfunction once (fn) {\n  var called = false;\n  return function () {\n    if (!called) {\n      called = true;\n      fn();\n    }\n  }\n}\n\nvar transition = inBrowser ? {\n  create: function create (_, vnode) {\n    if (!vnode.data.show) {\n      enter(vnode);\n    }\n  },\n  remove: function remove (vnode, rm) {\n    /* istanbul ignore else */\n    if (!vnode.data.show) {\n      leave(vnode, rm);\n    } else {\n      rm();\n    }\n  }\n} : {};\n\nvar platformModules = [\n  attrs,\n  klass,\n  events,\n  domProps,\n  style,\n  transition\n];\n\n/*  */\n\n// the directive module should be applied last, after all\n// built-in modules have been applied.\nvar modules = platformModules.concat(baseModules);\n\nvar patch$1 = createPatchFunction({ nodeOps: nodeOps, modules: modules });\n\n/**\n * Not type checking this file because flow doesn't like attaching\n * properties to Elements.\n */\n\nvar modelableTagRE = /^input|select|textarea|vue-component-[0-9]+(-[0-9a-zA-Z_-]*)?$/;\n\n/* istanbul ignore if */\nif (isIE9) {\n  // http://www.matts411.com/post/internet-explorer-9-oninput/\n  document.addEventListener('selectionchange', function () {\n    var el = document.activeElement;\n    if (el && el.vmodel) {\n      trigger(el, 'input');\n    }\n  });\n}\n\nvar model = {\n  inserted: function inserted (el, binding, vnode) {\n    if (process.env.NODE_ENV !== 'production') {\n      if (!modelableTagRE.test(vnode.tag)) {\n        warn(\n          \"v-model is not supported on element type: <\" + (vnode.tag) + \">. \" +\n          'If you are working with contenteditable, it\\'s recommended to ' +\n          'wrap a library dedicated for that purpose inside a custom component.',\n          vnode.context\n        );\n      }\n    }\n    if (vnode.tag === 'select') {\n      var cb = function () {\n        setSelected(el, binding, vnode.context);\n      };\n      cb();\n      /* istanbul ignore if */\n      if (isIE || isEdge) {\n        setTimeout(cb, 0);\n      }\n    } else if (\n      (vnode.tag === 'textarea' || el.type === 'text') &&\n      !binding.modifiers.lazy\n    ) {\n      if (!isAndroid) {\n        el.addEventListener('compositionstart', onCompositionStart);\n        el.addEventListener('compositionend', onCompositionEnd);\n      }\n      /* istanbul ignore if */\n      if (isIE9) {\n        el.vmodel = true;\n      }\n    }\n  },\n  componentUpdated: function componentUpdated (el, binding, vnode) {\n    if (vnode.tag === 'select') {\n      setSelected(el, binding, vnode.context);\n      // in case the options rendered by v-for have changed,\n      // it's possible that the value is out-of-sync with the rendered options.\n      // detect such cases and filter out values that no longer has a matching\n      // option in the DOM.\n      var needReset = el.multiple\n        ? binding.value.some(function (v) { return hasNoMatchingOption(v, el.options); })\n        : binding.value !== binding.oldValue && hasNoMatchingOption(binding.value, el.options);\n      if (needReset) {\n        trigger(el, 'change');\n      }\n    }\n  }\n};\n\nfunction setSelected (el, binding, vm) {\n  var value = binding.value;\n  var isMultiple = el.multiple;\n  if (isMultiple && !Array.isArray(value)) {\n    process.env.NODE_ENV !== 'production' && warn(\n      \"<select multiple v-model=\\\"\" + (binding.expression) + \"\\\"> \" +\n      \"expects an Array value for its binding, but got \" + (Object.prototype.toString.call(value).slice(8, -1)),\n      vm\n    );\n    return\n  }\n  var selected, option;\n  for (var i = 0, l = el.options.length; i < l; i++) {\n    option = el.options[i];\n    if (isMultiple) {\n      selected = looseIndexOf(value, getValue(option)) > -1;\n      if (option.selected !== selected) {\n        option.selected = selected;\n      }\n    } else {\n      if (looseEqual(getValue(option), value)) {\n        if (el.selectedIndex !== i) {\n          el.selectedIndex = i;\n        }\n        return\n      }\n    }\n  }\n  if (!isMultiple) {\n    el.selectedIndex = -1;\n  }\n}\n\nfunction hasNoMatchingOption (value, options) {\n  for (var i = 0, l = options.length; i < l; i++) {\n    if (looseEqual(getValue(options[i]), value)) {\n      return false\n    }\n  }\n  return true\n}\n\nfunction getValue (option) {\n  return '_value' in option\n    ? option._value\n    : option.value\n}\n\nfunction onCompositionStart (e) {\n  e.target.composing = true;\n}\n\nfunction onCompositionEnd (e) {\n  e.target.composing = false;\n  trigger(e.target, 'input');\n}\n\nfunction trigger (el, type) {\n  var e = document.createEvent('HTMLEvents');\n  e.initEvent(type, true, true);\n  el.dispatchEvent(e);\n}\n\n/*  */\n\n// recursively search for possible transition defined inside the component root\nfunction locateNode (vnode) {\n  return vnode.child && (!vnode.data || !vnode.data.transition)\n    ? locateNode(vnode.child._vnode)\n    : vnode\n}\n\nvar show = {\n  bind: function bind (el, ref, vnode) {\n    var value = ref.value;\n\n    vnode = locateNode(vnode);\n    var transition = vnode.data && vnode.data.transition;\n    if (value && transition && !isIE9) {\n      enter(vnode);\n    }\n    var originalDisplay = el.style.display === 'none' ? '' : el.style.display;\n    el.style.display = value ? originalDisplay : 'none';\n    el.__vOriginalDisplay = originalDisplay;\n  },\n  update: function update (el, ref, vnode) {\n    var value = ref.value;\n    var oldValue = ref.oldValue;\n\n    /* istanbul ignore if */\n    if (value === oldValue) { return }\n    vnode = locateNode(vnode);\n    var transition = vnode.data && vnode.data.transition;\n    if (transition && !isIE9) {\n      if (value) {\n        enter(vnode);\n        el.style.display = el.__vOriginalDisplay;\n      } else {\n        leave(vnode, function () {\n          el.style.display = 'none';\n        });\n      }\n    } else {\n      el.style.display = value ? el.__vOriginalDisplay : 'none';\n    }\n  }\n};\n\nvar platformDirectives = {\n  model: model,\n  show: show\n};\n\n/*  */\n\n// Provides transition support for a single element/component.\n// supports transition mode (out-in / in-out)\n\nvar transitionProps = {\n  name: String,\n  appear: Boolean,\n  css: Boolean,\n  mode: String,\n  type: String,\n  enterClass: String,\n  leaveClass: String,\n  enterActiveClass: String,\n  leaveActiveClass: String,\n  appearClass: String,\n  appearActiveClass: String\n};\n\n// in case the child is also an abstract component, e.g. <keep-alive>\n// we want to recursively retrieve the real component to be rendered\nfunction getRealChild (vnode) {\n  var compOptions = vnode && vnode.componentOptions;\n  if (compOptions && compOptions.Ctor.options.abstract) {\n    return getRealChild(getFirstComponentChild(compOptions.children))\n  } else {\n    return vnode\n  }\n}\n\nfunction extractTransitionData (comp) {\n  var data = {};\n  var options = comp.$options;\n  // props\n  for (var key in options.propsData) {\n    data[key] = comp[key];\n  }\n  // events.\n  // extract listeners and pass them directly to the transition methods\n  var listeners = options._parentListeners;\n  for (var key$1 in listeners) {\n    data[camelize(key$1)] = listeners[key$1].fn;\n  }\n  return data\n}\n\nfunction placeholder (h, rawChild) {\n  return /\\d-keep-alive$/.test(rawChild.tag)\n    ? h('keep-alive')\n    : null\n}\n\nfunction hasParentTransition (vnode) {\n  while ((vnode = vnode.parent)) {\n    if (vnode.data.transition) {\n      return true\n    }\n  }\n}\n\nvar Transition = {\n  name: 'transition',\n  props: transitionProps,\n  abstract: true,\n  render: function render (h) {\n    var this$1 = this;\n\n    var children = this.$slots.default;\n    if (!children) {\n      return\n    }\n\n    // filter out text nodes (possible whitespaces)\n    children = children.filter(function (c) { return c.tag; });\n    /* istanbul ignore if */\n    if (!children.length) {\n      return\n    }\n\n    // warn multiple elements\n    if (process.env.NODE_ENV !== 'production' && children.length > 1) {\n      warn(\n        '<transition> can only be used on a single element. Use ' +\n        '<transition-group> for lists.',\n        this.$parent\n      );\n    }\n\n    var mode = this.mode;\n\n    // warn invalid mode\n    if (process.env.NODE_ENV !== 'production' &&\n        mode && mode !== 'in-out' && mode !== 'out-in') {\n      warn(\n        'invalid <transition> mode: ' + mode,\n        this.$parent\n      );\n    }\n\n    var rawChild = children[0];\n\n    // if this is a component root node and the component's\n    // parent container node also has transition, skip.\n    if (hasParentTransition(this.$vnode)) {\n      return rawChild\n    }\n\n    // apply transition data to child\n    // use getRealChild() to ignore abstract components e.g. keep-alive\n    var child = getRealChild(rawChild);\n    /* istanbul ignore if */\n    if (!child) {\n      return rawChild\n    }\n\n    if (this._leaving) {\n      return placeholder(h, rawChild)\n    }\n\n    var key = child.key = child.key == null || child.isStatic\n      ? (\"__v\" + (child.tag + this._uid) + \"__\")\n      : child.key;\n    var data = (child.data || (child.data = {})).transition = extractTransitionData(this);\n    var oldRawChild = this._vnode;\n    var oldChild = getRealChild(oldRawChild);\n\n    // mark v-show\n    // so that the transition module can hand over the control to the directive\n    if (child.data.directives && child.data.directives.some(function (d) { return d.name === 'show'; })) {\n      child.data.show = true;\n    }\n\n    if (oldChild && oldChild.data && oldChild.key !== key) {\n      // replace old child transition data with fresh one\n      // important for dynamic transitions!\n      var oldData = oldChild.data.transition = extend({}, data);\n\n      // handle transition mode\n      if (mode === 'out-in') {\n        // return placeholder node and queue update when leave finishes\n        this._leaving = true;\n        mergeVNodeHook(oldData, 'afterLeave', function () {\n          this$1._leaving = false;\n          this$1.$forceUpdate();\n        }, key);\n        return placeholder(h, rawChild)\n      } else if (mode === 'in-out') {\n        var delayedLeave;\n        var performLeave = function () { delayedLeave(); };\n        mergeVNodeHook(data, 'afterEnter', performLeave, key);\n        mergeVNodeHook(data, 'enterCancelled', performLeave, key);\n        mergeVNodeHook(oldData, 'delayLeave', function (leave) {\n          delayedLeave = leave;\n        }, key);\n      }\n    }\n\n    return rawChild\n  }\n};\n\n/*  */\n\n// Provides transition support for list items.\n// supports move transitions using the FLIP technique.\n\n// Because the vdom's children update algorithm is \"unstable\" - i.e.\n// it doesn't guarantee the relative positioning of removed elements,\n// we force transition-group to update its children into two passes:\n// in the first pass, we remove all nodes that need to be removed,\n// triggering their leaving transition; in the second pass, we insert/move\n// into the final disired state. This way in the second pass removed\n// nodes will remain where they should be.\n\nvar props = extend({\n  tag: String,\n  moveClass: String\n}, transitionProps);\n\ndelete props.mode;\n\nvar TransitionGroup = {\n  props: props,\n\n  render: function render (h) {\n    var tag = this.tag || this.$vnode.data.tag || 'span';\n    var map = Object.create(null);\n    var prevChildren = this.prevChildren = this.children;\n    var rawChildren = this.$slots.default || [];\n    var children = this.children = [];\n    var transitionData = extractTransitionData(this);\n\n    for (var i = 0; i < rawChildren.length; i++) {\n      var c = rawChildren[i];\n      if (c.tag) {\n        if (c.key != null && String(c.key).indexOf('__vlist') !== 0) {\n          children.push(c);\n          map[c.key] = c\n          ;(c.data || (c.data = {})).transition = transitionData;\n        } else if (process.env.NODE_ENV !== 'production') {\n          var opts = c.componentOptions;\n          var name = opts\n            ? (opts.Ctor.options.name || opts.tag)\n            : c.tag;\n          warn((\"<transition-group> children must be keyed: <\" + name + \">\"));\n        }\n      }\n    }\n\n    if (prevChildren) {\n      var kept = [];\n      var removed = [];\n      for (var i$1 = 0; i$1 < prevChildren.length; i$1++) {\n        var c$1 = prevChildren[i$1];\n        c$1.data.transition = transitionData;\n        c$1.data.pos = c$1.elm.getBoundingClientRect();\n        if (map[c$1.key]) {\n          kept.push(c$1);\n        } else {\n          removed.push(c$1);\n        }\n      }\n      this.kept = h(tag, null, kept);\n      this.removed = removed;\n    }\n\n    return h(tag, null, children)\n  },\n\n  beforeUpdate: function beforeUpdate () {\n    // force removing pass\n    this.__patch__(\n      this._vnode,\n      this.kept,\n      false, // hydrating\n      true // removeOnly (!important, avoids unnecessary moves)\n    );\n    this._vnode = this.kept;\n  },\n\n  updated: function updated () {\n    var children = this.prevChildren;\n    var moveClass = this.moveClass || ((this.name || 'v') + '-move');\n    if (!children.length || !this.hasMove(children[0].elm, moveClass)) {\n      return\n    }\n\n    // we divide the work into three loops to avoid mixing DOM reads and writes\n    // in each iteration - which helps prevent layout thrashing.\n    children.forEach(callPendingCbs);\n    children.forEach(recordPosition);\n    children.forEach(applyTranslation);\n\n    // force reflow to put everything in position\n    var f = document.body.offsetHeight; // eslint-disable-line\n\n    children.forEach(function (c) {\n      if (c.data.moved) {\n        var el = c.elm;\n        var s = el.style;\n        addTransitionClass(el, moveClass);\n        s.transform = s.WebkitTransform = s.transitionDuration = '';\n        el.addEventListener(transitionEndEvent, el._moveCb = function cb (e) {\n          if (!e || /transform$/.test(e.propertyName)) {\n            el.removeEventListener(transitionEndEvent, cb);\n            el._moveCb = null;\n            removeTransitionClass(el, moveClass);\n          }\n        });\n      }\n    });\n  },\n\n  methods: {\n    hasMove: function hasMove (el, moveClass) {\n      /* istanbul ignore if */\n      if (!hasTransition) {\n        return false\n      }\n      if (this._hasMove != null) {\n        return this._hasMove\n      }\n      addTransitionClass(el, moveClass);\n      var info = getTransitionInfo(el);\n      removeTransitionClass(el, moveClass);\n      return (this._hasMove = info.hasTransform)\n    }\n  }\n};\n\nfunction callPendingCbs (c) {\n  /* istanbul ignore if */\n  if (c.elm._moveCb) {\n    c.elm._moveCb();\n  }\n  /* istanbul ignore if */\n  if (c.elm._enterCb) {\n    c.elm._enterCb();\n  }\n}\n\nfunction recordPosition (c) {\n  c.data.newPos = c.elm.getBoundingClientRect();\n}\n\nfunction applyTranslation (c) {\n  var oldPos = c.data.pos;\n  var newPos = c.data.newPos;\n  var dx = oldPos.left - newPos.left;\n  var dy = oldPos.top - newPos.top;\n  if (dx || dy) {\n    c.data.moved = true;\n    var s = c.elm.style;\n    s.transform = s.WebkitTransform = \"translate(\" + dx + \"px,\" + dy + \"px)\";\n    s.transitionDuration = '0s';\n  }\n}\n\nvar platformComponents = {\n  Transition: Transition,\n  TransitionGroup: TransitionGroup\n};\n\n/*  */\n\n// install platform specific utils\nVue$2.config.isUnknownElement = isUnknownElement;\nVue$2.config.isReservedTag = isReservedTag;\nVue$2.config.getTagNamespace = getTagNamespace;\nVue$2.config.mustUseProp = mustUseProp;\n\n// install platform runtime directives & components\nextend(Vue$2.options.directives, platformDirectives);\nextend(Vue$2.options.components, platformComponents);\n\n// install platform patch function\nVue$2.prototype.__patch__ = config._isServer ? noop : patch$1;\n\n// wrap mount\nVue$2.prototype.$mount = function (\n  el,\n  hydrating\n) {\n  el = el && !config._isServer ? query(el) : undefined;\n  return this._mount(el, hydrating)\n};\n\n// devtools global hook\n/* istanbul ignore next */\nsetTimeout(function () {\n  if (config.devtools) {\n    if (devtools) {\n      devtools.emit('init', Vue$2);\n    } else if (\n      process.env.NODE_ENV !== 'production' &&\n      inBrowser && /Chrome\\/\\d+/.test(window.navigator.userAgent)\n    ) {\n      console.log(\n        'Download the Vue Devtools for a better development experience:\\n' +\n        'https://github.com/vuejs/vue-devtools'\n      );\n    }\n  }\n}, 0);\n\nmodule.exports = Vue$2;\n\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+Ly4yLjAuOEB2dWUvZGlzdC92dWUuY29tbW9uLmpzPzk1NTYiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsaUJBQWlCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQiwrQkFBK0I7QUFDckQsc0JBQXNCLGlCQUFpQjtBQUN2Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELGlDQUFpQyxFQUFFO0FBQ3JGLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsZ0JBQWdCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsY0FBYzs7QUFFcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCLGdCQUFnQjtBQUNqQyxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLHFCQUFxQixxQkFBcUI7QUFDMUMsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsbUJBQW1CO0FBQ3RDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixrQkFBa0I7QUFDcEM7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHFCQUFxQixjQUFjO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsT0FBTztBQUN6QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1CQUFtQiw4QkFBOEI7QUFDakQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixvQkFBb0IsRUFBRTs7QUFFcEQ7QUFDQTtBQUNBLGlCQUFpQixzQkFBc0I7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQix5QkFBeUI7QUFDMUMsR0FBRztBQUNIO0FBQ0E7QUFDQSxpQkFBaUIsK0JBQStCO0FBQ2hEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLDJCQUEyQjtBQUM5QztBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQzs7QUFFRDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixpQkFBaUI7QUFDbEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLE9BQU87QUFDMUM7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxPQUFPO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsT0FBTztBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUEsbUJBQW1CLGlCQUFpQjtBQUNwQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixvQkFBb0I7QUFDM0M7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQkFBaUIsbUJBQW1CO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSwyREFBMkQ7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSx1QkFBdUIsZ0JBQWdCLE9BQU8saUJBQWlCO0FBQy9EO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtQkFBbUIsZ0JBQWdCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxPQUFPO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxPQUFPO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxtREFBbUQsZ0NBQWdDLEVBQUU7QUFDckY7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLHFCQUFxQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLE9BQU87QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxhQUFhO0FBQ2I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixnQ0FBZ0M7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQix3Q0FBd0M7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsT0FBTztBQUM5QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQix5QkFBeUI7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxtQkFBbUI7QUFDbkIsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxxQkFBcUIsaUJBQWlCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsK0JBQStCLFVBQVU7QUFDekM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsT0FBTztBQUN4QztBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0Esa0NBQWtDLE9BQU87QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0Esb0RBQW9EO0FBQ3BELDhDQUE4QztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsT0FBTztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlEO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxPQUFPO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLGlCQUFpQixpQkFBaUI7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQixtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsT0FBTztBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsMkJBQTJCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxTQUFTO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLGFBQWEsRUFBRTtBQUM3QjtBQUNBO0FBQ0EsY0FBYyxhQUFhLEVBQUU7QUFDN0IsNkJBQTZCLDRCQUE0QixFQUFFO0FBQzNEO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzRUFBc0U7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsZUFBZTtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLG9CQUFvQix5QkFBeUI7QUFDN0MsQ0FBQzs7QUFFRDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxPQUFPO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGtCQUFrQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsNkNBQTZDOztBQUU3Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLDRCQUE0QixFQUFFO0FBQzNFLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLCtCQUErQixFQUFFO0FBQzlFLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSwyREFBMkQ7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RDtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxtQ0FBbUMscUNBQXFDOztBQUV4RTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLDJCQUEyQjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHVDQUF1Qzs7QUFFdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQiLCJmaWxlIjoiMS5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogVnVlLmpzIHYyLjAuOFxuICogKGMpIDIwMTQtMjAxNiBFdmFuIFlvdVxuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuICovXG4ndXNlIHN0cmljdCc7XG5cbi8qICAqL1xuXG4vKipcbiAqIENvbnZlcnQgYSB2YWx1ZSB0byBhIHN0cmluZyB0aGF0IGlzIGFjdHVhbGx5IHJlbmRlcmVkLlxuICovXG5mdW5jdGlvbiBfdG9TdHJpbmcgKHZhbCkge1xuICByZXR1cm4gdmFsID09IG51bGxcbiAgICA/ICcnXG4gICAgOiB0eXBlb2YgdmFsID09PSAnb2JqZWN0J1xuICAgICAgPyBKU09OLnN0cmluZ2lmeSh2YWwsIG51bGwsIDIpXG4gICAgICA6IFN0cmluZyh2YWwpXG59XG5cbi8qKlxuICogQ29udmVydCBhIGlucHV0IHZhbHVlIHRvIGEgbnVtYmVyIGZvciBwZXJzaXN0ZW5jZS5cbiAqIElmIHRoZSBjb252ZXJzaW9uIGZhaWxzLCByZXR1cm4gb3JpZ2luYWwgc3RyaW5nLlxuICovXG5mdW5jdGlvbiB0b051bWJlciAodmFsKSB7XG4gIHZhciBuID0gcGFyc2VGbG9hdCh2YWwsIDEwKTtcbiAgcmV0dXJuIChuIHx8IG4gPT09IDApID8gbiA6IHZhbFxufVxuXG4vKipcbiAqIE1ha2UgYSBtYXAgYW5kIHJldHVybiBhIGZ1bmN0aW9uIGZvciBjaGVja2luZyBpZiBhIGtleVxuICogaXMgaW4gdGhhdCBtYXAuXG4gKi9cbmZ1bmN0aW9uIG1ha2VNYXAgKFxuICBzdHIsXG4gIGV4cGVjdHNMb3dlckNhc2Vcbikge1xuICB2YXIgbWFwID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgdmFyIGxpc3QgPSBzdHIuc3BsaXQoJywnKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgbWFwW2xpc3RbaV1dID0gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZXhwZWN0c0xvd2VyQ2FzZVxuICAgID8gZnVuY3Rpb24gKHZhbCkgeyByZXR1cm4gbWFwW3ZhbC50b0xvd2VyQ2FzZSgpXTsgfVxuICAgIDogZnVuY3Rpb24gKHZhbCkgeyByZXR1cm4gbWFwW3ZhbF07IH1cbn1cblxuLyoqXG4gKiBDaGVjayBpZiBhIHRhZyBpcyBhIGJ1aWx0LWluIHRhZy5cbiAqL1xudmFyIGlzQnVpbHRJblRhZyA9IG1ha2VNYXAoJ3Nsb3QsY29tcG9uZW50JywgdHJ1ZSk7XG5cbi8qKlxuICogUmVtb3ZlIGFuIGl0ZW0gZnJvbSBhbiBhcnJheVxuICovXG5mdW5jdGlvbiByZW1vdmUkMSAoYXJyLCBpdGVtKSB7XG4gIGlmIChhcnIubGVuZ3RoKSB7XG4gICAgdmFyIGluZGV4ID0gYXJyLmluZGV4T2YoaXRlbSk7XG4gICAgaWYgKGluZGV4ID4gLTEpIHtcbiAgICAgIHJldHVybiBhcnIuc3BsaWNlKGluZGV4LCAxKVxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIENoZWNrIHdoZXRoZXIgdGhlIG9iamVjdCBoYXMgdGhlIHByb3BlcnR5LlxuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuZnVuY3Rpb24gaGFzT3duIChvYmosIGtleSkge1xuICByZXR1cm4gaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSlcbn1cblxuLyoqXG4gKiBDaGVjayBpZiB2YWx1ZSBpcyBwcmltaXRpdmVcbiAqL1xuZnVuY3Rpb24gaXNQcmltaXRpdmUgKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcidcbn1cblxuLyoqXG4gKiBDcmVhdGUgYSBjYWNoZWQgdmVyc2lvbiBvZiBhIHB1cmUgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGNhY2hlZCAoZm4pIHtcbiAgdmFyIGNhY2hlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgcmV0dXJuIGZ1bmN0aW9uIGNhY2hlZEZuIChzdHIpIHtcbiAgICB2YXIgaGl0ID0gY2FjaGVbc3RyXTtcbiAgICByZXR1cm4gaGl0IHx8IChjYWNoZVtzdHJdID0gZm4oc3RyKSlcbiAgfVxufVxuXG4vKipcbiAqIENhbWVsaXplIGEgaHlwaGVuLWRlbG1pdGVkIHN0cmluZy5cbiAqL1xudmFyIGNhbWVsaXplUkUgPSAvLShcXHcpL2c7XG52YXIgY2FtZWxpemUgPSBjYWNoZWQoZnVuY3Rpb24gKHN0cikge1xuICByZXR1cm4gc3RyLnJlcGxhY2UoY2FtZWxpemVSRSwgZnVuY3Rpb24gKF8sIGMpIHsgcmV0dXJuIGMgPyBjLnRvVXBwZXJDYXNlKCkgOiAnJzsgfSlcbn0pO1xuXG4vKipcbiAqIENhcGl0YWxpemUgYSBzdHJpbmcuXG4gKi9cbnZhciBjYXBpdGFsaXplID0gY2FjaGVkKGZ1bmN0aW9uIChzdHIpIHtcbiAgcmV0dXJuIHN0ci5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHN0ci5zbGljZSgxKVxufSk7XG5cbi8qKlxuICogSHlwaGVuYXRlIGEgY2FtZWxDYXNlIHN0cmluZy5cbiAqL1xudmFyIGh5cGhlbmF0ZVJFID0gLyhbXi1dKShbQS1aXSkvZztcbnZhciBoeXBoZW5hdGUgPSBjYWNoZWQoZnVuY3Rpb24gKHN0cikge1xuICByZXR1cm4gc3RyXG4gICAgLnJlcGxhY2UoaHlwaGVuYXRlUkUsICckMS0kMicpXG4gICAgLnJlcGxhY2UoaHlwaGVuYXRlUkUsICckMS0kMicpXG4gICAgLnRvTG93ZXJDYXNlKClcbn0pO1xuXG4vKipcbiAqIFNpbXBsZSBiaW5kLCBmYXN0ZXIgdGhhbiBuYXRpdmVcbiAqL1xuZnVuY3Rpb24gYmluZCQxIChmbiwgY3R4KSB7XG4gIGZ1bmN0aW9uIGJvdW5kRm4gKGEpIHtcbiAgICB2YXIgbCA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgcmV0dXJuIGxcbiAgICAgID8gbCA+IDFcbiAgICAgICAgPyBmbi5hcHBseShjdHgsIGFyZ3VtZW50cylcbiAgICAgICAgOiBmbi5jYWxsKGN0eCwgYSlcbiAgICAgIDogZm4uY2FsbChjdHgpXG4gIH1cbiAgLy8gcmVjb3JkIG9yaWdpbmFsIGZuIGxlbmd0aFxuICBib3VuZEZuLl9sZW5ndGggPSBmbi5sZW5ndGg7XG4gIHJldHVybiBib3VuZEZuXG59XG5cbi8qKlxuICogQ29udmVydCBhbiBBcnJheS1saWtlIG9iamVjdCB0byBhIHJlYWwgQXJyYXkuXG4gKi9cbmZ1bmN0aW9uIHRvQXJyYXkgKGxpc3QsIHN0YXJ0KSB7XG4gIHN0YXJ0ID0gc3RhcnQgfHwgMDtcbiAgdmFyIGkgPSBsaXN0Lmxlbmd0aCAtIHN0YXJ0O1xuICB2YXIgcmV0ID0gbmV3IEFycmF5KGkpO1xuICB3aGlsZSAoaS0tKSB7XG4gICAgcmV0W2ldID0gbGlzdFtpICsgc3RhcnRdO1xuICB9XG4gIHJldHVybiByZXRcbn1cblxuLyoqXG4gKiBNaXggcHJvcGVydGllcyBpbnRvIHRhcmdldCBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIGV4dGVuZCAodG8sIF9mcm9tKSB7XG4gIGZvciAodmFyIGtleSBpbiBfZnJvbSkge1xuICAgIHRvW2tleV0gPSBfZnJvbVtrZXldO1xuICB9XG4gIHJldHVybiB0b1xufVxuXG4vKipcbiAqIFF1aWNrIG9iamVjdCBjaGVjayAtIHRoaXMgaXMgcHJpbWFyaWx5IHVzZWQgdG8gdGVsbFxuICogT2JqZWN0cyBmcm9tIHByaW1pdGl2ZSB2YWx1ZXMgd2hlbiB3ZSBrbm93IHRoZSB2YWx1ZVxuICogaXMgYSBKU09OLWNvbXBsaWFudCB0eXBlLlxuICovXG5mdW5jdGlvbiBpc09iamVjdCAob2JqKSB7XG4gIHJldHVybiBvYmogIT09IG51bGwgJiYgdHlwZW9mIG9iaiA9PT0gJ29iamVjdCdcbn1cblxuLyoqXG4gKiBTdHJpY3Qgb2JqZWN0IHR5cGUgY2hlY2suIE9ubHkgcmV0dXJucyB0cnVlXG4gKiBmb3IgcGxhaW4gSmF2YVNjcmlwdCBvYmplY3RzLlxuICovXG52YXIgdG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xudmFyIE9CSkVDVF9TVFJJTkcgPSAnW29iamVjdCBPYmplY3RdJztcbmZ1bmN0aW9uIGlzUGxhaW5PYmplY3QgKG9iaikge1xuICByZXR1cm4gdG9TdHJpbmcuY2FsbChvYmopID09PSBPQkpFQ1RfU1RSSU5HXG59XG5cbi8qKlxuICogTWVyZ2UgYW4gQXJyYXkgb2YgT2JqZWN0cyBpbnRvIGEgc2luZ2xlIE9iamVjdC5cbiAqL1xuZnVuY3Rpb24gdG9PYmplY3QgKGFycikge1xuICB2YXIgcmVzID0ge307XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKGFycltpXSkge1xuICAgICAgZXh0ZW5kKHJlcywgYXJyW2ldKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG4vKipcbiAqIFBlcmZvcm0gbm8gb3BlcmF0aW9uLlxuICovXG5mdW5jdGlvbiBub29wICgpIHt9XG5cbi8qKlxuICogQWx3YXlzIHJldHVybiBmYWxzZS5cbiAqL1xudmFyIG5vID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gZmFsc2U7IH07XG5cbi8qKlxuICogR2VuZXJhdGUgYSBzdGF0aWMga2V5cyBzdHJpbmcgZnJvbSBjb21waWxlciBtb2R1bGVzLlxuICovXG5mdW5jdGlvbiBnZW5TdGF0aWNLZXlzIChtb2R1bGVzKSB7XG4gIHJldHVybiBtb2R1bGVzLnJlZHVjZShmdW5jdGlvbiAoa2V5cywgbSkge1xuICAgIHJldHVybiBrZXlzLmNvbmNhdChtLnN0YXRpY0tleXMgfHwgW10pXG4gIH0sIFtdKS5qb2luKCcsJylcbn1cblxuLyoqXG4gKiBDaGVjayBpZiB0d28gdmFsdWVzIGFyZSBsb29zZWx5IGVxdWFsIC0gdGhhdCBpcyxcbiAqIGlmIHRoZXkgYXJlIHBsYWluIG9iamVjdHMsIGRvIHRoZXkgaGF2ZSB0aGUgc2FtZSBzaGFwZT9cbiAqL1xuZnVuY3Rpb24gbG9vc2VFcXVhbCAoYSwgYikge1xuICAvKiBlc2xpbnQtZGlzYWJsZSBlcWVxZXEgKi9cbiAgcmV0dXJuIGEgPT0gYiB8fCAoXG4gICAgaXNPYmplY3QoYSkgJiYgaXNPYmplY3QoYilcbiAgICAgID8gSlNPTi5zdHJpbmdpZnkoYSkgPT09IEpTT04uc3RyaW5naWZ5KGIpXG4gICAgICA6IGZhbHNlXG4gIClcbiAgLyogZXNsaW50LWVuYWJsZSBlcWVxZXEgKi9cbn1cblxuZnVuY3Rpb24gbG9vc2VJbmRleE9mIChhcnIsIHZhbCkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuICAgIGlmIChsb29zZUVxdWFsKGFycltpXSwgdmFsKSkgeyByZXR1cm4gaSB9XG4gIH1cbiAgcmV0dXJuIC0xXG59XG5cbi8qICAqL1xuXG52YXIgY29uZmlnID0ge1xuICAvKipcbiAgICogT3B0aW9uIG1lcmdlIHN0cmF0ZWdpZXMgKHVzZWQgaW4gY29yZS91dGlsL29wdGlvbnMpXG4gICAqL1xuICBvcHRpb25NZXJnZVN0cmF0ZWdpZXM6IE9iamVjdC5jcmVhdGUobnVsbCksXG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgdG8gc3VwcHJlc3Mgd2FybmluZ3MuXG4gICAqL1xuICBzaWxlbnQ6IGZhbHNlLFxuXG4gIC8qKlxuICAgKiBXaGV0aGVyIHRvIGVuYWJsZSBkZXZ0b29sc1xuICAgKi9cbiAgZGV2dG9vbHM6IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicsXG5cbiAgLyoqXG4gICAqIEVycm9yIGhhbmRsZXIgZm9yIHdhdGNoZXIgZXJyb3JzXG4gICAqL1xuICBlcnJvckhhbmRsZXI6IG51bGwsXG5cbiAgLyoqXG4gICAqIElnbm9yZSBjZXJ0YWluIGN1c3RvbSBlbGVtZW50c1xuICAgKi9cbiAgaWdub3JlZEVsZW1lbnRzOiBudWxsLFxuXG4gIC8qKlxuICAgKiBDdXN0b20gdXNlciBrZXkgYWxpYXNlcyBmb3Igdi1vblxuICAgKi9cbiAga2V5Q29kZXM6IE9iamVjdC5jcmVhdGUobnVsbCksXG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIGEgdGFnIGlzIHJlc2VydmVkIHNvIHRoYXQgaXQgY2Fubm90IGJlIHJlZ2lzdGVyZWQgYXMgYVxuICAgKiBjb21wb25lbnQuIFRoaXMgaXMgcGxhdGZvcm0tZGVwZW5kZW50IGFuZCBtYXkgYmUgb3ZlcndyaXR0ZW4uXG4gICAqL1xuICBpc1Jlc2VydmVkVGFnOiBubyxcblxuICAvKipcbiAgICogQ2hlY2sgaWYgYSB0YWcgaXMgYW4gdW5rbm93biBlbGVtZW50LlxuICAgKiBQbGF0Zm9ybS1kZXBlbmRlbnQuXG4gICAqL1xuICBpc1Vua25vd25FbGVtZW50OiBubyxcblxuICAvKipcbiAgICogR2V0IHRoZSBuYW1lc3BhY2Ugb2YgYW4gZWxlbWVudFxuICAgKi9cbiAgZ2V0VGFnTmFtZXNwYWNlOiBub29wLFxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiBhbiBhdHRyaWJ1dGUgbXVzdCBiZSBib3VuZCB1c2luZyBwcm9wZXJ0eSwgZS5nLiB2YWx1ZVxuICAgKiBQbGF0Zm9ybS1kZXBlbmRlbnQuXG4gICAqL1xuICBtdXN0VXNlUHJvcDogbm8sXG5cbiAgLyoqXG4gICAqIExpc3Qgb2YgYXNzZXQgdHlwZXMgdGhhdCBhIGNvbXBvbmVudCBjYW4gb3duLlxuICAgKi9cbiAgX2Fzc2V0VHlwZXM6IFtcbiAgICAnY29tcG9uZW50JyxcbiAgICAnZGlyZWN0aXZlJyxcbiAgICAnZmlsdGVyJ1xuICBdLFxuXG4gIC8qKlxuICAgKiBMaXN0IG9mIGxpZmVjeWNsZSBob29rcy5cbiAgICovXG4gIF9saWZlY3ljbGVIb29rczogW1xuICAgICdiZWZvcmVDcmVhdGUnLFxuICAgICdjcmVhdGVkJyxcbiAgICAnYmVmb3JlTW91bnQnLFxuICAgICdtb3VudGVkJyxcbiAgICAnYmVmb3JlVXBkYXRlJyxcbiAgICAndXBkYXRlZCcsXG4gICAgJ2JlZm9yZURlc3Ryb3knLFxuICAgICdkZXN0cm95ZWQnLFxuICAgICdhY3RpdmF0ZWQnLFxuICAgICdkZWFjdGl2YXRlZCdcbiAgXSxcblxuICAvKipcbiAgICogTWF4IGNpcmN1bGFyIHVwZGF0ZXMgYWxsb3dlZCBpbiBhIHNjaGVkdWxlciBmbHVzaCBjeWNsZS5cbiAgICovXG4gIF9tYXhVcGRhdGVDb3VudDogMTAwLFxuXG4gIC8qKlxuICAgKiBTZXJ2ZXIgcmVuZGVyaW5nP1xuICAgKi9cbiAgX2lzU2VydmVyOiBwcm9jZXNzLmVudi5WVUVfRU5WID09PSAnc2VydmVyJ1xufTtcblxuLyogICovXG5cbi8qKlxuICogQ2hlY2sgaWYgYSBzdHJpbmcgc3RhcnRzIHdpdGggJCBvciBfXG4gKi9cbmZ1bmN0aW9uIGlzUmVzZXJ2ZWQgKHN0cikge1xuICB2YXIgYyA9IChzdHIgKyAnJykuY2hhckNvZGVBdCgwKTtcbiAgcmV0dXJuIGMgPT09IDB4MjQgfHwgYyA9PT0gMHg1RlxufVxuXG4vKipcbiAqIERlZmluZSBhIHByb3BlcnR5LlxuICovXG5mdW5jdGlvbiBkZWYgKG9iaiwga2V5LCB2YWwsIGVudW1lcmFibGUpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XG4gICAgdmFsdWU6IHZhbCxcbiAgICBlbnVtZXJhYmxlOiAhIWVudW1lcmFibGUsXG4gICAgd3JpdGFibGU6IHRydWUsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xufVxuXG4vKipcbiAqIFBhcnNlIHNpbXBsZSBwYXRoLlxuICovXG52YXIgYmFpbFJFID0gL1teXFx3LiRdLztcbmZ1bmN0aW9uIHBhcnNlUGF0aCAocGF0aCkge1xuICBpZiAoYmFpbFJFLnRlc3QocGF0aCkpIHtcbiAgICByZXR1cm5cbiAgfSBlbHNlIHtcbiAgICB2YXIgc2VnbWVudHMgPSBwYXRoLnNwbGl0KCcuJyk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChvYmopIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2VnbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKCFvYmopIHsgcmV0dXJuIH1cbiAgICAgICAgb2JqID0gb2JqW3NlZ21lbnRzW2ldXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBvYmpcbiAgICB9XG4gIH1cbn1cblxuLyogICovXG4vKiBnbG9iYWxzIE11dGF0aW9uT2JzZXJ2ZXIgKi9cblxuLy8gY2FuIHdlIHVzZSBfX3Byb3RvX18/XG52YXIgaGFzUHJvdG8gPSAnX19wcm90b19fJyBpbiB7fTtcblxuLy8gQnJvd3NlciBlbnZpcm9ubWVudCBzbmlmZmluZ1xudmFyIGluQnJvd3NlciA9XG4gIHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmXG4gIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh3aW5kb3cpICE9PSAnW29iamVjdCBPYmplY3RdJztcblxudmFyIFVBID0gaW5Ccm93c2VyICYmIHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCk7XG52YXIgaXNJRSA9IFVBICYmIC9tc2llfHRyaWRlbnQvLnRlc3QoVUEpO1xudmFyIGlzSUU5ID0gVUEgJiYgVUEuaW5kZXhPZignbXNpZSA5LjAnKSA+IDA7XG52YXIgaXNFZGdlID0gVUEgJiYgVUEuaW5kZXhPZignZWRnZS8nKSA+IDA7XG52YXIgaXNBbmRyb2lkID0gVUEgJiYgVUEuaW5kZXhPZignYW5kcm9pZCcpID4gMDtcbnZhciBpc0lPUyA9IFVBICYmIC9pcGhvbmV8aXBhZHxpcG9kfGlvcy8udGVzdChVQSk7XG5cbi8vIGRldGVjdCBkZXZ0b29sc1xudmFyIGRldnRvb2xzID0gaW5Ccm93c2VyICYmIHdpbmRvdy5fX1ZVRV9ERVZUT09MU19HTE9CQUxfSE9PS19fO1xuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuZnVuY3Rpb24gaXNOYXRpdmUgKEN0b3IpIHtcbiAgcmV0dXJuIC9uYXRpdmUgY29kZS8udGVzdChDdG9yLnRvU3RyaW5nKCkpXG59XG5cbi8qKlxuICogRGVmZXIgYSB0YXNrIHRvIGV4ZWN1dGUgaXQgYXN5bmNocm9ub3VzbHkuXG4gKi9cbnZhciBuZXh0VGljayA9IChmdW5jdGlvbiAoKSB7XG4gIHZhciBjYWxsYmFja3MgPSBbXTtcbiAgdmFyIHBlbmRpbmcgPSBmYWxzZTtcbiAgdmFyIHRpbWVyRnVuYztcblxuICBmdW5jdGlvbiBuZXh0VGlja0hhbmRsZXIgKCkge1xuICAgIHBlbmRpbmcgPSBmYWxzZTtcbiAgICB2YXIgY29waWVzID0gY2FsbGJhY2tzLnNsaWNlKDApO1xuICAgIGNhbGxiYWNrcy5sZW5ndGggPSAwO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29waWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb3BpZXNbaV0oKTtcbiAgICB9XG4gIH1cblxuICAvLyB0aGUgbmV4dFRpY2sgYmVoYXZpb3IgbGV2ZXJhZ2VzIHRoZSBtaWNyb3Rhc2sgcXVldWUsIHdoaWNoIGNhbiBiZSBhY2Nlc3NlZFxuICAvLyB2aWEgZWl0aGVyIG5hdGl2ZSBQcm9taXNlLnRoZW4gb3IgTXV0YXRpb25PYnNlcnZlci5cbiAgLy8gTXV0YXRpb25PYnNlcnZlciBoYXMgd2lkZXIgc3VwcG9ydCwgaG93ZXZlciBpdCBpcyBzZXJpb3VzbHkgYnVnZ2VkIGluXG4gIC8vIFVJV2ViVmlldyBpbiBpT1MgPj0gOS4zLjMgd2hlbiB0cmlnZ2VyZWQgaW4gdG91Y2ggZXZlbnQgaGFuZGxlcnMuIEl0XG4gIC8vIGNvbXBsZXRlbHkgc3RvcHMgd29ya2luZyBhZnRlciB0cmlnZ2VyaW5nIGEgZmV3IHRpbWVzLi4uIHNvLCBpZiBuYXRpdmVcbiAgLy8gUHJvbWlzZSBpcyBhdmFpbGFibGUsIHdlIHdpbGwgdXNlIGl0OlxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKHR5cGVvZiBQcm9taXNlICE9PSAndW5kZWZpbmVkJyAmJiBpc05hdGl2ZShQcm9taXNlKSkge1xuICAgIHZhciBwID0gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgdGltZXJGdW5jID0gZnVuY3Rpb24gKCkge1xuICAgICAgcC50aGVuKG5leHRUaWNrSGFuZGxlcik7XG4gICAgICAvLyBpbiBwcm9ibGVtYXRpYyBVSVdlYlZpZXdzLCBQcm9taXNlLnRoZW4gZG9lc24ndCBjb21wbGV0ZWx5IGJyZWFrLCBidXRcbiAgICAgIC8vIGl0IGNhbiBnZXQgc3R1Y2sgaW4gYSB3ZWlyZCBzdGF0ZSB3aGVyZSBjYWxsYmFja3MgYXJlIHB1c2hlZCBpbnRvIHRoZVxuICAgICAgLy8gbWljcm90YXNrIHF1ZXVlIGJ1dCB0aGUgcXVldWUgaXNuJ3QgYmVpbmcgZmx1c2hlZCwgdW50aWwgdGhlIGJyb3dzZXJcbiAgICAgIC8vIG5lZWRzIHRvIGRvIHNvbWUgb3RoZXIgd29yaywgZS5nLiBoYW5kbGUgYSB0aW1lci4gVGhlcmVmb3JlIHdlIGNhblxuICAgICAgLy8gXCJmb3JjZVwiIHRoZSBtaWNyb3Rhc2sgcXVldWUgdG8gYmUgZmx1c2hlZCBieSBhZGRpbmcgYW4gZW1wdHkgdGltZXIuXG4gICAgICBpZiAoaXNJT1MpIHsgc2V0VGltZW91dChub29wKTsgfVxuICAgIH07XG4gIH0gZWxzZSBpZiAodHlwZW9mIE11dGF0aW9uT2JzZXJ2ZXIgIT09ICd1bmRlZmluZWQnICYmIChcbiAgICBpc05hdGl2ZShNdXRhdGlvbk9ic2VydmVyKSB8fFxuICAgIC8vIFBoYW50b21KUyBhbmQgaU9TIDcueFxuICAgIE11dGF0aW9uT2JzZXJ2ZXIudG9TdHJpbmcoKSA9PT0gJ1tvYmplY3QgTXV0YXRpb25PYnNlcnZlckNvbnN0cnVjdG9yXSdcbiAgKSkge1xuICAgIC8vIHVzZSBNdXRhdGlvbk9ic2VydmVyIHdoZXJlIG5hdGl2ZSBQcm9taXNlIGlzIG5vdCBhdmFpbGFibGUsXG4gICAgLy8gZS5nLiBQaGFudG9tSlMgSUUxMSwgaU9TNywgQW5kcm9pZCA0LjRcbiAgICB2YXIgY291bnRlciA9IDE7XG4gICAgdmFyIG9ic2VydmVyID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIobmV4dFRpY2tIYW5kbGVyKTtcbiAgICB2YXIgdGV4dE5vZGUgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShTdHJpbmcoY291bnRlcikpO1xuICAgIG9ic2VydmVyLm9ic2VydmUodGV4dE5vZGUsIHtcbiAgICAgIGNoYXJhY3RlckRhdGE6IHRydWVcbiAgICB9KTtcbiAgICB0aW1lckZ1bmMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBjb3VudGVyID0gKGNvdW50ZXIgKyAxKSAlIDI7XG4gICAgICB0ZXh0Tm9kZS5kYXRhID0gU3RyaW5nKGNvdW50ZXIpO1xuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgLy8gZmFsbGJhY2sgdG8gc2V0VGltZW91dFxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgdGltZXJGdW5jID0gZnVuY3Rpb24gKCkge1xuICAgICAgc2V0VGltZW91dChuZXh0VGlja0hhbmRsZXIsIDApO1xuICAgIH07XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24gcXVldWVOZXh0VGljayAoY2IsIGN0eCkge1xuICAgIHZhciBmdW5jID0gY3R4XG4gICAgICA/IGZ1bmN0aW9uICgpIHsgY2IuY2FsbChjdHgpOyB9XG4gICAgICA6IGNiO1xuICAgIGNhbGxiYWNrcy5wdXNoKGZ1bmMpO1xuICAgIGlmICghcGVuZGluZykge1xuICAgICAgcGVuZGluZyA9IHRydWU7XG4gICAgICB0aW1lckZ1bmMoKTtcbiAgICB9XG4gIH1cbn0pKCk7XG5cbnZhciBfU2V0O1xuLyogaXN0YW5idWwgaWdub3JlIGlmICovXG5pZiAodHlwZW9mIFNldCAhPT0gJ3VuZGVmaW5lZCcgJiYgaXNOYXRpdmUoU2V0KSkge1xuICAvLyB1c2UgbmF0aXZlIFNldCB3aGVuIGF2YWlsYWJsZS5cbiAgX1NldCA9IFNldDtcbn0gZWxzZSB7XG4gIC8vIGEgbm9uLXN0YW5kYXJkIFNldCBwb2x5ZmlsbCB0aGF0IG9ubHkgd29ya3Mgd2l0aCBwcmltaXRpdmUga2V5cy5cbiAgX1NldCA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gU2V0ICgpIHtcbiAgICAgIHRoaXMuc2V0ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB9XG4gICAgU2V0LnByb3RvdHlwZS5oYXMgPSBmdW5jdGlvbiBoYXMgKGtleSkge1xuICAgICAgcmV0dXJuIHRoaXMuc2V0W2tleV0gIT09IHVuZGVmaW5lZFxuICAgIH07XG4gICAgU2V0LnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiBhZGQgKGtleSkge1xuICAgICAgdGhpcy5zZXRba2V5XSA9IDE7XG4gICAgfTtcbiAgICBTZXQucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gY2xlYXIgKCkge1xuICAgICAgdGhpcy5zZXQgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIH07XG5cbiAgICByZXR1cm4gU2V0O1xuICB9KCkpO1xufVxuXG4vKiBub3QgdHlwZSBjaGVja2luZyB0aGlzIGZpbGUgYmVjYXVzZSBmbG93IGRvZXNuJ3QgcGxheSB3ZWxsIHdpdGggUHJveHkgKi9cblxudmFyIGhhc1Byb3h5O1xudmFyIHByb3h5SGFuZGxlcnM7XG52YXIgaW5pdFByb3h5O1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICB2YXIgYWxsb3dlZEdsb2JhbHMgPSBtYWtlTWFwKFxuICAgICdJbmZpbml0eSx1bmRlZmluZWQsTmFOLGlzRmluaXRlLGlzTmFOLCcgK1xuICAgICdwYXJzZUZsb2F0LHBhcnNlSW50LGRlY29kZVVSSSxkZWNvZGVVUklDb21wb25lbnQsZW5jb2RlVVJJLGVuY29kZVVSSUNvbXBvbmVudCwnICtcbiAgICAnTWF0aCxOdW1iZXIsRGF0ZSxBcnJheSxPYmplY3QsQm9vbGVhbixTdHJpbmcsUmVnRXhwLE1hcCxTZXQsSlNPTixJbnRsLCcgK1xuICAgICdyZXF1aXJlJyAvLyBmb3IgV2VicGFjay9Ccm93c2VyaWZ5XG4gICk7XG5cbiAgaGFzUHJveHkgPVxuICAgIHR5cGVvZiBQcm94eSAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICBQcm94eS50b1N0cmluZygpLm1hdGNoKC9uYXRpdmUgY29kZS8pO1xuXG4gIHByb3h5SGFuZGxlcnMgPSB7XG4gICAgaGFzOiBmdW5jdGlvbiBoYXMgKHRhcmdldCwga2V5KSB7XG4gICAgICB2YXIgaGFzID0ga2V5IGluIHRhcmdldDtcbiAgICAgIHZhciBpc0FsbG93ZWQgPSBhbGxvd2VkR2xvYmFscyhrZXkpIHx8IGtleS5jaGFyQXQoMCkgPT09ICdfJztcbiAgICAgIGlmICghaGFzICYmICFpc0FsbG93ZWQpIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICBcIlByb3BlcnR5IG9yIG1ldGhvZCBcXFwiXCIgKyBrZXkgKyBcIlxcXCIgaXMgbm90IGRlZmluZWQgb24gdGhlIGluc3RhbmNlIGJ1dCBcIiArXG4gICAgICAgICAgXCJyZWZlcmVuY2VkIGR1cmluZyByZW5kZXIuIE1ha2Ugc3VyZSB0byBkZWNsYXJlIHJlYWN0aXZlIGRhdGEgXCIgK1xuICAgICAgICAgIFwicHJvcGVydGllcyBpbiB0aGUgZGF0YSBvcHRpb24uXCIsXG4gICAgICAgICAgdGFyZ2V0XG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICByZXR1cm4gaGFzIHx8ICFpc0FsbG93ZWRcbiAgICB9XG4gIH07XG5cbiAgaW5pdFByb3h5ID0gZnVuY3Rpb24gaW5pdFByb3h5ICh2bSkge1xuICAgIGlmIChoYXNQcm94eSkge1xuICAgICAgdm0uX3JlbmRlclByb3h5ID0gbmV3IFByb3h5KHZtLCBwcm94eUhhbmRsZXJzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdm0uX3JlbmRlclByb3h5ID0gdm07XG4gICAgfVxuICB9O1xufVxuXG4vKiAgKi9cblxuXG52YXIgdWlkJDIgPSAwO1xuXG4vKipcbiAqIEEgZGVwIGlzIGFuIG9ic2VydmFibGUgdGhhdCBjYW4gaGF2ZSBtdWx0aXBsZVxuICogZGlyZWN0aXZlcyBzdWJzY3JpYmluZyB0byBpdC5cbiAqL1xudmFyIERlcCA9IGZ1bmN0aW9uIERlcCAoKSB7XG4gIHRoaXMuaWQgPSB1aWQkMisrO1xuICB0aGlzLnN1YnMgPSBbXTtcbn07XG5cbkRlcC5wcm90b3R5cGUuYWRkU3ViID0gZnVuY3Rpb24gYWRkU3ViIChzdWIpIHtcbiAgdGhpcy5zdWJzLnB1c2goc3ViKTtcbn07XG5cbkRlcC5wcm90b3R5cGUucmVtb3ZlU3ViID0gZnVuY3Rpb24gcmVtb3ZlU3ViIChzdWIpIHtcbiAgcmVtb3ZlJDEodGhpcy5zdWJzLCBzdWIpO1xufTtcblxuRGVwLnByb3RvdHlwZS5kZXBlbmQgPSBmdW5jdGlvbiBkZXBlbmQgKCkge1xuICBpZiAoRGVwLnRhcmdldCkge1xuICAgIERlcC50YXJnZXQuYWRkRGVwKHRoaXMpO1xuICB9XG59O1xuXG5EZXAucHJvdG90eXBlLm5vdGlmeSA9IGZ1bmN0aW9uIG5vdGlmeSAoKSB7XG4gIC8vIHN0YWJsaXplIHRoZSBzdWJzY3JpYmVyIGxpc3QgZmlyc3RcbiAgdmFyIHN1YnMgPSB0aGlzLnN1YnMuc2xpY2UoKTtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBzdWJzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIHN1YnNbaV0udXBkYXRlKCk7XG4gIH1cbn07XG5cbi8vIHRoZSBjdXJyZW50IHRhcmdldCB3YXRjaGVyIGJlaW5nIGV2YWx1YXRlZC5cbi8vIHRoaXMgaXMgZ2xvYmFsbHkgdW5pcXVlIGJlY2F1c2UgdGhlcmUgY291bGQgYmUgb25seSBvbmVcbi8vIHdhdGNoZXIgYmVpbmcgZXZhbHVhdGVkIGF0IGFueSB0aW1lLlxuRGVwLnRhcmdldCA9IG51bGw7XG52YXIgdGFyZ2V0U3RhY2sgPSBbXTtcblxuZnVuY3Rpb24gcHVzaFRhcmdldCAoX3RhcmdldCkge1xuICBpZiAoRGVwLnRhcmdldCkgeyB0YXJnZXRTdGFjay5wdXNoKERlcC50YXJnZXQpOyB9XG4gIERlcC50YXJnZXQgPSBfdGFyZ2V0O1xufVxuXG5mdW5jdGlvbiBwb3BUYXJnZXQgKCkge1xuICBEZXAudGFyZ2V0ID0gdGFyZ2V0U3RhY2sucG9wKCk7XG59XG5cbi8qICAqL1xuXG5cbnZhciBxdWV1ZSA9IFtdO1xudmFyIGhhcyQxID0ge307XG52YXIgY2lyY3VsYXIgPSB7fTtcbnZhciB3YWl0aW5nID0gZmFsc2U7XG52YXIgZmx1c2hpbmcgPSBmYWxzZTtcbnZhciBpbmRleCA9IDA7XG5cbi8qKlxuICogUmVzZXQgdGhlIHNjaGVkdWxlcidzIHN0YXRlLlxuICovXG5mdW5jdGlvbiByZXNldFNjaGVkdWxlclN0YXRlICgpIHtcbiAgcXVldWUubGVuZ3RoID0gMDtcbiAgaGFzJDEgPSB7fTtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBjaXJjdWxhciA9IHt9O1xuICB9XG4gIHdhaXRpbmcgPSBmbHVzaGluZyA9IGZhbHNlO1xufVxuXG4vKipcbiAqIEZsdXNoIGJvdGggcXVldWVzIGFuZCBydW4gdGhlIHdhdGNoZXJzLlxuICovXG5mdW5jdGlvbiBmbHVzaFNjaGVkdWxlclF1ZXVlICgpIHtcbiAgZmx1c2hpbmcgPSB0cnVlO1xuXG4gIC8vIFNvcnQgcXVldWUgYmVmb3JlIGZsdXNoLlxuICAvLyBUaGlzIGVuc3VyZXMgdGhhdDpcbiAgLy8gMS4gQ29tcG9uZW50cyBhcmUgdXBkYXRlZCBmcm9tIHBhcmVudCB0byBjaGlsZC4gKGJlY2F1c2UgcGFyZW50IGlzIGFsd2F5c1xuICAvLyAgICBjcmVhdGVkIGJlZm9yZSB0aGUgY2hpbGQpXG4gIC8vIDIuIEEgY29tcG9uZW50J3MgdXNlciB3YXRjaGVycyBhcmUgcnVuIGJlZm9yZSBpdHMgcmVuZGVyIHdhdGNoZXIgKGJlY2F1c2VcbiAgLy8gICAgdXNlciB3YXRjaGVycyBhcmUgY3JlYXRlZCBiZWZvcmUgdGhlIHJlbmRlciB3YXRjaGVyKVxuICAvLyAzLiBJZiBhIGNvbXBvbmVudCBpcyBkZXN0cm95ZWQgZHVyaW5nIGEgcGFyZW50IGNvbXBvbmVudCdzIHdhdGNoZXIgcnVuLFxuICAvLyAgICBpdHMgd2F0Y2hlcnMgY2FuIGJlIHNraXBwZWQuXG4gIHF1ZXVlLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHsgcmV0dXJuIGEuaWQgLSBiLmlkOyB9KTtcblxuICAvLyBkbyBub3QgY2FjaGUgbGVuZ3RoIGJlY2F1c2UgbW9yZSB3YXRjaGVycyBtaWdodCBiZSBwdXNoZWRcbiAgLy8gYXMgd2UgcnVuIGV4aXN0aW5nIHdhdGNoZXJzXG4gIGZvciAoaW5kZXggPSAwOyBpbmRleCA8IHF1ZXVlLmxlbmd0aDsgaW5kZXgrKykge1xuICAgIHZhciB3YXRjaGVyID0gcXVldWVbaW5kZXhdO1xuICAgIHZhciBpZCA9IHdhdGNoZXIuaWQ7XG4gICAgaGFzJDFbaWRdID0gbnVsbDtcbiAgICB3YXRjaGVyLnJ1bigpO1xuICAgIC8vIGluIGRldiBidWlsZCwgY2hlY2sgYW5kIHN0b3AgY2lyY3VsYXIgdXBkYXRlcy5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBoYXMkMVtpZF0gIT0gbnVsbCkge1xuICAgICAgY2lyY3VsYXJbaWRdID0gKGNpcmN1bGFyW2lkXSB8fCAwKSArIDE7XG4gICAgICBpZiAoY2lyY3VsYXJbaWRdID4gY29uZmlnLl9tYXhVcGRhdGVDb3VudCkge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgICdZb3UgbWF5IGhhdmUgYW4gaW5maW5pdGUgdXBkYXRlIGxvb3AgJyArIChcbiAgICAgICAgICAgIHdhdGNoZXIudXNlclxuICAgICAgICAgICAgICA/IChcImluIHdhdGNoZXIgd2l0aCBleHByZXNzaW9uIFxcXCJcIiArICh3YXRjaGVyLmV4cHJlc3Npb24pICsgXCJcXFwiXCIpXG4gICAgICAgICAgICAgIDogXCJpbiBhIGNvbXBvbmVudCByZW5kZXIgZnVuY3Rpb24uXCJcbiAgICAgICAgICApLFxuICAgICAgICAgIHdhdGNoZXIudm1cbiAgICAgICAgKTtcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBkZXZ0b29sIGhvb2tcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChkZXZ0b29scyAmJiBjb25maWcuZGV2dG9vbHMpIHtcbiAgICBkZXZ0b29scy5lbWl0KCdmbHVzaCcpO1xuICB9XG5cbiAgcmVzZXRTY2hlZHVsZXJTdGF0ZSgpO1xufVxuXG4vKipcbiAqIFB1c2ggYSB3YXRjaGVyIGludG8gdGhlIHdhdGNoZXIgcXVldWUuXG4gKiBKb2JzIHdpdGggZHVwbGljYXRlIElEcyB3aWxsIGJlIHNraXBwZWQgdW5sZXNzIGl0J3NcbiAqIHB1c2hlZCB3aGVuIHRoZSBxdWV1ZSBpcyBiZWluZyBmbHVzaGVkLlxuICovXG5mdW5jdGlvbiBxdWV1ZVdhdGNoZXIgKHdhdGNoZXIpIHtcbiAgdmFyIGlkID0gd2F0Y2hlci5pZDtcbiAgaWYgKGhhcyQxW2lkXSA9PSBudWxsKSB7XG4gICAgaGFzJDFbaWRdID0gdHJ1ZTtcbiAgICBpZiAoIWZsdXNoaW5nKSB7XG4gICAgICBxdWV1ZS5wdXNoKHdhdGNoZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBpZiBhbHJlYWR5IGZsdXNoaW5nLCBzcGxpY2UgdGhlIHdhdGNoZXIgYmFzZWQgb24gaXRzIGlkXG4gICAgICAvLyBpZiBhbHJlYWR5IHBhc3QgaXRzIGlkLCBpdCB3aWxsIGJlIHJ1biBuZXh0IGltbWVkaWF0ZWx5LlxuICAgICAgdmFyIGkgPSBxdWV1ZS5sZW5ndGggLSAxO1xuICAgICAgd2hpbGUgKGkgPj0gMCAmJiBxdWV1ZVtpXS5pZCA+IHdhdGNoZXIuaWQpIHtcbiAgICAgICAgaS0tO1xuICAgICAgfVxuICAgICAgcXVldWUuc3BsaWNlKE1hdGgubWF4KGksIGluZGV4KSArIDEsIDAsIHdhdGNoZXIpO1xuICAgIH1cbiAgICAvLyBxdWV1ZSB0aGUgZmx1c2hcbiAgICBpZiAoIXdhaXRpbmcpIHtcbiAgICAgIHdhaXRpbmcgPSB0cnVlO1xuICAgICAgbmV4dFRpY2soZmx1c2hTY2hlZHVsZXJRdWV1ZSk7XG4gICAgfVxuICB9XG59XG5cbi8qICAqL1xuXG52YXIgdWlkJDEgPSAwO1xuXG4vKipcbiAqIEEgd2F0Y2hlciBwYXJzZXMgYW4gZXhwcmVzc2lvbiwgY29sbGVjdHMgZGVwZW5kZW5jaWVzLFxuICogYW5kIGZpcmVzIGNhbGxiYWNrIHdoZW4gdGhlIGV4cHJlc3Npb24gdmFsdWUgY2hhbmdlcy5cbiAqIFRoaXMgaXMgdXNlZCBmb3IgYm90aCB0aGUgJHdhdGNoKCkgYXBpIGFuZCBkaXJlY3RpdmVzLlxuICovXG52YXIgV2F0Y2hlciA9IGZ1bmN0aW9uIFdhdGNoZXIgKFxuICB2bSxcbiAgZXhwT3JGbixcbiAgY2IsXG4gIG9wdGlvbnNcbikge1xuICBpZiAoIG9wdGlvbnMgPT09IHZvaWQgMCApIG9wdGlvbnMgPSB7fTtcblxuICB0aGlzLnZtID0gdm07XG4gIHZtLl93YXRjaGVycy5wdXNoKHRoaXMpO1xuICAvLyBvcHRpb25zXG4gIHRoaXMuZGVlcCA9ICEhb3B0aW9ucy5kZWVwO1xuICB0aGlzLnVzZXIgPSAhIW9wdGlvbnMudXNlcjtcbiAgdGhpcy5sYXp5ID0gISFvcHRpb25zLmxhenk7XG4gIHRoaXMuc3luYyA9ICEhb3B0aW9ucy5zeW5jO1xuICB0aGlzLmV4cHJlc3Npb24gPSBleHBPckZuLnRvU3RyaW5nKCk7XG4gIHRoaXMuY2IgPSBjYjtcbiAgdGhpcy5pZCA9ICsrdWlkJDE7IC8vIHVpZCBmb3IgYmF0Y2hpbmdcbiAgdGhpcy5hY3RpdmUgPSB0cnVlO1xuICB0aGlzLmRpcnR5ID0gdGhpcy5sYXp5OyAvLyBmb3IgbGF6eSB3YXRjaGVyc1xuICB0aGlzLmRlcHMgPSBbXTtcbiAgdGhpcy5uZXdEZXBzID0gW107XG4gIHRoaXMuZGVwSWRzID0gbmV3IF9TZXQoKTtcbiAgdGhpcy5uZXdEZXBJZHMgPSBuZXcgX1NldCgpO1xuICAvLyBwYXJzZSBleHByZXNzaW9uIGZvciBnZXR0ZXJcbiAgaWYgKHR5cGVvZiBleHBPckZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhpcy5nZXR0ZXIgPSBleHBPckZuO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuZ2V0dGVyID0gcGFyc2VQYXRoKGV4cE9yRm4pO1xuICAgIGlmICghdGhpcy5nZXR0ZXIpIHtcbiAgICAgIHRoaXMuZ2V0dGVyID0gZnVuY3Rpb24gKCkge307XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXG4gICAgICAgIFwiRmFpbGVkIHdhdGNoaW5nIHBhdGg6IFxcXCJcIiArIGV4cE9yRm4gKyBcIlxcXCIgXCIgK1xuICAgICAgICAnV2F0Y2hlciBvbmx5IGFjY2VwdHMgc2ltcGxlIGRvdC1kZWxpbWl0ZWQgcGF0aHMuICcgK1xuICAgICAgICAnRm9yIGZ1bGwgY29udHJvbCwgdXNlIGEgZnVuY3Rpb24gaW5zdGVhZC4nLFxuICAgICAgICB2bVxuICAgICAgKTtcbiAgICB9XG4gIH1cbiAgdGhpcy52YWx1ZSA9IHRoaXMubGF6eVxuICAgID8gdW5kZWZpbmVkXG4gICAgOiB0aGlzLmdldCgpO1xufTtcblxuLyoqXG4gKiBFdmFsdWF0ZSB0aGUgZ2V0dGVyLCBhbmQgcmUtY29sbGVjdCBkZXBlbmRlbmNpZXMuXG4gKi9cbldhdGNoZXIucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIGdldCAoKSB7XG4gIHB1c2hUYXJnZXQodGhpcyk7XG4gIHZhciB2YWx1ZSA9IHRoaXMuZ2V0dGVyLmNhbGwodGhpcy52bSwgdGhpcy52bSk7XG4gIC8vIFwidG91Y2hcIiBldmVyeSBwcm9wZXJ0eSBzbyB0aGV5IGFyZSBhbGwgdHJhY2tlZCBhc1xuICAvLyBkZXBlbmRlbmNpZXMgZm9yIGRlZXAgd2F0Y2hpbmdcbiAgaWYgKHRoaXMuZGVlcCkge1xuICAgIHRyYXZlcnNlKHZhbHVlKTtcbiAgfVxuICBwb3BUYXJnZXQoKTtcbiAgdGhpcy5jbGVhbnVwRGVwcygpO1xuICByZXR1cm4gdmFsdWVcbn07XG5cbi8qKlxuICogQWRkIGEgZGVwZW5kZW5jeSB0byB0aGlzIGRpcmVjdGl2ZS5cbiAqL1xuV2F0Y2hlci5wcm90b3R5cGUuYWRkRGVwID0gZnVuY3Rpb24gYWRkRGVwIChkZXApIHtcbiAgdmFyIGlkID0gZGVwLmlkO1xuICBpZiAoIXRoaXMubmV3RGVwSWRzLmhhcyhpZCkpIHtcbiAgICB0aGlzLm5ld0RlcElkcy5hZGQoaWQpO1xuICAgIHRoaXMubmV3RGVwcy5wdXNoKGRlcCk7XG4gICAgaWYgKCF0aGlzLmRlcElkcy5oYXMoaWQpKSB7XG4gICAgICBkZXAuYWRkU3ViKHRoaXMpO1xuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBDbGVhbiB1cCBmb3IgZGVwZW5kZW5jeSBjb2xsZWN0aW9uLlxuICovXG5XYXRjaGVyLnByb3RvdHlwZS5jbGVhbnVwRGVwcyA9IGZ1bmN0aW9uIGNsZWFudXBEZXBzICgpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICB2YXIgaSA9IHRoaXMuZGVwcy5sZW5ndGg7XG4gIHdoaWxlIChpLS0pIHtcbiAgICB2YXIgZGVwID0gdGhpcyQxLmRlcHNbaV07XG4gICAgaWYgKCF0aGlzJDEubmV3RGVwSWRzLmhhcyhkZXAuaWQpKSB7XG4gICAgICBkZXAucmVtb3ZlU3ViKHRoaXMkMSk7XG4gICAgfVxuICB9XG4gIHZhciB0bXAgPSB0aGlzLmRlcElkcztcbiAgdGhpcy5kZXBJZHMgPSB0aGlzLm5ld0RlcElkcztcbiAgdGhpcy5uZXdEZXBJZHMgPSB0bXA7XG4gIHRoaXMubmV3RGVwSWRzLmNsZWFyKCk7XG4gIHRtcCA9IHRoaXMuZGVwcztcbiAgdGhpcy5kZXBzID0gdGhpcy5uZXdEZXBzO1xuICB0aGlzLm5ld0RlcHMgPSB0bXA7XG4gIHRoaXMubmV3RGVwcy5sZW5ndGggPSAwO1xufTtcblxuLyoqXG4gKiBTdWJzY3JpYmVyIGludGVyZmFjZS5cbiAqIFdpbGwgYmUgY2FsbGVkIHdoZW4gYSBkZXBlbmRlbmN5IGNoYW5nZXMuXG4gKi9cbldhdGNoZXIucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIHVwZGF0ZSAoKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gIGlmICh0aGlzLmxhenkpIHtcbiAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcbiAgfSBlbHNlIGlmICh0aGlzLnN5bmMpIHtcbiAgICB0aGlzLnJ1bigpO1xuICB9IGVsc2Uge1xuICAgIHF1ZXVlV2F0Y2hlcih0aGlzKTtcbiAgfVxufTtcblxuLyoqXG4gKiBTY2hlZHVsZXIgam9iIGludGVyZmFjZS5cbiAqIFdpbGwgYmUgY2FsbGVkIGJ5IHRoZSBzY2hlZHVsZXIuXG4gKi9cbldhdGNoZXIucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uIHJ1biAoKSB7XG4gIGlmICh0aGlzLmFjdGl2ZSkge1xuICAgIHZhciB2YWx1ZSA9IHRoaXMuZ2V0KCk7XG4gICAgICBpZiAoXG4gICAgICAgIHZhbHVlICE9PSB0aGlzLnZhbHVlIHx8XG4gICAgICAvLyBEZWVwIHdhdGNoZXJzIGFuZCB3YXRjaGVycyBvbiBPYmplY3QvQXJyYXlzIHNob3VsZCBmaXJlIGV2ZW5cbiAgICAgIC8vIHdoZW4gdGhlIHZhbHVlIGlzIHRoZSBzYW1lLCBiZWNhdXNlIHRoZSB2YWx1ZSBtYXlcbiAgICAgIC8vIGhhdmUgbXV0YXRlZC5cbiAgICAgIGlzT2JqZWN0KHZhbHVlKSB8fFxuICAgICAgdGhpcy5kZWVwXG4gICAgKSB7XG4gICAgICAvLyBzZXQgbmV3IHZhbHVlXG4gICAgICB2YXIgb2xkVmFsdWUgPSB0aGlzLnZhbHVlO1xuICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgaWYgKHRoaXMudXNlcikge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHRoaXMuY2IuY2FsbCh0aGlzLnZtLCB2YWx1ZSwgb2xkVmFsdWUpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxuICAgICAgICAgICAgKFwiRXJyb3IgaW4gd2F0Y2hlciBcXFwiXCIgKyAodGhpcy5leHByZXNzaW9uKSArIFwiXFxcIlwiKSxcbiAgICAgICAgICAgIHRoaXMudm1cbiAgICAgICAgICApO1xuICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgICAgICAgaWYgKGNvbmZpZy5lcnJvckhhbmRsZXIpIHtcbiAgICAgICAgICAgIGNvbmZpZy5lcnJvckhhbmRsZXIuY2FsbChudWxsLCBlLCB0aGlzLnZtKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgZVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5jYi5jYWxsKHRoaXMudm0sIHZhbHVlLCBvbGRWYWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIEV2YWx1YXRlIHRoZSB2YWx1ZSBvZiB0aGUgd2F0Y2hlci5cbiAqIFRoaXMgb25seSBnZXRzIGNhbGxlZCBmb3IgbGF6eSB3YXRjaGVycy5cbiAqL1xuV2F0Y2hlci5wcm90b3R5cGUuZXZhbHVhdGUgPSBmdW5jdGlvbiBldmFsdWF0ZSAoKSB7XG4gIHRoaXMudmFsdWUgPSB0aGlzLmdldCgpO1xuICB0aGlzLmRpcnR5ID0gZmFsc2U7XG59O1xuXG4vKipcbiAqIERlcGVuZCBvbiBhbGwgZGVwcyBjb2xsZWN0ZWQgYnkgdGhpcyB3YXRjaGVyLlxuICovXG5XYXRjaGVyLnByb3RvdHlwZS5kZXBlbmQgPSBmdW5jdGlvbiBkZXBlbmQgKCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIHZhciBpID0gdGhpcy5kZXBzLmxlbmd0aDtcbiAgd2hpbGUgKGktLSkge1xuICAgIHRoaXMkMS5kZXBzW2ldLmRlcGVuZCgpO1xuICB9XG59O1xuXG4vKipcbiAqIFJlbW92ZSBzZWxmIGZyb20gYWxsIGRlcGVuZGVuY2llcycgc3Vic2NyaWJlciBsaXN0LlxuICovXG5XYXRjaGVyLnByb3RvdHlwZS50ZWFyZG93biA9IGZ1bmN0aW9uIHRlYXJkb3duICgpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICBpZiAodGhpcy5hY3RpdmUpIHtcbiAgICAvLyByZW1vdmUgc2VsZiBmcm9tIHZtJ3Mgd2F0Y2hlciBsaXN0XG4gICAgLy8gdGhpcyBpcyBhIHNvbWV3aGF0IGV4cGVuc2l2ZSBvcGVyYXRpb24gc28gd2Ugc2tpcCBpdFxuICAgIC8vIGlmIHRoZSB2bSBpcyBiZWluZyBkZXN0cm95ZWQgb3IgaXMgcGVyZm9ybWluZyBhIHYtZm9yXG4gICAgLy8gcmUtcmVuZGVyICh0aGUgd2F0Y2hlciBsaXN0IGlzIHRoZW4gZmlsdGVyZWQgYnkgdi1mb3IpLlxuICAgIGlmICghdGhpcy52bS5faXNCZWluZ0Rlc3Ryb3llZCAmJiAhdGhpcy52bS5fdkZvclJlbW92aW5nKSB7XG4gICAgICByZW1vdmUkMSh0aGlzLnZtLl93YXRjaGVycywgdGhpcyk7XG4gICAgfVxuICAgIHZhciBpID0gdGhpcy5kZXBzLmxlbmd0aDtcbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICB0aGlzJDEuZGVwc1tpXS5yZW1vdmVTdWIodGhpcyQxKTtcbiAgICB9XG4gICAgdGhpcy5hY3RpdmUgPSBmYWxzZTtcbiAgfVxufTtcblxuLyoqXG4gKiBSZWN1cnNpdmVseSB0cmF2ZXJzZSBhbiBvYmplY3QgdG8gZXZva2UgYWxsIGNvbnZlcnRlZFxuICogZ2V0dGVycywgc28gdGhhdCBldmVyeSBuZXN0ZWQgcHJvcGVydHkgaW5zaWRlIHRoZSBvYmplY3RcbiAqIGlzIGNvbGxlY3RlZCBhcyBhIFwiZGVlcFwiIGRlcGVuZGVuY3kuXG4gKi9cbnZhciBzZWVuT2JqZWN0cyA9IG5ldyBfU2V0KCk7XG5mdW5jdGlvbiB0cmF2ZXJzZSAodmFsKSB7XG4gIHNlZW5PYmplY3RzLmNsZWFyKCk7XG4gIF90cmF2ZXJzZSh2YWwsIHNlZW5PYmplY3RzKTtcbn1cblxuZnVuY3Rpb24gX3RyYXZlcnNlICh2YWwsIHNlZW4pIHtcbiAgdmFyIGksIGtleXM7XG4gIHZhciBpc0EgPSBBcnJheS5pc0FycmF5KHZhbCk7XG4gIGlmICgoIWlzQSAmJiAhaXNPYmplY3QodmFsKSkgfHwgIU9iamVjdC5pc0V4dGVuc2libGUodmFsKSkge1xuICAgIHJldHVyblxuICB9XG4gIGlmICh2YWwuX19vYl9fKSB7XG4gICAgdmFyIGRlcElkID0gdmFsLl9fb2JfXy5kZXAuaWQ7XG4gICAgaWYgKHNlZW4uaGFzKGRlcElkKSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIHNlZW4uYWRkKGRlcElkKTtcbiAgfVxuICBpZiAoaXNBKSB7XG4gICAgaSA9IHZhbC5sZW5ndGg7XG4gICAgd2hpbGUgKGktLSkgeyBfdHJhdmVyc2UodmFsW2ldLCBzZWVuKTsgfVxuICB9IGVsc2Uge1xuICAgIGtleXMgPSBPYmplY3Qua2V5cyh2YWwpO1xuICAgIGkgPSBrZXlzLmxlbmd0aDtcbiAgICB3aGlsZSAoaS0tKSB7IF90cmF2ZXJzZSh2YWxba2V5c1tpXV0sIHNlZW4pOyB9XG4gIH1cbn1cblxuLypcbiAqIG5vdCB0eXBlIGNoZWNraW5nIHRoaXMgZmlsZSBiZWNhdXNlIGZsb3cgZG9lc24ndCBwbGF5IHdlbGwgd2l0aFxuICogZHluYW1pY2FsbHkgYWNjZXNzaW5nIG1ldGhvZHMgb24gQXJyYXkgcHJvdG90eXBlXG4gKi9cblxudmFyIGFycmF5UHJvdG8gPSBBcnJheS5wcm90b3R5cGU7XG52YXIgYXJyYXlNZXRob2RzID0gT2JqZWN0LmNyZWF0ZShhcnJheVByb3RvKTtbXG4gICdwdXNoJyxcbiAgJ3BvcCcsXG4gICdzaGlmdCcsXG4gICd1bnNoaWZ0JyxcbiAgJ3NwbGljZScsXG4gICdzb3J0JyxcbiAgJ3JldmVyc2UnXG5dXG4uZm9yRWFjaChmdW5jdGlvbiAobWV0aG9kKSB7XG4gIC8vIGNhY2hlIG9yaWdpbmFsIG1ldGhvZFxuICB2YXIgb3JpZ2luYWwgPSBhcnJheVByb3RvW21ldGhvZF07XG4gIGRlZihhcnJheU1ldGhvZHMsIG1ldGhvZCwgZnVuY3Rpb24gbXV0YXRvciAoKSB7XG4gICAgdmFyIGFyZ3VtZW50cyQxID0gYXJndW1lbnRzO1xuXG4gICAgLy8gYXZvaWQgbGVha2luZyBhcmd1bWVudHM6XG4gICAgLy8gaHR0cDovL2pzcGVyZi5jb20vY2xvc3VyZS13aXRoLWFyZ3VtZW50c1xuICAgIHZhciBpID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShpKTtcbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICBhcmdzW2ldID0gYXJndW1lbnRzJDFbaV07XG4gICAgfVxuICAgIHZhciByZXN1bHQgPSBvcmlnaW5hbC5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICB2YXIgb2IgPSB0aGlzLl9fb2JfXztcbiAgICB2YXIgaW5zZXJ0ZWQ7XG4gICAgc3dpdGNoIChtZXRob2QpIHtcbiAgICAgIGNhc2UgJ3B1c2gnOlxuICAgICAgICBpbnNlcnRlZCA9IGFyZ3M7XG4gICAgICAgIGJyZWFrXG4gICAgICBjYXNlICd1bnNoaWZ0JzpcbiAgICAgICAgaW5zZXJ0ZWQgPSBhcmdzO1xuICAgICAgICBicmVha1xuICAgICAgY2FzZSAnc3BsaWNlJzpcbiAgICAgICAgaW5zZXJ0ZWQgPSBhcmdzLnNsaWNlKDIpO1xuICAgICAgICBicmVha1xuICAgIH1cbiAgICBpZiAoaW5zZXJ0ZWQpIHsgb2Iub2JzZXJ2ZUFycmF5KGluc2VydGVkKTsgfVxuICAgIC8vIG5vdGlmeSBjaGFuZ2VcbiAgICBvYi5kZXAubm90aWZ5KCk7XG4gICAgcmV0dXJuIHJlc3VsdFxuICB9KTtcbn0pO1xuXG4vKiAgKi9cblxudmFyIGFycmF5S2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKGFycmF5TWV0aG9kcyk7XG5cbi8qKlxuICogQnkgZGVmYXVsdCwgd2hlbiBhIHJlYWN0aXZlIHByb3BlcnR5IGlzIHNldCwgdGhlIG5ldyB2YWx1ZSBpc1xuICogYWxzbyBjb252ZXJ0ZWQgdG8gYmVjb21lIHJlYWN0aXZlLiBIb3dldmVyIHdoZW4gcGFzc2luZyBkb3duIHByb3BzLFxuICogd2UgZG9uJ3Qgd2FudCB0byBmb3JjZSBjb252ZXJzaW9uIGJlY2F1c2UgdGhlIHZhbHVlIG1heSBiZSBhIG5lc3RlZCB2YWx1ZVxuICogdW5kZXIgYSBmcm96ZW4gZGF0YSBzdHJ1Y3R1cmUuIENvbnZlcnRpbmcgaXQgd291bGQgZGVmZWF0IHRoZSBvcHRpbWl6YXRpb24uXG4gKi9cbnZhciBvYnNlcnZlclN0YXRlID0ge1xuICBzaG91bGRDb252ZXJ0OiB0cnVlLFxuICBpc1NldHRpbmdQcm9wczogZmFsc2Vcbn07XG5cbi8qKlxuICogT2JzZXJ2ZXIgY2xhc3MgdGhhdCBhcmUgYXR0YWNoZWQgdG8gZWFjaCBvYnNlcnZlZFxuICogb2JqZWN0LiBPbmNlIGF0dGFjaGVkLCB0aGUgb2JzZXJ2ZXIgY29udmVydHMgdGFyZ2V0XG4gKiBvYmplY3QncyBwcm9wZXJ0eSBrZXlzIGludG8gZ2V0dGVyL3NldHRlcnMgdGhhdFxuICogY29sbGVjdCBkZXBlbmRlbmNpZXMgYW5kIGRpc3BhdGNoZXMgdXBkYXRlcy5cbiAqL1xudmFyIE9ic2VydmVyID0gZnVuY3Rpb24gT2JzZXJ2ZXIgKHZhbHVlKSB7XG4gIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgdGhpcy5kZXAgPSBuZXcgRGVwKCk7XG4gIHRoaXMudm1Db3VudCA9IDA7XG4gIGRlZih2YWx1ZSwgJ19fb2JfXycsIHRoaXMpO1xuICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICB2YXIgYXVnbWVudCA9IGhhc1Byb3RvXG4gICAgICA/IHByb3RvQXVnbWVudFxuICAgICAgOiBjb3B5QXVnbWVudDtcbiAgICBhdWdtZW50KHZhbHVlLCBhcnJheU1ldGhvZHMsIGFycmF5S2V5cyk7XG4gICAgdGhpcy5vYnNlcnZlQXJyYXkodmFsdWUpO1xuICB9IGVsc2Uge1xuICAgIHRoaXMud2Fsayh2YWx1ZSk7XG4gIH1cbn07XG5cbi8qKlxuICogV2FsayB0aHJvdWdoIGVhY2ggcHJvcGVydHkgYW5kIGNvbnZlcnQgdGhlbSBpbnRvXG4gKiBnZXR0ZXIvc2V0dGVycy4gVGhpcyBtZXRob2Qgc2hvdWxkIG9ubHkgYmUgY2FsbGVkIHdoZW5cbiAqIHZhbHVlIHR5cGUgaXMgT2JqZWN0LlxuICovXG5PYnNlcnZlci5wcm90b3R5cGUud2FsayA9IGZ1bmN0aW9uIHdhbGsgKG9iaikge1xuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iaik7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgIGRlZmluZVJlYWN0aXZlJCQxKG9iaiwga2V5c1tpXSwgb2JqW2tleXNbaV1dKTtcbiAgfVxufTtcblxuLyoqXG4gKiBPYnNlcnZlIGEgbGlzdCBvZiBBcnJheSBpdGVtcy5cbiAqL1xuT2JzZXJ2ZXIucHJvdG90eXBlLm9ic2VydmVBcnJheSA9IGZ1bmN0aW9uIG9ic2VydmVBcnJheSAoaXRlbXMpIHtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBpdGVtcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBvYnNlcnZlKGl0ZW1zW2ldKTtcbiAgfVxufTtcblxuLy8gaGVscGVyc1xuXG4vKipcbiAqIEF1Z21lbnQgYW4gdGFyZ2V0IE9iamVjdCBvciBBcnJheSBieSBpbnRlcmNlcHRpbmdcbiAqIHRoZSBwcm90b3R5cGUgY2hhaW4gdXNpbmcgX19wcm90b19fXG4gKi9cbmZ1bmN0aW9uIHByb3RvQXVnbWVudCAodGFyZ2V0LCBzcmMpIHtcbiAgLyogZXNsaW50LWRpc2FibGUgbm8tcHJvdG8gKi9cbiAgdGFyZ2V0Ll9fcHJvdG9fXyA9IHNyYztcbiAgLyogZXNsaW50LWVuYWJsZSBuby1wcm90byAqL1xufVxuXG4vKipcbiAqIEF1Z21lbnQgYW4gdGFyZ2V0IE9iamVjdCBvciBBcnJheSBieSBkZWZpbmluZ1xuICogaGlkZGVuIHByb3BlcnRpZXMuXG4gKlxuICogaXN0YW5idWwgaWdub3JlIG5leHRcbiAqL1xuZnVuY3Rpb24gY29weUF1Z21lbnQgKHRhcmdldCwgc3JjLCBrZXlzKSB7XG4gIGZvciAodmFyIGkgPSAwLCBsID0ga2V5cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICB2YXIga2V5ID0ga2V5c1tpXTtcbiAgICBkZWYodGFyZ2V0LCBrZXksIHNyY1trZXldKTtcbiAgfVxufVxuXG4vKipcbiAqIEF0dGVtcHQgdG8gY3JlYXRlIGFuIG9ic2VydmVyIGluc3RhbmNlIGZvciBhIHZhbHVlLFxuICogcmV0dXJucyB0aGUgbmV3IG9ic2VydmVyIGlmIHN1Y2Nlc3NmdWxseSBvYnNlcnZlZCxcbiAqIG9yIHRoZSBleGlzdGluZyBvYnNlcnZlciBpZiB0aGUgdmFsdWUgYWxyZWFkeSBoYXMgb25lLlxuICovXG5mdW5jdGlvbiBvYnNlcnZlICh2YWx1ZSkge1xuICBpZiAoIWlzT2JqZWN0KHZhbHVlKSkge1xuICAgIHJldHVyblxuICB9XG4gIHZhciBvYjtcbiAgaWYgKGhhc093bih2YWx1ZSwgJ19fb2JfXycpICYmIHZhbHVlLl9fb2JfXyBpbnN0YW5jZW9mIE9ic2VydmVyKSB7XG4gICAgb2IgPSB2YWx1ZS5fX29iX187XG4gIH0gZWxzZSBpZiAoXG4gICAgb2JzZXJ2ZXJTdGF0ZS5zaG91bGRDb252ZXJ0ICYmXG4gICAgIWNvbmZpZy5faXNTZXJ2ZXIgJiZcbiAgICAoQXJyYXkuaXNBcnJheSh2YWx1ZSkgfHwgaXNQbGFpbk9iamVjdCh2YWx1ZSkpICYmXG4gICAgT2JqZWN0LmlzRXh0ZW5zaWJsZSh2YWx1ZSkgJiZcbiAgICAhdmFsdWUuX2lzVnVlXG4gICkge1xuICAgIG9iID0gbmV3IE9ic2VydmVyKHZhbHVlKTtcbiAgfVxuICByZXR1cm4gb2Jcbn1cblxuLyoqXG4gKiBEZWZpbmUgYSByZWFjdGl2ZSBwcm9wZXJ0eSBvbiBhbiBPYmplY3QuXG4gKi9cbmZ1bmN0aW9uIGRlZmluZVJlYWN0aXZlJCQxIChcbiAgb2JqLFxuICBrZXksXG4gIHZhbCxcbiAgY3VzdG9tU2V0dGVyXG4pIHtcbiAgdmFyIGRlcCA9IG5ldyBEZXAoKTtcblxuICB2YXIgcHJvcGVydHkgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iaiwga2V5KTtcbiAgaWYgKHByb3BlcnR5ICYmIHByb3BlcnR5LmNvbmZpZ3VyYWJsZSA9PT0gZmFsc2UpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIC8vIGNhdGVyIGZvciBwcmUtZGVmaW5lZCBnZXR0ZXIvc2V0dGVyc1xuICB2YXIgZ2V0dGVyID0gcHJvcGVydHkgJiYgcHJvcGVydHkuZ2V0O1xuICB2YXIgc2V0dGVyID0gcHJvcGVydHkgJiYgcHJvcGVydHkuc2V0O1xuXG4gIHZhciBjaGlsZE9iID0gb2JzZXJ2ZSh2YWwpO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uIHJlYWN0aXZlR2V0dGVyICgpIHtcbiAgICAgIHZhciB2YWx1ZSA9IGdldHRlciA/IGdldHRlci5jYWxsKG9iaikgOiB2YWw7XG4gICAgICBpZiAoRGVwLnRhcmdldCkge1xuICAgICAgICBkZXAuZGVwZW5kKCk7XG4gICAgICAgIGlmIChjaGlsZE9iKSB7XG4gICAgICAgICAgY2hpbGRPYi5kZXAuZGVwZW5kKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgZGVwZW5kQXJyYXkodmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdmFsdWVcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gcmVhY3RpdmVTZXR0ZXIgKG5ld1ZhbCkge1xuICAgICAgdmFyIHZhbHVlID0gZ2V0dGVyID8gZ2V0dGVyLmNhbGwob2JqKSA6IHZhbDtcbiAgICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLXNlbGYtY29tcGFyZSAqL1xuICAgICAgaWYgKG5ld1ZhbCA9PT0gdmFsdWUgfHwgKG5ld1ZhbCAhPT0gbmV3VmFsICYmIHZhbHVlICE9PSB2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgICAvKiBlc2xpbnQtZW5hYmxlIG5vLXNlbGYtY29tcGFyZSAqL1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgY3VzdG9tU2V0dGVyKSB7XG4gICAgICAgIGN1c3RvbVNldHRlcigpO1xuICAgICAgfVxuICAgICAgaWYgKHNldHRlcikge1xuICAgICAgICBzZXR0ZXIuY2FsbChvYmosIG5ld1ZhbCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YWwgPSBuZXdWYWw7XG4gICAgICB9XG4gICAgICBjaGlsZE9iID0gb2JzZXJ2ZShuZXdWYWwpO1xuICAgICAgZGVwLm5vdGlmeSgpO1xuICAgIH1cbiAgfSk7XG59XG5cbi8qKlxuICogU2V0IGEgcHJvcGVydHkgb24gYW4gb2JqZWN0LiBBZGRzIHRoZSBuZXcgcHJvcGVydHkgYW5kXG4gKiB0cmlnZ2VycyBjaGFuZ2Ugbm90aWZpY2F0aW9uIGlmIHRoZSBwcm9wZXJ0eSBkb2Vzbid0XG4gKiBhbHJlYWR5IGV4aXN0LlxuICovXG5mdW5jdGlvbiBzZXQgKG9iaiwga2V5LCB2YWwpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkob2JqKSkge1xuICAgIG9iai5sZW5ndGggPSBNYXRoLm1heChvYmoubGVuZ3RoLCBrZXkpO1xuICAgIG9iai5zcGxpY2Uoa2V5LCAxLCB2YWwpO1xuICAgIHJldHVybiB2YWxcbiAgfVxuICBpZiAoaGFzT3duKG9iaiwga2V5KSkge1xuICAgIG9ialtrZXldID0gdmFsO1xuICAgIHJldHVyblxuICB9XG4gIHZhciBvYiA9IG9iai5fX29iX187XG4gIGlmIChvYmouX2lzVnVlIHx8IChvYiAmJiBvYi52bUNvdW50KSkge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcbiAgICAgICdBdm9pZCBhZGRpbmcgcmVhY3RpdmUgcHJvcGVydGllcyB0byBhIFZ1ZSBpbnN0YW5jZSBvciBpdHMgcm9vdCAkZGF0YSAnICtcbiAgICAgICdhdCBydW50aW1lIC0gZGVjbGFyZSBpdCB1cGZyb250IGluIHRoZSBkYXRhIG9wdGlvbi4nXG4gICAgKTtcbiAgICByZXR1cm5cbiAgfVxuICBpZiAoIW9iKSB7XG4gICAgb2JqW2tleV0gPSB2YWw7XG4gICAgcmV0dXJuXG4gIH1cbiAgZGVmaW5lUmVhY3RpdmUkJDEob2IudmFsdWUsIGtleSwgdmFsKTtcbiAgb2IuZGVwLm5vdGlmeSgpO1xuICByZXR1cm4gdmFsXG59XG5cbi8qKlxuICogRGVsZXRlIGEgcHJvcGVydHkgYW5kIHRyaWdnZXIgY2hhbmdlIGlmIG5lY2Vzc2FyeS5cbiAqL1xuZnVuY3Rpb24gZGVsIChvYmosIGtleSkge1xuICB2YXIgb2IgPSBvYmouX19vYl9fO1xuICBpZiAob2JqLl9pc1Z1ZSB8fCAob2IgJiYgb2Iudm1Db3VudCkpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXG4gICAgICAnQXZvaWQgZGVsZXRpbmcgcHJvcGVydGllcyBvbiBhIFZ1ZSBpbnN0YW5jZSBvciBpdHMgcm9vdCAkZGF0YSAnICtcbiAgICAgICctIGp1c3Qgc2V0IGl0IHRvIG51bGwuJ1xuICAgICk7XG4gICAgcmV0dXJuXG4gIH1cbiAgaWYgKCFoYXNPd24ob2JqLCBrZXkpKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgZGVsZXRlIG9ialtrZXldO1xuICBpZiAoIW9iKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgb2IuZGVwLm5vdGlmeSgpO1xufVxuXG4vKipcbiAqIENvbGxlY3QgZGVwZW5kZW5jaWVzIG9uIGFycmF5IGVsZW1lbnRzIHdoZW4gdGhlIGFycmF5IGlzIHRvdWNoZWQsIHNpbmNlXG4gKiB3ZSBjYW5ub3QgaW50ZXJjZXB0IGFycmF5IGVsZW1lbnQgYWNjZXNzIGxpa2UgcHJvcGVydHkgZ2V0dGVycy5cbiAqL1xuZnVuY3Rpb24gZGVwZW5kQXJyYXkgKHZhbHVlKSB7XG4gIGZvciAodmFyIGUgPSAodm9pZCAwKSwgaSA9IDAsIGwgPSB2YWx1ZS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBlID0gdmFsdWVbaV07XG4gICAgZSAmJiBlLl9fb2JfXyAmJiBlLl9fb2JfXy5kZXAuZGVwZW5kKCk7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZSkpIHtcbiAgICAgIGRlcGVuZEFycmF5KGUpO1xuICAgIH1cbiAgfVxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gaW5pdFN0YXRlICh2bSkge1xuICB2bS5fd2F0Y2hlcnMgPSBbXTtcbiAgaW5pdFByb3BzKHZtKTtcbiAgaW5pdERhdGEodm0pO1xuICBpbml0Q29tcHV0ZWQodm0pO1xuICBpbml0TWV0aG9kcyh2bSk7XG4gIGluaXRXYXRjaCh2bSk7XG59XG5cbnZhciBpc1Jlc2VydmVkUHJvcCA9IG1ha2VNYXAoJ2tleSxyZWYsc2xvdCcpO1xuXG5mdW5jdGlvbiBpbml0UHJvcHMgKHZtKSB7XG4gIHZhciBwcm9wcyA9IHZtLiRvcHRpb25zLnByb3BzO1xuICBpZiAocHJvcHMpIHtcbiAgICB2YXIgcHJvcHNEYXRhID0gdm0uJG9wdGlvbnMucHJvcHNEYXRhIHx8IHt9O1xuICAgIHZhciBrZXlzID0gdm0uJG9wdGlvbnMuX3Byb3BLZXlzID0gT2JqZWN0LmtleXMocHJvcHMpO1xuICAgIHZhciBpc1Jvb3QgPSAhdm0uJHBhcmVudDtcbiAgICAvLyByb290IGluc3RhbmNlIHByb3BzIHNob3VsZCBiZSBjb252ZXJ0ZWRcbiAgICBvYnNlcnZlclN0YXRlLnNob3VsZENvbnZlcnQgPSBpc1Jvb3Q7XG4gICAgdmFyIGxvb3AgPSBmdW5jdGlvbiAoIGkgKSB7XG4gICAgICB2YXIga2V5ID0ga2V5c1tpXTtcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBpZiAoaXNSZXNlcnZlZFByb3Aoa2V5KSkge1xuICAgICAgICAgIHdhcm4oXG4gICAgICAgICAgICAoXCJcXFwiXCIgKyBrZXkgKyBcIlxcXCIgaXMgYSByZXNlcnZlZCBhdHRyaWJ1dGUgYW5kIGNhbm5vdCBiZSB1c2VkIGFzIGNvbXBvbmVudCBwcm9wLlwiKSxcbiAgICAgICAgICAgIHZtXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBkZWZpbmVSZWFjdGl2ZSQkMSh2bSwga2V5LCB2YWxpZGF0ZVByb3Aoa2V5LCBwcm9wcywgcHJvcHNEYXRhLCB2bSksIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBpZiAodm0uJHBhcmVudCAmJiAhb2JzZXJ2ZXJTdGF0ZS5pc1NldHRpbmdQcm9wcykge1xuICAgICAgICAgICAgd2FybihcbiAgICAgICAgICAgICAgXCJBdm9pZCBtdXRhdGluZyBhIHByb3AgZGlyZWN0bHkgc2luY2UgdGhlIHZhbHVlIHdpbGwgYmUgXCIgK1xuICAgICAgICAgICAgICBcIm92ZXJ3cml0dGVuIHdoZW5ldmVyIHRoZSBwYXJlbnQgY29tcG9uZW50IHJlLXJlbmRlcnMuIFwiICtcbiAgICAgICAgICAgICAgXCJJbnN0ZWFkLCB1c2UgYSBkYXRhIG9yIGNvbXB1dGVkIHByb3BlcnR5IGJhc2VkIG9uIHRoZSBwcm9wJ3MgXCIgK1xuICAgICAgICAgICAgICBcInZhbHVlLiBQcm9wIGJlaW5nIG11dGF0ZWQ6IFxcXCJcIiArIGtleSArIFwiXFxcIlwiLFxuICAgICAgICAgICAgICB2bVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGVmaW5lUmVhY3RpdmUkJDEodm0sIGtleSwgdmFsaWRhdGVQcm9wKGtleSwgcHJvcHMsIHByb3BzRGF0YSwgdm0pKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSBsb29wKCBpICk7XG4gICAgb2JzZXJ2ZXJTdGF0ZS5zaG91bGRDb252ZXJ0ID0gdHJ1ZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpbml0RGF0YSAodm0pIHtcbiAgdmFyIGRhdGEgPSB2bS4kb3B0aW9ucy5kYXRhO1xuICBkYXRhID0gdm0uX2RhdGEgPSB0eXBlb2YgZGF0YSA9PT0gJ2Z1bmN0aW9uJ1xuICAgID8gZGF0YS5jYWxsKHZtKVxuICAgIDogZGF0YSB8fCB7fTtcbiAgaWYgKCFpc1BsYWluT2JqZWN0KGRhdGEpKSB7XG4gICAgZGF0YSA9IHt9O1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcbiAgICAgICdkYXRhIGZ1bmN0aW9ucyBzaG91bGQgcmV0dXJuIGFuIG9iamVjdC4nLFxuICAgICAgdm1cbiAgICApO1xuICB9XG4gIC8vIHByb3h5IGRhdGEgb24gaW5zdGFuY2VcbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhkYXRhKTtcbiAgdmFyIHByb3BzID0gdm0uJG9wdGlvbnMucHJvcHM7XG4gIHZhciBpID0ga2V5cy5sZW5ndGg7XG4gIHdoaWxlIChpLS0pIHtcbiAgICBpZiAocHJvcHMgJiYgaGFzT3duKHByb3BzLCBrZXlzW2ldKSkge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxuICAgICAgICBcIlRoZSBkYXRhIHByb3BlcnR5IFxcXCJcIiArIChrZXlzW2ldKSArIFwiXFxcIiBpcyBhbHJlYWR5IGRlY2xhcmVkIGFzIGEgcHJvcC4gXCIgK1xuICAgICAgICBcIlVzZSBwcm9wIGRlZmF1bHQgdmFsdWUgaW5zdGVhZC5cIixcbiAgICAgICAgdm1cbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHByb3h5KHZtLCBrZXlzW2ldKTtcbiAgICB9XG4gIH1cbiAgLy8gb2JzZXJ2ZSBkYXRhXG4gIG9ic2VydmUoZGF0YSk7XG4gIGRhdGEuX19vYl9fICYmIGRhdGEuX19vYl9fLnZtQ291bnQrKztcbn1cblxudmFyIGNvbXB1dGVkU2hhcmVkRGVmaW5pdGlvbiA9IHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgY29uZmlndXJhYmxlOiB0cnVlLFxuICBnZXQ6IG5vb3AsXG4gIHNldDogbm9vcFxufTtcblxuZnVuY3Rpb24gaW5pdENvbXB1dGVkICh2bSkge1xuICB2YXIgY29tcHV0ZWQgPSB2bS4kb3B0aW9ucy5jb21wdXRlZDtcbiAgaWYgKGNvbXB1dGVkKSB7XG4gICAgZm9yICh2YXIga2V5IGluIGNvbXB1dGVkKSB7XG4gICAgICB2YXIgdXNlckRlZiA9IGNvbXB1dGVkW2tleV07XG4gICAgICBpZiAodHlwZW9mIHVzZXJEZWYgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgY29tcHV0ZWRTaGFyZWREZWZpbml0aW9uLmdldCA9IG1ha2VDb21wdXRlZEdldHRlcih1c2VyRGVmLCB2bSk7XG4gICAgICAgIGNvbXB1dGVkU2hhcmVkRGVmaW5pdGlvbi5zZXQgPSBub29wO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29tcHV0ZWRTaGFyZWREZWZpbml0aW9uLmdldCA9IHVzZXJEZWYuZ2V0XG4gICAgICAgICAgPyB1c2VyRGVmLmNhY2hlICE9PSBmYWxzZVxuICAgICAgICAgICAgPyBtYWtlQ29tcHV0ZWRHZXR0ZXIodXNlckRlZi5nZXQsIHZtKVxuICAgICAgICAgICAgOiBiaW5kJDEodXNlckRlZi5nZXQsIHZtKVxuICAgICAgICAgIDogbm9vcDtcbiAgICAgICAgY29tcHV0ZWRTaGFyZWREZWZpbml0aW9uLnNldCA9IHVzZXJEZWYuc2V0XG4gICAgICAgICAgPyBiaW5kJDEodXNlckRlZi5zZXQsIHZtKVxuICAgICAgICAgIDogbm9vcDtcbiAgICAgIH1cbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh2bSwga2V5LCBjb21wdXRlZFNoYXJlZERlZmluaXRpb24pO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBtYWtlQ29tcHV0ZWRHZXR0ZXIgKGdldHRlciwgb3duZXIpIHtcbiAgdmFyIHdhdGNoZXIgPSBuZXcgV2F0Y2hlcihvd25lciwgZ2V0dGVyLCBub29wLCB7XG4gICAgbGF6eTogdHJ1ZVxuICB9KTtcbiAgcmV0dXJuIGZ1bmN0aW9uIGNvbXB1dGVkR2V0dGVyICgpIHtcbiAgICBpZiAod2F0Y2hlci5kaXJ0eSkge1xuICAgICAgd2F0Y2hlci5ldmFsdWF0ZSgpO1xuICAgIH1cbiAgICBpZiAoRGVwLnRhcmdldCkge1xuICAgICAgd2F0Y2hlci5kZXBlbmQoKTtcbiAgICB9XG4gICAgcmV0dXJuIHdhdGNoZXIudmFsdWVcbiAgfVxufVxuXG5mdW5jdGlvbiBpbml0TWV0aG9kcyAodm0pIHtcbiAgdmFyIG1ldGhvZHMgPSB2bS4kb3B0aW9ucy5tZXRob2RzO1xuICBpZiAobWV0aG9kcykge1xuICAgIGZvciAodmFyIGtleSBpbiBtZXRob2RzKSB7XG4gICAgICB2bVtrZXldID0gbWV0aG9kc1trZXldID09IG51bGwgPyBub29wIDogYmluZCQxKG1ldGhvZHNba2V5XSwgdm0pO1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgbWV0aG9kc1trZXldID09IG51bGwpIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICBcIm1ldGhvZCBcXFwiXCIgKyBrZXkgKyBcIlxcXCIgaGFzIGFuIHVuZGVmaW5lZCB2YWx1ZSBpbiB0aGUgY29tcG9uZW50IGRlZmluaXRpb24uIFwiICtcbiAgICAgICAgICBcIkRpZCB5b3UgcmVmZXJlbmNlIHRoZSBmdW5jdGlvbiBjb3JyZWN0bHk/XCIsXG4gICAgICAgICAgdm1cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gaW5pdFdhdGNoICh2bSkge1xuICB2YXIgd2F0Y2ggPSB2bS4kb3B0aW9ucy53YXRjaDtcbiAgaWYgKHdhdGNoKSB7XG4gICAgZm9yICh2YXIga2V5IGluIHdhdGNoKSB7XG4gICAgICB2YXIgaGFuZGxlciA9IHdhdGNoW2tleV07XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShoYW5kbGVyKSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGhhbmRsZXIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBjcmVhdGVXYXRjaGVyKHZtLCBrZXksIGhhbmRsZXJbaV0pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjcmVhdGVXYXRjaGVyKHZtLCBrZXksIGhhbmRsZXIpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjcmVhdGVXYXRjaGVyICh2bSwga2V5LCBoYW5kbGVyKSB7XG4gIHZhciBvcHRpb25zO1xuICBpZiAoaXNQbGFpbk9iamVjdChoYW5kbGVyKSkge1xuICAgIG9wdGlvbnMgPSBoYW5kbGVyO1xuICAgIGhhbmRsZXIgPSBoYW5kbGVyLmhhbmRsZXI7XG4gIH1cbiAgaWYgKHR5cGVvZiBoYW5kbGVyID09PSAnc3RyaW5nJykge1xuICAgIGhhbmRsZXIgPSB2bVtoYW5kbGVyXTtcbiAgfVxuICB2bS4kd2F0Y2goa2V5LCBoYW5kbGVyLCBvcHRpb25zKTtcbn1cblxuZnVuY3Rpb24gc3RhdGVNaXhpbiAoVnVlKSB7XG4gIC8vIGZsb3cgc29tZWhvdyBoYXMgcHJvYmxlbXMgd2l0aCBkaXJlY3RseSBkZWNsYXJlZCBkZWZpbml0aW9uIG9iamVjdFxuICAvLyB3aGVuIHVzaW5nIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSwgc28gd2UgaGF2ZSB0byBwcm9jZWR1cmFsbHkgYnVpbGQgdXBcbiAgLy8gdGhlIG9iamVjdCBoZXJlLlxuICB2YXIgZGF0YURlZiA9IHt9O1xuICBkYXRhRGVmLmdldCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5fZGF0YVxuICB9O1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGRhdGFEZWYuc2V0ID0gZnVuY3Rpb24gKG5ld0RhdGEpIHtcbiAgICAgIHdhcm4oXG4gICAgICAgICdBdm9pZCByZXBsYWNpbmcgaW5zdGFuY2Ugcm9vdCAkZGF0YS4gJyArXG4gICAgICAgICdVc2UgbmVzdGVkIGRhdGEgcHJvcGVydGllcyBpbnN0ZWFkLicsXG4gICAgICAgIHRoaXNcbiAgICAgICk7XG4gICAgfTtcbiAgfVxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVnVlLnByb3RvdHlwZSwgJyRkYXRhJywgZGF0YURlZik7XG5cbiAgVnVlLnByb3RvdHlwZS4kc2V0ID0gc2V0O1xuICBWdWUucHJvdG90eXBlLiRkZWxldGUgPSBkZWw7XG5cbiAgVnVlLnByb3RvdHlwZS4kd2F0Y2ggPSBmdW5jdGlvbiAoXG4gICAgZXhwT3JGbixcbiAgICBjYixcbiAgICBvcHRpb25zXG4gICkge1xuICAgIHZhciB2bSA9IHRoaXM7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgb3B0aW9ucy51c2VyID0gdHJ1ZTtcbiAgICB2YXIgd2F0Y2hlciA9IG5ldyBXYXRjaGVyKHZtLCBleHBPckZuLCBjYiwgb3B0aW9ucyk7XG4gICAgaWYgKG9wdGlvbnMuaW1tZWRpYXRlKSB7XG4gICAgICBjYi5jYWxsKHZtLCB3YXRjaGVyLnZhbHVlKTtcbiAgICB9XG4gICAgcmV0dXJuIGZ1bmN0aW9uIHVud2F0Y2hGbiAoKSB7XG4gICAgICB3YXRjaGVyLnRlYXJkb3duKCk7XG4gICAgfVxuICB9O1xufVxuXG5mdW5jdGlvbiBwcm94eSAodm0sIGtleSkge1xuICBpZiAoIWlzUmVzZXJ2ZWQoa2V5KSkge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh2bSwga2V5LCB7XG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgZ2V0OiBmdW5jdGlvbiBwcm94eUdldHRlciAoKSB7XG4gICAgICAgIHJldHVybiB2bS5fZGF0YVtrZXldXG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbiBwcm94eVNldHRlciAodmFsKSB7XG4gICAgICAgIHZtLl9kYXRhW2tleV0gPSB2YWw7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn1cblxuLyogICovXG5cbnZhciBWTm9kZSA9IGZ1bmN0aW9uIFZOb2RlIChcbiAgdGFnLFxuICBkYXRhLFxuICBjaGlsZHJlbixcbiAgdGV4dCxcbiAgZWxtLFxuICBucyxcbiAgY29udGV4dCxcbiAgY29tcG9uZW50T3B0aW9uc1xuKSB7XG4gIHRoaXMudGFnID0gdGFnO1xuICB0aGlzLmRhdGEgPSBkYXRhO1xuICB0aGlzLmNoaWxkcmVuID0gY2hpbGRyZW47XG4gIHRoaXMudGV4dCA9IHRleHQ7XG4gIHRoaXMuZWxtID0gZWxtO1xuICB0aGlzLm5zID0gbnM7XG4gIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gIHRoaXMuZnVuY3Rpb25hbENvbnRleHQgPSB1bmRlZmluZWQ7XG4gIHRoaXMua2V5ID0gZGF0YSAmJiBkYXRhLmtleTtcbiAgdGhpcy5jb21wb25lbnRPcHRpb25zID0gY29tcG9uZW50T3B0aW9ucztcbiAgdGhpcy5jaGlsZCA9IHVuZGVmaW5lZDtcbiAgdGhpcy5wYXJlbnQgPSB1bmRlZmluZWQ7XG4gIHRoaXMucmF3ID0gZmFsc2U7XG4gIHRoaXMuaXNTdGF0aWMgPSBmYWxzZTtcbiAgdGhpcy5pc1Jvb3RJbnNlcnQgPSB0cnVlO1xuICB0aGlzLmlzQ29tbWVudCA9IGZhbHNlO1xuICB0aGlzLmlzQ2xvbmVkID0gZmFsc2U7XG4gIHRoaXMuaXNPbmNlID0gZmFsc2U7XG59O1xuXG52YXIgZW1wdHlWTm9kZSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIG5vZGUgPSBuZXcgVk5vZGUoKTtcbiAgbm9kZS50ZXh0ID0gJyc7XG4gIG5vZGUuaXNDb21tZW50ID0gdHJ1ZTtcbiAgcmV0dXJuIG5vZGVcbn07XG5cbi8vIG9wdGltaXplZCBzaGFsbG93IGNsb25lXG4vLyB1c2VkIGZvciBzdGF0aWMgbm9kZXMgYW5kIHNsb3Qgbm9kZXMgYmVjYXVzZSB0aGV5IG1heSBiZSByZXVzZWQgYWNyb3NzXG4vLyBtdWx0aXBsZSByZW5kZXJzLCBjbG9uaW5nIHRoZW0gYXZvaWRzIGVycm9ycyB3aGVuIERPTSBtYW5pcHVsYXRpb25zIHJlbHlcbi8vIG9uIHRoZWlyIGVsbSByZWZlcmVuY2UuXG5mdW5jdGlvbiBjbG9uZVZOb2RlICh2bm9kZSkge1xuICB2YXIgY2xvbmVkID0gbmV3IFZOb2RlKFxuICAgIHZub2RlLnRhZyxcbiAgICB2bm9kZS5kYXRhLFxuICAgIHZub2RlLmNoaWxkcmVuLFxuICAgIHZub2RlLnRleHQsXG4gICAgdm5vZGUuZWxtLFxuICAgIHZub2RlLm5zLFxuICAgIHZub2RlLmNvbnRleHQsXG4gICAgdm5vZGUuY29tcG9uZW50T3B0aW9uc1xuICApO1xuICBjbG9uZWQuaXNTdGF0aWMgPSB2bm9kZS5pc1N0YXRpYztcbiAgY2xvbmVkLmtleSA9IHZub2RlLmtleTtcbiAgY2xvbmVkLmlzQ2xvbmVkID0gdHJ1ZTtcbiAgcmV0dXJuIGNsb25lZFxufVxuXG5mdW5jdGlvbiBjbG9uZVZOb2RlcyAodm5vZGVzKSB7XG4gIHZhciByZXMgPSBuZXcgQXJyYXkodm5vZGVzLmxlbmd0aCk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdm5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgcmVzW2ldID0gY2xvbmVWTm9kZSh2bm9kZXNbaV0pO1xuICB9XG4gIHJldHVybiByZXNcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIG1lcmdlVk5vZGVIb29rIChkZWYsIGhvb2tLZXksIGhvb2ssIGtleSkge1xuICBrZXkgPSBrZXkgKyBob29rS2V5O1xuICB2YXIgaW5qZWN0ZWRIYXNoID0gZGVmLl9faW5qZWN0ZWQgfHwgKGRlZi5fX2luamVjdGVkID0ge30pO1xuICBpZiAoIWluamVjdGVkSGFzaFtrZXldKSB7XG4gICAgaW5qZWN0ZWRIYXNoW2tleV0gPSB0cnVlO1xuICAgIHZhciBvbGRIb29rID0gZGVmW2hvb2tLZXldO1xuICAgIGlmIChvbGRIb29rKSB7XG4gICAgICBkZWZbaG9va0tleV0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIG9sZEhvb2suYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgaG9vay5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGVmW2hvb2tLZXldID0gaG9vaztcbiAgICB9XG4gIH1cbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIHVwZGF0ZUxpc3RlbmVycyAoXG4gIG9uLFxuICBvbGRPbixcbiAgYWRkLFxuICByZW1vdmUkJDEsXG4gIHZtXG4pIHtcbiAgdmFyIG5hbWUsIGN1ciwgb2xkLCBmbiwgZXZlbnQsIGNhcHR1cmU7XG4gIGZvciAobmFtZSBpbiBvbikge1xuICAgIGN1ciA9IG9uW25hbWVdO1xuICAgIG9sZCA9IG9sZE9uW25hbWVdO1xuICAgIGlmICghY3VyKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXG4gICAgICAgIFwiSW52YWxpZCBoYW5kbGVyIGZvciBldmVudCBcXFwiXCIgKyBuYW1lICsgXCJcXFwiOiBnb3QgXCIgKyBTdHJpbmcoY3VyKSxcbiAgICAgICAgdm1cbiAgICAgICk7XG4gICAgfSBlbHNlIGlmICghb2xkKSB7XG4gICAgICBjYXB0dXJlID0gbmFtZS5jaGFyQXQoMCkgPT09ICchJztcbiAgICAgIGV2ZW50ID0gY2FwdHVyZSA/IG5hbWUuc2xpY2UoMSkgOiBuYW1lO1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoY3VyKSkge1xuICAgICAgICBhZGQoZXZlbnQsIChjdXIuaW52b2tlciA9IGFyckludm9rZXIoY3VyKSksIGNhcHR1cmUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKCFjdXIuaW52b2tlcikge1xuICAgICAgICAgIGZuID0gY3VyO1xuICAgICAgICAgIGN1ciA9IG9uW25hbWVdID0ge307XG4gICAgICAgICAgY3VyLmZuID0gZm47XG4gICAgICAgICAgY3VyLmludm9rZXIgPSBmbkludm9rZXIoY3VyKTtcbiAgICAgICAgfVxuICAgICAgICBhZGQoZXZlbnQsIGN1ci5pbnZva2VyLCBjYXB0dXJlKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGN1ciAhPT0gb2xkKSB7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShvbGQpKSB7XG4gICAgICAgIG9sZC5sZW5ndGggPSBjdXIubGVuZ3RoO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9sZC5sZW5ndGg7IGkrKykgeyBvbGRbaV0gPSBjdXJbaV07IH1cbiAgICAgICAgb25bbmFtZV0gPSBvbGQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvbGQuZm4gPSBjdXI7XG4gICAgICAgIG9uW25hbWVdID0gb2xkO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBmb3IgKG5hbWUgaW4gb2xkT24pIHtcbiAgICBpZiAoIW9uW25hbWVdKSB7XG4gICAgICBldmVudCA9IG5hbWUuY2hhckF0KDApID09PSAnIScgPyBuYW1lLnNsaWNlKDEpIDogbmFtZTtcbiAgICAgIHJlbW92ZSQkMShldmVudCwgb2xkT25bbmFtZV0uaW52b2tlcik7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGFyckludm9rZXIgKGFycikge1xuICByZXR1cm4gZnVuY3Rpb24gKGV2KSB7XG4gICAgdmFyIGFyZ3VtZW50cyQxID0gYXJndW1lbnRzO1xuXG4gICAgdmFyIHNpbmdsZSA9IGFyZ3VtZW50cy5sZW5ndGggPT09IDE7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcbiAgICAgIHNpbmdsZSA/IGFycltpXShldikgOiBhcnJbaV0uYXBwbHkobnVsbCwgYXJndW1lbnRzJDEpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBmbkludm9rZXIgKG8pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChldikge1xuICAgIHZhciBzaW5nbGUgPSBhcmd1bWVudHMubGVuZ3RoID09PSAxO1xuICAgIHNpbmdsZSA/IG8uZm4oZXYpIDogby5mbi5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICB9XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBub3JtYWxpemVDaGlsZHJlbiAoXG4gIGNoaWxkcmVuLFxuICBucyxcbiAgbmVzdGVkSW5kZXhcbikge1xuICBpZiAoaXNQcmltaXRpdmUoY2hpbGRyZW4pKSB7XG4gICAgcmV0dXJuIFtjcmVhdGVUZXh0Vk5vZGUoY2hpbGRyZW4pXVxuICB9XG4gIGlmIChBcnJheS5pc0FycmF5KGNoaWxkcmVuKSkge1xuICAgIHZhciByZXMgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IGNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgdmFyIGMgPSBjaGlsZHJlbltpXTtcbiAgICAgIHZhciBsYXN0ID0gcmVzW3Jlcy5sZW5ndGggLSAxXTtcbiAgICAgIC8vICBuZXN0ZWRcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KGMpKSB7XG4gICAgICAgIHJlcy5wdXNoLmFwcGx5KHJlcywgbm9ybWFsaXplQ2hpbGRyZW4oYywgbnMsICgobmVzdGVkSW5kZXggfHwgJycpICsgXCJfXCIgKyBpKSkpO1xuICAgICAgfSBlbHNlIGlmIChpc1ByaW1pdGl2ZShjKSkge1xuICAgICAgICBpZiAobGFzdCAmJiBsYXN0LnRleHQpIHtcbiAgICAgICAgICBsYXN0LnRleHQgKz0gU3RyaW5nKGMpO1xuICAgICAgICB9IGVsc2UgaWYgKGMgIT09ICcnKSB7XG4gICAgICAgICAgLy8gY29udmVydCBwcmltaXRpdmUgdG8gdm5vZGVcbiAgICAgICAgICByZXMucHVzaChjcmVhdGVUZXh0Vk5vZGUoYykpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGMgaW5zdGFuY2VvZiBWTm9kZSkge1xuICAgICAgICBpZiAoYy50ZXh0ICYmIGxhc3QgJiYgbGFzdC50ZXh0KSB7XG4gICAgICAgICAgaWYgKCFsYXN0LmlzQ2xvbmVkKSB7XG4gICAgICAgICAgICBsYXN0LnRleHQgKz0gYy50ZXh0O1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBpbmhlcml0IHBhcmVudCBuYW1lc3BhY2VcbiAgICAgICAgICBpZiAobnMpIHtcbiAgICAgICAgICAgIGFwcGx5TlMoYywgbnMpO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBkZWZhdWx0IGtleSBmb3IgbmVzdGVkIGFycmF5IGNoaWxkcmVuIChsaWtlbHkgZ2VuZXJhdGVkIGJ5IHYtZm9yKVxuICAgICAgICAgIGlmIChjLnRhZyAmJiBjLmtleSA9PSBudWxsICYmIG5lc3RlZEluZGV4ICE9IG51bGwpIHtcbiAgICAgICAgICAgIGMua2V5ID0gXCJfX3ZsaXN0XCIgKyBuZXN0ZWRJbmRleCArIFwiX1wiICsgaSArIFwiX19cIjtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmVzLnB1c2goYyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc1xuICB9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVRleHRWTm9kZSAodmFsKSB7XG4gIHJldHVybiBuZXcgVk5vZGUodW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgU3RyaW5nKHZhbCkpXG59XG5cbmZ1bmN0aW9uIGFwcGx5TlMgKHZub2RlLCBucykge1xuICBpZiAodm5vZGUudGFnICYmICF2bm9kZS5ucykge1xuICAgIHZub2RlLm5zID0gbnM7XG4gICAgaWYgKHZub2RlLmNoaWxkcmVuKSB7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbCA9IHZub2RlLmNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICBhcHBseU5TKHZub2RlLmNoaWxkcmVuW2ldLCBucyk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBnZXRGaXJzdENvbXBvbmVudENoaWxkIChjaGlsZHJlbikge1xuICByZXR1cm4gY2hpbGRyZW4gJiYgY2hpbGRyZW4uZmlsdGVyKGZ1bmN0aW9uIChjKSB7IHJldHVybiBjICYmIGMuY29tcG9uZW50T3B0aW9uczsgfSlbMF1cbn1cblxuLyogICovXG5cbnZhciBhY3RpdmVJbnN0YW5jZSA9IG51bGw7XG5cbmZ1bmN0aW9uIGluaXRMaWZlY3ljbGUgKHZtKSB7XG4gIHZhciBvcHRpb25zID0gdm0uJG9wdGlvbnM7XG5cbiAgLy8gbG9jYXRlIGZpcnN0IG5vbi1hYnN0cmFjdCBwYXJlbnRcbiAgdmFyIHBhcmVudCA9IG9wdGlvbnMucGFyZW50O1xuICBpZiAocGFyZW50ICYmICFvcHRpb25zLmFic3RyYWN0KSB7XG4gICAgd2hpbGUgKHBhcmVudC4kb3B0aW9ucy5hYnN0cmFjdCAmJiBwYXJlbnQuJHBhcmVudCkge1xuICAgICAgcGFyZW50ID0gcGFyZW50LiRwYXJlbnQ7XG4gICAgfVxuICAgIHBhcmVudC4kY2hpbGRyZW4ucHVzaCh2bSk7XG4gIH1cblxuICB2bS4kcGFyZW50ID0gcGFyZW50O1xuICB2bS4kcm9vdCA9IHBhcmVudCA/IHBhcmVudC4kcm9vdCA6IHZtO1xuXG4gIHZtLiRjaGlsZHJlbiA9IFtdO1xuICB2bS4kcmVmcyA9IHt9O1xuXG4gIHZtLl93YXRjaGVyID0gbnVsbDtcbiAgdm0uX2luYWN0aXZlID0gZmFsc2U7XG4gIHZtLl9pc01vdW50ZWQgPSBmYWxzZTtcbiAgdm0uX2lzRGVzdHJveWVkID0gZmFsc2U7XG4gIHZtLl9pc0JlaW5nRGVzdHJveWVkID0gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGxpZmVjeWNsZU1peGluIChWdWUpIHtcbiAgVnVlLnByb3RvdHlwZS5fbW91bnQgPSBmdW5jdGlvbiAoXG4gICAgZWwsXG4gICAgaHlkcmF0aW5nXG4gICkge1xuICAgIHZhciB2bSA9IHRoaXM7XG4gICAgdm0uJGVsID0gZWw7XG4gICAgaWYgKCF2bS4kb3B0aW9ucy5yZW5kZXIpIHtcbiAgICAgIHZtLiRvcHRpb25zLnJlbmRlciA9IGVtcHR5Vk5vZGU7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgaWYgKHZtLiRvcHRpb25zLnRlbXBsYXRlICYmIHZtLiRvcHRpb25zLnRlbXBsYXRlLmNoYXJBdCgwKSAhPT0gJyMnKSB7XG4gICAgICAgICAgd2FybihcbiAgICAgICAgICAgICdZb3UgYXJlIHVzaW5nIHRoZSBydW50aW1lLW9ubHkgYnVpbGQgb2YgVnVlIHdoZXJlIHRoZSB0ZW1wbGF0ZSAnICtcbiAgICAgICAgICAgICdvcHRpb24gaXMgbm90IGF2YWlsYWJsZS4gRWl0aGVyIHByZS1jb21waWxlIHRoZSB0ZW1wbGF0ZXMgaW50byAnICtcbiAgICAgICAgICAgICdyZW5kZXIgZnVuY3Rpb25zLCBvciB1c2UgdGhlIGNvbXBpbGVyLWluY2x1ZGVkIGJ1aWxkLicsXG4gICAgICAgICAgICB2bVxuICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgd2FybihcbiAgICAgICAgICAgICdGYWlsZWQgdG8gbW91bnQgY29tcG9uZW50OiB0ZW1wbGF0ZSBvciByZW5kZXIgZnVuY3Rpb24gbm90IGRlZmluZWQuJyxcbiAgICAgICAgICAgIHZtXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBjYWxsSG9vayh2bSwgJ2JlZm9yZU1vdW50Jyk7XG4gICAgdm0uX3dhdGNoZXIgPSBuZXcgV2F0Y2hlcih2bSwgZnVuY3Rpb24gKCkge1xuICAgICAgdm0uX3VwZGF0ZSh2bS5fcmVuZGVyKCksIGh5ZHJhdGluZyk7XG4gICAgfSwgbm9vcCk7XG4gICAgaHlkcmF0aW5nID0gZmFsc2U7XG4gICAgLy8gbWFudWFsbHkgbW91bnRlZCBpbnN0YW5jZSwgY2FsbCBtb3VudGVkIG9uIHNlbGZcbiAgICAvLyBtb3VudGVkIGlzIGNhbGxlZCBmb3IgcmVuZGVyLWNyZWF0ZWQgY2hpbGQgY29tcG9uZW50cyBpbiBpdHMgaW5zZXJ0ZWQgaG9va1xuICAgIGlmICh2bS4kdm5vZGUgPT0gbnVsbCkge1xuICAgICAgdm0uX2lzTW91bnRlZCA9IHRydWU7XG4gICAgICBjYWxsSG9vayh2bSwgJ21vdW50ZWQnKTtcbiAgICB9XG4gICAgcmV0dXJuIHZtXG4gIH07XG5cbiAgVnVlLnByb3RvdHlwZS5fdXBkYXRlID0gZnVuY3Rpb24gKHZub2RlLCBoeWRyYXRpbmcpIHtcbiAgICB2YXIgdm0gPSB0aGlzO1xuICAgIGlmICh2bS5faXNNb3VudGVkKSB7XG4gICAgICBjYWxsSG9vayh2bSwgJ2JlZm9yZVVwZGF0ZScpO1xuICAgIH1cbiAgICB2YXIgcHJldkVsID0gdm0uJGVsO1xuICAgIHZhciBwcmV2QWN0aXZlSW5zdGFuY2UgPSBhY3RpdmVJbnN0YW5jZTtcbiAgICBhY3RpdmVJbnN0YW5jZSA9IHZtO1xuICAgIHZhciBwcmV2Vm5vZGUgPSB2bS5fdm5vZGU7XG4gICAgdm0uX3Zub2RlID0gdm5vZGU7XG4gICAgaWYgKCFwcmV2Vm5vZGUpIHtcbiAgICAgIC8vIFZ1ZS5wcm90b3R5cGUuX19wYXRjaF9fIGlzIGluamVjdGVkIGluIGVudHJ5IHBvaW50c1xuICAgICAgLy8gYmFzZWQgb24gdGhlIHJlbmRlcmluZyBiYWNrZW5kIHVzZWQuXG4gICAgICB2bS4kZWwgPSB2bS5fX3BhdGNoX18odm0uJGVsLCB2bm9kZSwgaHlkcmF0aW5nKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdm0uJGVsID0gdm0uX19wYXRjaF9fKHByZXZWbm9kZSwgdm5vZGUpO1xuICAgIH1cbiAgICBhY3RpdmVJbnN0YW5jZSA9IHByZXZBY3RpdmVJbnN0YW5jZTtcbiAgICAvLyB1cGRhdGUgX192dWVfXyByZWZlcmVuY2VcbiAgICBpZiAocHJldkVsKSB7XG4gICAgICBwcmV2RWwuX192dWVfXyA9IG51bGw7XG4gICAgfVxuICAgIGlmICh2bS4kZWwpIHtcbiAgICAgIHZtLiRlbC5fX3Z1ZV9fID0gdm07XG4gICAgfVxuICAgIC8vIGlmIHBhcmVudCBpcyBhbiBIT0MsIHVwZGF0ZSBpdHMgJGVsIGFzIHdlbGxcbiAgICBpZiAodm0uJHZub2RlICYmIHZtLiRwYXJlbnQgJiYgdm0uJHZub2RlID09PSB2bS4kcGFyZW50Ll92bm9kZSkge1xuICAgICAgdm0uJHBhcmVudC4kZWwgPSB2bS4kZWw7XG4gICAgfVxuICAgIGlmICh2bS5faXNNb3VudGVkKSB7XG4gICAgICBjYWxsSG9vayh2bSwgJ3VwZGF0ZWQnKTtcbiAgICB9XG4gIH07XG5cbiAgVnVlLnByb3RvdHlwZS5fdXBkYXRlRnJvbVBhcmVudCA9IGZ1bmN0aW9uIChcbiAgICBwcm9wc0RhdGEsXG4gICAgbGlzdGVuZXJzLFxuICAgIHBhcmVudFZub2RlLFxuICAgIHJlbmRlckNoaWxkcmVuXG4gICkge1xuICAgIHZhciB2bSA9IHRoaXM7XG4gICAgdmFyIGhhc0NoaWxkcmVuID0gISEodm0uJG9wdGlvbnMuX3JlbmRlckNoaWxkcmVuIHx8IHJlbmRlckNoaWxkcmVuKTtcbiAgICB2bS4kb3B0aW9ucy5fcGFyZW50Vm5vZGUgPSBwYXJlbnRWbm9kZTtcbiAgICB2bS4kb3B0aW9ucy5fcmVuZGVyQ2hpbGRyZW4gPSByZW5kZXJDaGlsZHJlbjtcbiAgICAvLyB1cGRhdGUgcHJvcHNcbiAgICBpZiAocHJvcHNEYXRhICYmIHZtLiRvcHRpb25zLnByb3BzKSB7XG4gICAgICBvYnNlcnZlclN0YXRlLnNob3VsZENvbnZlcnQgPSBmYWxzZTtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIG9ic2VydmVyU3RhdGUuaXNTZXR0aW5nUHJvcHMgPSB0cnVlO1xuICAgICAgfVxuICAgICAgdmFyIHByb3BLZXlzID0gdm0uJG9wdGlvbnMuX3Byb3BLZXlzIHx8IFtdO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wS2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIga2V5ID0gcHJvcEtleXNbaV07XG4gICAgICAgIHZtW2tleV0gPSB2YWxpZGF0ZVByb3Aoa2V5LCB2bS4kb3B0aW9ucy5wcm9wcywgcHJvcHNEYXRhLCB2bSk7XG4gICAgICB9XG4gICAgICBvYnNlcnZlclN0YXRlLnNob3VsZENvbnZlcnQgPSB0cnVlO1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgb2JzZXJ2ZXJTdGF0ZS5pc1NldHRpbmdQcm9wcyA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgdm0uJG9wdGlvbnMucHJvcHNEYXRhID0gcHJvcHNEYXRhO1xuICAgIH1cbiAgICAvLyB1cGRhdGUgbGlzdGVuZXJzXG4gICAgaWYgKGxpc3RlbmVycykge1xuICAgICAgdmFyIG9sZExpc3RlbmVycyA9IHZtLiRvcHRpb25zLl9wYXJlbnRMaXN0ZW5lcnM7XG4gICAgICB2bS4kb3B0aW9ucy5fcGFyZW50TGlzdGVuZXJzID0gbGlzdGVuZXJzO1xuICAgICAgdm0uX3VwZGF0ZUxpc3RlbmVycyhsaXN0ZW5lcnMsIG9sZExpc3RlbmVycyk7XG4gICAgfVxuICAgIC8vIHJlc29sdmUgc2xvdHMgKyBmb3JjZSB1cGRhdGUgaWYgaGFzIGNoaWxkcmVuXG4gICAgaWYgKGhhc0NoaWxkcmVuKSB7XG4gICAgICB2bS4kc2xvdHMgPSByZXNvbHZlU2xvdHMocmVuZGVyQ2hpbGRyZW4sIHZtLl9yZW5kZXJDb250ZXh0KTtcbiAgICAgIHZtLiRmb3JjZVVwZGF0ZSgpO1xuICAgIH1cbiAgfTtcblxuICBWdWUucHJvdG90eXBlLiRmb3JjZVVwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdm0gPSB0aGlzO1xuICAgIGlmICh2bS5fd2F0Y2hlcikge1xuICAgICAgdm0uX3dhdGNoZXIudXBkYXRlKCk7XG4gICAgfVxuICB9O1xuXG4gIFZ1ZS5wcm90b3R5cGUuJGRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHZtID0gdGhpcztcbiAgICBpZiAodm0uX2lzQmVpbmdEZXN0cm95ZWQpIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICBjYWxsSG9vayh2bSwgJ2JlZm9yZURlc3Ryb3knKTtcbiAgICB2bS5faXNCZWluZ0Rlc3Ryb3llZCA9IHRydWU7XG4gICAgLy8gcmVtb3ZlIHNlbGYgZnJvbSBwYXJlbnRcbiAgICB2YXIgcGFyZW50ID0gdm0uJHBhcmVudDtcbiAgICBpZiAocGFyZW50ICYmICFwYXJlbnQuX2lzQmVpbmdEZXN0cm95ZWQgJiYgIXZtLiRvcHRpb25zLmFic3RyYWN0KSB7XG4gICAgICByZW1vdmUkMShwYXJlbnQuJGNoaWxkcmVuLCB2bSk7XG4gICAgfVxuICAgIC8vIHRlYXJkb3duIHdhdGNoZXJzXG4gICAgaWYgKHZtLl93YXRjaGVyKSB7XG4gICAgICB2bS5fd2F0Y2hlci50ZWFyZG93bigpO1xuICAgIH1cbiAgICB2YXIgaSA9IHZtLl93YXRjaGVycy5sZW5ndGg7XG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgdm0uX3dhdGNoZXJzW2ldLnRlYXJkb3duKCk7XG4gICAgfVxuICAgIC8vIHJlbW92ZSByZWZlcmVuY2UgZnJvbSBkYXRhIG9iXG4gICAgLy8gZnJvemVuIG9iamVjdCBtYXkgbm90IGhhdmUgb2JzZXJ2ZXIuXG4gICAgaWYgKHZtLl9kYXRhLl9fb2JfXykge1xuICAgICAgdm0uX2RhdGEuX19vYl9fLnZtQ291bnQtLTtcbiAgICB9XG4gICAgLy8gY2FsbCB0aGUgbGFzdCBob29rLi4uXG4gICAgdm0uX2lzRGVzdHJveWVkID0gdHJ1ZTtcbiAgICBjYWxsSG9vayh2bSwgJ2Rlc3Ryb3llZCcpO1xuICAgIC8vIHR1cm4gb2ZmIGFsbCBpbnN0YW5jZSBsaXN0ZW5lcnMuXG4gICAgdm0uJG9mZigpO1xuICAgIC8vIHJlbW92ZSBfX3Z1ZV9fIHJlZmVyZW5jZVxuICAgIGlmICh2bS4kZWwpIHtcbiAgICAgIHZtLiRlbC5fX3Z1ZV9fID0gbnVsbDtcbiAgICB9XG4gICAgLy8gaW52b2tlIGRlc3Ryb3kgaG9va3Mgb24gY3VycmVudCByZW5kZXJlZCB0cmVlXG4gICAgdm0uX19wYXRjaF9fKHZtLl92bm9kZSwgbnVsbCk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGNhbGxIb29rICh2bSwgaG9vaykge1xuICB2YXIgaGFuZGxlcnMgPSB2bS4kb3B0aW9uc1tob29rXTtcbiAgaWYgKGhhbmRsZXJzKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGogPSBoYW5kbGVycy5sZW5ndGg7IGkgPCBqOyBpKyspIHtcbiAgICAgIGhhbmRsZXJzW2ldLmNhbGwodm0pO1xuICAgIH1cbiAgfVxuICB2bS4kZW1pdCgnaG9vazonICsgaG9vayk7XG59XG5cbi8qICAqL1xuXG52YXIgaG9va3MgPSB7IGluaXQ6IGluaXQsIHByZXBhdGNoOiBwcmVwYXRjaCwgaW5zZXJ0OiBpbnNlcnQsIGRlc3Ryb3k6IGRlc3Ryb3kkMSB9O1xudmFyIGhvb2tzVG9NZXJnZSA9IE9iamVjdC5rZXlzKGhvb2tzKTtcblxuZnVuY3Rpb24gY3JlYXRlQ29tcG9uZW50IChcbiAgQ3RvcixcbiAgZGF0YSxcbiAgY29udGV4dCxcbiAgY2hpbGRyZW4sXG4gIHRhZ1xuKSB7XG4gIGlmICghQ3Rvcikge1xuICAgIHJldHVyblxuICB9XG5cbiAgdmFyIGJhc2VDdG9yID0gY29udGV4dC4kb3B0aW9ucy5fYmFzZTtcbiAgaWYgKGlzT2JqZWN0KEN0b3IpKSB7XG4gICAgQ3RvciA9IGJhc2VDdG9yLmV4dGVuZChDdG9yKTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgQ3RvciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICB3YXJuKChcIkludmFsaWQgQ29tcG9uZW50IGRlZmluaXRpb246IFwiICsgKFN0cmluZyhDdG9yKSkpLCBjb250ZXh0KTtcbiAgICB9XG4gICAgcmV0dXJuXG4gIH1cblxuICAvLyBhc3luYyBjb21wb25lbnRcbiAgaWYgKCFDdG9yLmNpZCkge1xuICAgIGlmIChDdG9yLnJlc29sdmVkKSB7XG4gICAgICBDdG9yID0gQ3Rvci5yZXNvbHZlZDtcbiAgICB9IGVsc2Uge1xuICAgICAgQ3RvciA9IHJlc29sdmVBc3luY0NvbXBvbmVudChDdG9yLCBiYXNlQ3RvciwgZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBpdCdzIG9rIHRvIHF1ZXVlIHRoaXMgb24gZXZlcnkgcmVuZGVyIGJlY2F1c2VcbiAgICAgICAgLy8gJGZvcmNlVXBkYXRlIGlzIGJ1ZmZlcmVkIGJ5IHRoZSBzY2hlZHVsZXIuXG4gICAgICAgIGNvbnRleHQuJGZvcmNlVXBkYXRlKCk7XG4gICAgICB9KTtcbiAgICAgIGlmICghQ3Rvcikge1xuICAgICAgICAvLyByZXR1cm4gbm90aGluZyBpZiB0aGlzIGlzIGluZGVlZCBhbiBhc3luYyBjb21wb25lbnRcbiAgICAgICAgLy8gd2FpdCBmb3IgdGhlIGNhbGxiYWNrIHRvIHRyaWdnZXIgcGFyZW50IHVwZGF0ZS5cbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gcmVzb2x2ZSBjb25zdHJ1Y3RvciBvcHRpb25zIGluIGNhc2UgZ2xvYmFsIG1peGlucyBhcmUgYXBwbGllZCBhZnRlclxuICAvLyBjb21wb25lbnQgY29uc3RydWN0b3IgY3JlYXRpb25cbiAgcmVzb2x2ZUNvbnN0cnVjdG9yT3B0aW9ucyhDdG9yKTtcblxuICBkYXRhID0gZGF0YSB8fCB7fTtcblxuICAvLyBleHRyYWN0IHByb3BzXG4gIHZhciBwcm9wc0RhdGEgPSBleHRyYWN0UHJvcHMoZGF0YSwgQ3Rvcik7XG5cbiAgLy8gZnVuY3Rpb25hbCBjb21wb25lbnRcbiAgaWYgKEN0b3Iub3B0aW9ucy5mdW5jdGlvbmFsKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUZ1bmN0aW9uYWxDb21wb25lbnQoQ3RvciwgcHJvcHNEYXRhLCBkYXRhLCBjb250ZXh0LCBjaGlsZHJlbilcbiAgfVxuXG4gIC8vIGV4dHJhY3QgbGlzdGVuZXJzLCBzaW5jZSB0aGVzZSBuZWVkcyB0byBiZSB0cmVhdGVkIGFzXG4gIC8vIGNoaWxkIGNvbXBvbmVudCBsaXN0ZW5lcnMgaW5zdGVhZCBvZiBET00gbGlzdGVuZXJzXG4gIHZhciBsaXN0ZW5lcnMgPSBkYXRhLm9uO1xuICAvLyByZXBsYWNlIHdpdGggbGlzdGVuZXJzIHdpdGggLm5hdGl2ZSBtb2RpZmllclxuICBkYXRhLm9uID0gZGF0YS5uYXRpdmVPbjtcblxuICBpZiAoQ3Rvci5vcHRpb25zLmFic3RyYWN0KSB7XG4gICAgLy8gYWJzdHJhY3QgY29tcG9uZW50cyBkbyBub3Qga2VlcCBhbnl0aGluZ1xuICAgIC8vIG90aGVyIHRoYW4gcHJvcHMgJiBsaXN0ZW5lcnNcbiAgICBkYXRhID0ge307XG4gIH1cblxuICAvLyBtZXJnZSBjb21wb25lbnQgbWFuYWdlbWVudCBob29rcyBvbnRvIHRoZSBwbGFjZWhvbGRlciBub2RlXG4gIG1lcmdlSG9va3MoZGF0YSk7XG5cbiAgLy8gcmV0dXJuIGEgcGxhY2Vob2xkZXIgdm5vZGVcbiAgdmFyIG5hbWUgPSBDdG9yLm9wdGlvbnMubmFtZSB8fCB0YWc7XG4gIHZhciB2bm9kZSA9IG5ldyBWTm9kZShcbiAgICAoXCJ2dWUtY29tcG9uZW50LVwiICsgKEN0b3IuY2lkKSArIChuYW1lID8gKFwiLVwiICsgbmFtZSkgOiAnJykpLFxuICAgIGRhdGEsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgY29udGV4dCxcbiAgICB7IEN0b3I6IEN0b3IsIHByb3BzRGF0YTogcHJvcHNEYXRhLCBsaXN0ZW5lcnM6IGxpc3RlbmVycywgdGFnOiB0YWcsIGNoaWxkcmVuOiBjaGlsZHJlbiB9XG4gICk7XG4gIHJldHVybiB2bm9kZVxufVxuXG5mdW5jdGlvbiBjcmVhdGVGdW5jdGlvbmFsQ29tcG9uZW50IChcbiAgQ3RvcixcbiAgcHJvcHNEYXRhLFxuICBkYXRhLFxuICBjb250ZXh0LFxuICBjaGlsZHJlblxuKSB7XG4gIHZhciBwcm9wcyA9IHt9O1xuICB2YXIgcHJvcE9wdGlvbnMgPSBDdG9yLm9wdGlvbnMucHJvcHM7XG4gIGlmIChwcm9wT3B0aW9ucykge1xuICAgIGZvciAodmFyIGtleSBpbiBwcm9wT3B0aW9ucykge1xuICAgICAgcHJvcHNba2V5XSA9IHZhbGlkYXRlUHJvcChrZXksIHByb3BPcHRpb25zLCBwcm9wc0RhdGEpO1xuICAgIH1cbiAgfVxuICB2YXIgdm5vZGUgPSBDdG9yLm9wdGlvbnMucmVuZGVyLmNhbGwoXG4gICAgbnVsbCxcbiAgICAvLyBlbnN1cmUgdGhlIGNyZWF0ZUVsZW1lbnQgZnVuY3Rpb24gaW4gZnVuY3Rpb25hbCBjb21wb25lbnRzXG4gICAgLy8gZ2V0cyBhIHVuaXF1ZSBjb250ZXh0IC0gdGhpcyBpcyBuZWNlc3NhcnkgZm9yIGNvcnJlY3QgbmFtZWQgc2xvdCBjaGVja1xuICAgIGJpbmQkMShjcmVhdGVFbGVtZW50LCB7IF9zZWxmOiBPYmplY3QuY3JlYXRlKGNvbnRleHQpIH0pLFxuICAgIHtcbiAgICAgIHByb3BzOiBwcm9wcyxcbiAgICAgIGRhdGE6IGRhdGEsXG4gICAgICBwYXJlbnQ6IGNvbnRleHQsXG4gICAgICBjaGlsZHJlbjogbm9ybWFsaXplQ2hpbGRyZW4oY2hpbGRyZW4pLFxuICAgICAgc2xvdHM6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHJlc29sdmVTbG90cyhjaGlsZHJlbiwgY29udGV4dCk7IH1cbiAgICB9XG4gICk7XG4gIGlmICh2bm9kZSBpbnN0YW5jZW9mIFZOb2RlKSB7XG4gICAgdm5vZGUuZnVuY3Rpb25hbENvbnRleHQgPSBjb250ZXh0O1xuICAgIGlmIChkYXRhLnNsb3QpIHtcbiAgICAgICh2bm9kZS5kYXRhIHx8ICh2bm9kZS5kYXRhID0ge30pKS5zbG90ID0gZGF0YS5zbG90O1xuICAgIH1cbiAgfVxuICByZXR1cm4gdm5vZGVcbn1cblxuZnVuY3Rpb24gY3JlYXRlQ29tcG9uZW50SW5zdGFuY2VGb3JWbm9kZSAoXG4gIHZub2RlLCAvLyB3ZSBrbm93IGl0J3MgTW91bnRlZENvbXBvbmVudFZOb2RlIGJ1dCBmbG93IGRvZXNuJ3RcbiAgcGFyZW50IC8vIGFjdGl2ZUluc3RhbmNlIGluIGxpZmVjeWNsZSBzdGF0ZVxuKSB7XG4gIHZhciB2bm9kZUNvbXBvbmVudE9wdGlvbnMgPSB2bm9kZS5jb21wb25lbnRPcHRpb25zO1xuICB2YXIgb3B0aW9ucyA9IHtcbiAgICBfaXNDb21wb25lbnQ6IHRydWUsXG4gICAgcGFyZW50OiBwYXJlbnQsXG4gICAgcHJvcHNEYXRhOiB2bm9kZUNvbXBvbmVudE9wdGlvbnMucHJvcHNEYXRhLFxuICAgIF9jb21wb25lbnRUYWc6IHZub2RlQ29tcG9uZW50T3B0aW9ucy50YWcsXG4gICAgX3BhcmVudFZub2RlOiB2bm9kZSxcbiAgICBfcGFyZW50TGlzdGVuZXJzOiB2bm9kZUNvbXBvbmVudE9wdGlvbnMubGlzdGVuZXJzLFxuICAgIF9yZW5kZXJDaGlsZHJlbjogdm5vZGVDb21wb25lbnRPcHRpb25zLmNoaWxkcmVuXG4gIH07XG4gIC8vIGNoZWNrIGlubGluZS10ZW1wbGF0ZSByZW5kZXIgZnVuY3Rpb25zXG4gIHZhciBpbmxpbmVUZW1wbGF0ZSA9IHZub2RlLmRhdGEuaW5saW5lVGVtcGxhdGU7XG4gIGlmIChpbmxpbmVUZW1wbGF0ZSkge1xuICAgIG9wdGlvbnMucmVuZGVyID0gaW5saW5lVGVtcGxhdGUucmVuZGVyO1xuICAgIG9wdGlvbnMuc3RhdGljUmVuZGVyRm5zID0gaW5saW5lVGVtcGxhdGUuc3RhdGljUmVuZGVyRm5zO1xuICB9XG4gIHJldHVybiBuZXcgdm5vZGVDb21wb25lbnRPcHRpb25zLkN0b3Iob3B0aW9ucylcbn1cblxuZnVuY3Rpb24gaW5pdCAodm5vZGUsIGh5ZHJhdGluZykge1xuICBpZiAoIXZub2RlLmNoaWxkIHx8IHZub2RlLmNoaWxkLl9pc0Rlc3Ryb3llZCkge1xuICAgIHZhciBjaGlsZCA9IHZub2RlLmNoaWxkID0gY3JlYXRlQ29tcG9uZW50SW5zdGFuY2VGb3JWbm9kZSh2bm9kZSwgYWN0aXZlSW5zdGFuY2UpO1xuICAgIGNoaWxkLiRtb3VudChoeWRyYXRpbmcgPyB2bm9kZS5lbG0gOiB1bmRlZmluZWQsIGh5ZHJhdGluZyk7XG4gIH0gZWxzZSBpZiAodm5vZGUuZGF0YS5rZWVwQWxpdmUpIHtcbiAgICAvLyBrZXB0LWFsaXZlIGNvbXBvbmVudHMsIHRyZWF0IGFzIGEgcGF0Y2hcbiAgICB2YXIgbW91bnRlZE5vZGUgPSB2bm9kZTsgLy8gd29yayBhcm91bmQgZmxvd1xuICAgIHByZXBhdGNoKG1vdW50ZWROb2RlLCBtb3VudGVkTm9kZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJlcGF0Y2ggKFxuICBvbGRWbm9kZSxcbiAgdm5vZGVcbikge1xuICB2YXIgb3B0aW9ucyA9IHZub2RlLmNvbXBvbmVudE9wdGlvbnM7XG4gIHZhciBjaGlsZCA9IHZub2RlLmNoaWxkID0gb2xkVm5vZGUuY2hpbGQ7XG4gIGNoaWxkLl91cGRhdGVGcm9tUGFyZW50KFxuICAgIG9wdGlvbnMucHJvcHNEYXRhLCAvLyB1cGRhdGVkIHByb3BzXG4gICAgb3B0aW9ucy5saXN0ZW5lcnMsIC8vIHVwZGF0ZWQgbGlzdGVuZXJzXG4gICAgdm5vZGUsIC8vIG5ldyBwYXJlbnQgdm5vZGVcbiAgICBvcHRpb25zLmNoaWxkcmVuIC8vIG5ldyBjaGlsZHJlblxuICApO1xufVxuXG5mdW5jdGlvbiBpbnNlcnQgKHZub2RlKSB7XG4gIGlmICghdm5vZGUuY2hpbGQuX2lzTW91bnRlZCkge1xuICAgIHZub2RlLmNoaWxkLl9pc01vdW50ZWQgPSB0cnVlO1xuICAgIGNhbGxIb29rKHZub2RlLmNoaWxkLCAnbW91bnRlZCcpO1xuICB9XG4gIGlmICh2bm9kZS5kYXRhLmtlZXBBbGl2ZSkge1xuICAgIHZub2RlLmNoaWxkLl9pbmFjdGl2ZSA9IGZhbHNlO1xuICAgIGNhbGxIb29rKHZub2RlLmNoaWxkLCAnYWN0aXZhdGVkJyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZGVzdHJveSQxICh2bm9kZSkge1xuICBpZiAoIXZub2RlLmNoaWxkLl9pc0Rlc3Ryb3llZCkge1xuICAgIGlmICghdm5vZGUuZGF0YS5rZWVwQWxpdmUpIHtcbiAgICAgIHZub2RlLmNoaWxkLiRkZXN0cm95KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZub2RlLmNoaWxkLl9pbmFjdGl2ZSA9IHRydWU7XG4gICAgICBjYWxsSG9vayh2bm9kZS5jaGlsZCwgJ2RlYWN0aXZhdGVkJyk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHJlc29sdmVBc3luY0NvbXBvbmVudCAoXG4gIGZhY3RvcnksXG4gIGJhc2VDdG9yLFxuICBjYlxuKSB7XG4gIGlmIChmYWN0b3J5LnJlcXVlc3RlZCkge1xuICAgIC8vIHBvb2wgY2FsbGJhY2tzXG4gICAgZmFjdG9yeS5wZW5kaW5nQ2FsbGJhY2tzLnB1c2goY2IpO1xuICB9IGVsc2Uge1xuICAgIGZhY3RvcnkucmVxdWVzdGVkID0gdHJ1ZTtcbiAgICB2YXIgY2JzID0gZmFjdG9yeS5wZW5kaW5nQ2FsbGJhY2tzID0gW2NiXTtcbiAgICB2YXIgc3luYyA9IHRydWU7XG5cbiAgICB2YXIgcmVzb2x2ZSA9IGZ1bmN0aW9uIChyZXMpIHtcbiAgICAgIGlmIChpc09iamVjdChyZXMpKSB7XG4gICAgICAgIHJlcyA9IGJhc2VDdG9yLmV4dGVuZChyZXMpO1xuICAgICAgfVxuICAgICAgLy8gY2FjaGUgcmVzb2x2ZWRcbiAgICAgIGZhY3RvcnkucmVzb2x2ZWQgPSByZXM7XG4gICAgICAvLyBpbnZva2UgY2FsbGJhY2tzIG9ubHkgaWYgdGhpcyBpcyBub3QgYSBzeW5jaHJvbm91cyByZXNvbHZlXG4gICAgICAvLyAoYXN5bmMgcmVzb2x2ZXMgYXJlIHNoaW1tZWQgYXMgc3luY2hyb25vdXMgZHVyaW5nIFNTUilcbiAgICAgIGlmICghc3luYykge1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGNicy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICBjYnNbaV0ocmVzKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgcmVqZWN0ID0gZnVuY3Rpb24gKHJlYXNvbikge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxuICAgICAgICBcIkZhaWxlZCB0byByZXNvbHZlIGFzeW5jIGNvbXBvbmVudDogXCIgKyAoU3RyaW5nKGZhY3RvcnkpKSArXG4gICAgICAgIChyZWFzb24gPyAoXCJcXG5SZWFzb246IFwiICsgcmVhc29uKSA6ICcnKVxuICAgICAgKTtcbiAgICB9O1xuXG4gICAgdmFyIHJlcyA9IGZhY3RvcnkocmVzb2x2ZSwgcmVqZWN0KTtcblxuICAgIC8vIGhhbmRsZSBwcm9taXNlXG4gICAgaWYgKHJlcyAmJiB0eXBlb2YgcmVzLnRoZW4gPT09ICdmdW5jdGlvbicgJiYgIWZhY3RvcnkucmVzb2x2ZWQpIHtcbiAgICAgIHJlcy50aGVuKHJlc29sdmUsIHJlamVjdCk7XG4gICAgfVxuXG4gICAgc3luYyA9IGZhbHNlO1xuICAgIC8vIHJldHVybiBpbiBjYXNlIHJlc29sdmVkIHN5bmNocm9ub3VzbHlcbiAgICByZXR1cm4gZmFjdG9yeS5yZXNvbHZlZFxuICB9XG59XG5cbmZ1bmN0aW9uIGV4dHJhY3RQcm9wcyAoZGF0YSwgQ3Rvcikge1xuICAvLyB3ZSBhcmUgb25seSBleHRyYWN0aW5nIHJhdyB2YWx1ZXMgaGVyZS5cbiAgLy8gdmFsaWRhdGlvbiBhbmQgZGVmYXVsdCB2YWx1ZXMgYXJlIGhhbmRsZWQgaW4gdGhlIGNoaWxkXG4gIC8vIGNvbXBvbmVudCBpdHNlbGYuXG4gIHZhciBwcm9wT3B0aW9ucyA9IEN0b3Iub3B0aW9ucy5wcm9wcztcbiAgaWYgKCFwcm9wT3B0aW9ucykge1xuICAgIHJldHVyblxuICB9XG4gIHZhciByZXMgPSB7fTtcbiAgdmFyIGF0dHJzID0gZGF0YS5hdHRycztcbiAgdmFyIHByb3BzID0gZGF0YS5wcm9wcztcbiAgdmFyIGRvbVByb3BzID0gZGF0YS5kb21Qcm9wcztcbiAgaWYgKGF0dHJzIHx8IHByb3BzIHx8IGRvbVByb3BzKSB7XG4gICAgZm9yICh2YXIga2V5IGluIHByb3BPcHRpb25zKSB7XG4gICAgICB2YXIgYWx0S2V5ID0gaHlwaGVuYXRlKGtleSk7XG4gICAgICBjaGVja1Byb3AocmVzLCBwcm9wcywga2V5LCBhbHRLZXksIHRydWUpIHx8XG4gICAgICBjaGVja1Byb3AocmVzLCBhdHRycywga2V5LCBhbHRLZXkpIHx8XG4gICAgICBjaGVja1Byb3AocmVzLCBkb21Qcm9wcywga2V5LCBhbHRLZXkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbmZ1bmN0aW9uIGNoZWNrUHJvcCAoXG4gIHJlcyxcbiAgaGFzaCxcbiAga2V5LFxuICBhbHRLZXksXG4gIHByZXNlcnZlXG4pIHtcbiAgaWYgKGhhc2gpIHtcbiAgICBpZiAoaGFzT3duKGhhc2gsIGtleSkpIHtcbiAgICAgIHJlc1trZXldID0gaGFzaFtrZXldO1xuICAgICAgaWYgKCFwcmVzZXJ2ZSkge1xuICAgICAgICBkZWxldGUgaGFzaFtrZXldO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWVcbiAgICB9IGVsc2UgaWYgKGhhc093bihoYXNoLCBhbHRLZXkpKSB7XG4gICAgICByZXNba2V5XSA9IGhhc2hbYWx0S2V5XTtcbiAgICAgIGlmICghcHJlc2VydmUpIHtcbiAgICAgICAgZGVsZXRlIGhhc2hbYWx0S2V5XTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZVxufVxuXG5mdW5jdGlvbiBtZXJnZUhvb2tzIChkYXRhKSB7XG4gIGlmICghZGF0YS5ob29rKSB7XG4gICAgZGF0YS5ob29rID0ge307XG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBob29rc1RvTWVyZ2UubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIga2V5ID0gaG9va3NUb01lcmdlW2ldO1xuICAgIHZhciBmcm9tUGFyZW50ID0gZGF0YS5ob29rW2tleV07XG4gICAgdmFyIG91cnMgPSBob29rc1trZXldO1xuICAgIGRhdGEuaG9va1trZXldID0gZnJvbVBhcmVudCA/IG1lcmdlSG9vayQxKG91cnMsIGZyb21QYXJlbnQpIDogb3VycztcbiAgfVxufVxuXG5mdW5jdGlvbiBtZXJnZUhvb2skMSAoYSwgYikge1xuICAvLyBzaW5jZSBhbGwgaG9va3MgaGF2ZSBhdCBtb3N0IHR3byBhcmdzLCB1c2UgZml4ZWQgYXJnc1xuICAvLyB0byBhdm9pZCBoYXZpbmcgdG8gdXNlIGZuLmFwcGx5KCkuXG4gIHJldHVybiBmdW5jdGlvbiAoXywgX18pIHtcbiAgICBhKF8sIF9fKTtcbiAgICBiKF8sIF9fKTtcbiAgfVxufVxuXG4vKiAgKi9cblxuLy8gd3JhcHBlciBmdW5jdGlvbiBmb3IgcHJvdmlkaW5nIGEgbW9yZSBmbGV4aWJsZSBpbnRlcmZhY2Vcbi8vIHdpdGhvdXQgZ2V0dGluZyB5ZWxsZWQgYXQgYnkgZmxvd1xuZnVuY3Rpb24gY3JlYXRlRWxlbWVudCAoXG4gIHRhZyxcbiAgZGF0YSxcbiAgY2hpbGRyZW5cbikge1xuICBpZiAoZGF0YSAmJiAoQXJyYXkuaXNBcnJheShkYXRhKSB8fCB0eXBlb2YgZGF0YSAhPT0gJ29iamVjdCcpKSB7XG4gICAgY2hpbGRyZW4gPSBkYXRhO1xuICAgIGRhdGEgPSB1bmRlZmluZWQ7XG4gIH1cbiAgLy8gbWFrZSBzdXJlIHRvIHVzZSByZWFsIGluc3RhbmNlIGluc3RlYWQgb2YgcHJveHkgYXMgY29udGV4dFxuICByZXR1cm4gX2NyZWF0ZUVsZW1lbnQodGhpcy5fc2VsZiwgdGFnLCBkYXRhLCBjaGlsZHJlbilcbn1cblxuZnVuY3Rpb24gX2NyZWF0ZUVsZW1lbnQgKFxuICBjb250ZXh0LFxuICB0YWcsXG4gIGRhdGEsXG4gIGNoaWxkcmVuXG4pIHtcbiAgaWYgKGRhdGEgJiYgZGF0YS5fX29iX18pIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXG4gICAgICBcIkF2b2lkIHVzaW5nIG9ic2VydmVkIGRhdGEgb2JqZWN0IGFzIHZub2RlIGRhdGE6IFwiICsgKEpTT04uc3RyaW5naWZ5KGRhdGEpKSArIFwiXFxuXCIgK1xuICAgICAgJ0Fsd2F5cyBjcmVhdGUgZnJlc2ggdm5vZGUgZGF0YSBvYmplY3RzIGluIGVhY2ggcmVuZGVyIScsXG4gICAgICBjb250ZXh0XG4gICAgKTtcbiAgICByZXR1cm5cbiAgfVxuICBpZiAoIXRhZykge1xuICAgIC8vIGluIGNhc2Ugb2YgY29tcG9uZW50IDppcyBzZXQgdG8gZmFsc3kgdmFsdWVcbiAgICByZXR1cm4gZW1wdHlWTm9kZSgpXG4gIH1cbiAgaWYgKHR5cGVvZiB0YWcgPT09ICdzdHJpbmcnKSB7XG4gICAgdmFyIEN0b3I7XG4gICAgdmFyIG5zID0gY29uZmlnLmdldFRhZ05hbWVzcGFjZSh0YWcpO1xuICAgIGlmIChjb25maWcuaXNSZXNlcnZlZFRhZyh0YWcpKSB7XG4gICAgICAvLyBwbGF0Zm9ybSBidWlsdC1pbiBlbGVtZW50c1xuICAgICAgcmV0dXJuIG5ldyBWTm9kZShcbiAgICAgICAgdGFnLCBkYXRhLCBub3JtYWxpemVDaGlsZHJlbihjaGlsZHJlbiwgbnMpLFxuICAgICAgICB1bmRlZmluZWQsIHVuZGVmaW5lZCwgbnMsIGNvbnRleHRcbiAgICAgIClcbiAgICB9IGVsc2UgaWYgKChDdG9yID0gcmVzb2x2ZUFzc2V0KGNvbnRleHQuJG9wdGlvbnMsICdjb21wb25lbnRzJywgdGFnKSkpIHtcbiAgICAgIC8vIGNvbXBvbmVudFxuICAgICAgcmV0dXJuIGNyZWF0ZUNvbXBvbmVudChDdG9yLCBkYXRhLCBjb250ZXh0LCBjaGlsZHJlbiwgdGFnKVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyB1bmtub3duIG9yIHVubGlzdGVkIG5hbWVzcGFjZWQgZWxlbWVudHNcbiAgICAgIC8vIGNoZWNrIGF0IHJ1bnRpbWUgYmVjYXVzZSBpdCBtYXkgZ2V0IGFzc2lnbmVkIGEgbmFtZXNwYWNlIHdoZW4gaXRzXG4gICAgICAvLyBwYXJlbnQgbm9ybWFsaXplcyBjaGlsZHJlblxuICAgICAgdmFyIGNoaWxkTnMgPSB0YWcgPT09ICdmb3JlaWduT2JqZWN0JyA/ICd4aHRtbCcgOiBucztcbiAgICAgIHJldHVybiBuZXcgVk5vZGUoXG4gICAgICAgIHRhZywgZGF0YSwgbm9ybWFsaXplQ2hpbGRyZW4oY2hpbGRyZW4sIGNoaWxkTnMpLFxuICAgICAgICB1bmRlZmluZWQsIHVuZGVmaW5lZCwgbnMsIGNvbnRleHRcbiAgICAgIClcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gZGlyZWN0IGNvbXBvbmVudCBvcHRpb25zIC8gY29uc3RydWN0b3JcbiAgICByZXR1cm4gY3JlYXRlQ29tcG9uZW50KHRhZywgZGF0YSwgY29udGV4dCwgY2hpbGRyZW4pXG4gIH1cbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGluaXRSZW5kZXIgKHZtKSB7XG4gIHZtLiR2bm9kZSA9IG51bGw7IC8vIHRoZSBwbGFjZWhvbGRlciBub2RlIGluIHBhcmVudCB0cmVlXG4gIHZtLl92bm9kZSA9IG51bGw7IC8vIHRoZSByb290IG9mIHRoZSBjaGlsZCB0cmVlXG4gIHZtLl9zdGF0aWNUcmVlcyA9IG51bGw7XG4gIHZtLl9yZW5kZXJDb250ZXh0ID0gdm0uJG9wdGlvbnMuX3BhcmVudFZub2RlICYmIHZtLiRvcHRpb25zLl9wYXJlbnRWbm9kZS5jb250ZXh0O1xuICB2bS4kc2xvdHMgPSByZXNvbHZlU2xvdHModm0uJG9wdGlvbnMuX3JlbmRlckNoaWxkcmVuLCB2bS5fcmVuZGVyQ29udGV4dCk7XG4gIC8vIGJpbmQgdGhlIHB1YmxpYyBjcmVhdGVFbGVtZW50IGZuIHRvIHRoaXMgaW5zdGFuY2VcbiAgLy8gc28gdGhhdCB3ZSBnZXQgcHJvcGVyIHJlbmRlciBjb250ZXh0IGluc2lkZSBpdC5cbiAgdm0uJGNyZWF0ZUVsZW1lbnQgPSBiaW5kJDEoY3JlYXRlRWxlbWVudCwgdm0pO1xuICBpZiAodm0uJG9wdGlvbnMuZWwpIHtcbiAgICB2bS4kbW91bnQodm0uJG9wdGlvbnMuZWwpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlbmRlck1peGluIChWdWUpIHtcbiAgVnVlLnByb3RvdHlwZS4kbmV4dFRpY2sgPSBmdW5jdGlvbiAoZm4pIHtcbiAgICBuZXh0VGljayhmbiwgdGhpcyk7XG4gIH07XG5cbiAgVnVlLnByb3RvdHlwZS5fcmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciB2bSA9IHRoaXM7XG4gICAgdmFyIHJlZiA9IHZtLiRvcHRpb25zO1xuICAgIHZhciByZW5kZXIgPSByZWYucmVuZGVyO1xuICAgIHZhciBzdGF0aWNSZW5kZXJGbnMgPSByZWYuc3RhdGljUmVuZGVyRm5zO1xuICAgIHZhciBfcGFyZW50Vm5vZGUgPSByZWYuX3BhcmVudFZub2RlO1xuXG4gICAgaWYgKHZtLl9pc01vdW50ZWQpIHtcbiAgICAgIC8vIGNsb25lIHNsb3Qgbm9kZXMgb24gcmUtcmVuZGVyc1xuICAgICAgZm9yICh2YXIga2V5IGluIHZtLiRzbG90cykge1xuICAgICAgICB2bS4kc2xvdHNba2V5XSA9IGNsb25lVk5vZGVzKHZtLiRzbG90c1trZXldKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoc3RhdGljUmVuZGVyRm5zICYmICF2bS5fc3RhdGljVHJlZXMpIHtcbiAgICAgIHZtLl9zdGF0aWNUcmVlcyA9IFtdO1xuICAgIH1cbiAgICAvLyBzZXQgcGFyZW50IHZub2RlLiB0aGlzIGFsbG93cyByZW5kZXIgZnVuY3Rpb25zIHRvIGhhdmUgYWNjZXNzXG4gICAgLy8gdG8gdGhlIGRhdGEgb24gdGhlIHBsYWNlaG9sZGVyIG5vZGUuXG4gICAgdm0uJHZub2RlID0gX3BhcmVudFZub2RlO1xuICAgIC8vIHJlbmRlciBzZWxmXG4gICAgdmFyIHZub2RlO1xuICAgIHRyeSB7XG4gICAgICB2bm9kZSA9IHJlbmRlci5jYWxsKHZtLl9yZW5kZXJQcm94eSwgdm0uJGNyZWF0ZUVsZW1lbnQpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIHdhcm4oKFwiRXJyb3Igd2hlbiByZW5kZXJpbmcgXCIgKyAoZm9ybWF0Q29tcG9uZW50TmFtZSh2bSkpICsgXCI6XCIpKTtcbiAgICAgIH1cbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgICBpZiAoY29uZmlnLmVycm9ySGFuZGxlcikge1xuICAgICAgICBjb25maWcuZXJyb3JIYW5kbGVyLmNhbGwobnVsbCwgZSwgdm0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGNvbmZpZy5faXNTZXJ2ZXIpIHtcbiAgICAgICAgICB0aHJvdyBlXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcihlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gcmV0dXJuIHByZXZpb3VzIHZub2RlIHRvIHByZXZlbnQgcmVuZGVyIGVycm9yIGNhdXNpbmcgYmxhbmsgY29tcG9uZW50XG4gICAgICB2bm9kZSA9IHZtLl92bm9kZTtcbiAgICB9XG4gICAgLy8gcmV0dXJuIGVtcHR5IHZub2RlIGluIGNhc2UgdGhlIHJlbmRlciBmdW5jdGlvbiBlcnJvcmVkIG91dFxuICAgIGlmICghKHZub2RlIGluc3RhbmNlb2YgVk5vZGUpKSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBBcnJheS5pc0FycmF5KHZub2RlKSkge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgICdNdWx0aXBsZSByb290IG5vZGVzIHJldHVybmVkIGZyb20gcmVuZGVyIGZ1bmN0aW9uLiBSZW5kZXIgZnVuY3Rpb24gJyArXG4gICAgICAgICAgJ3Nob3VsZCByZXR1cm4gYSBzaW5nbGUgcm9vdCBub2RlLicsXG4gICAgICAgICAgdm1cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHZub2RlID0gZW1wdHlWTm9kZSgpO1xuICAgIH1cbiAgICAvLyBzZXQgcGFyZW50XG4gICAgdm5vZGUucGFyZW50ID0gX3BhcmVudFZub2RlO1xuICAgIHJldHVybiB2bm9kZVxuICB9O1xuXG4gIC8vIHNob3J0aGFuZHMgdXNlZCBpbiByZW5kZXIgZnVuY3Rpb25zXG4gIFZ1ZS5wcm90b3R5cGUuX2ggPSBjcmVhdGVFbGVtZW50O1xuICAvLyB0b1N0cmluZyBmb3IgbXVzdGFjaGVzXG4gIFZ1ZS5wcm90b3R5cGUuX3MgPSBfdG9TdHJpbmc7XG4gIC8vIG51bWJlciBjb252ZXJzaW9uXG4gIFZ1ZS5wcm90b3R5cGUuX24gPSB0b051bWJlcjtcbiAgLy8gZW1wdHkgdm5vZGVcbiAgVnVlLnByb3RvdHlwZS5fZSA9IGVtcHR5Vk5vZGU7XG4gIC8vIGxvb3NlIGVxdWFsXG4gIFZ1ZS5wcm90b3R5cGUuX3EgPSBsb29zZUVxdWFsO1xuICAvLyBsb29zZSBpbmRleE9mXG4gIFZ1ZS5wcm90b3R5cGUuX2kgPSBsb29zZUluZGV4T2Y7XG5cbiAgLy8gcmVuZGVyIHN0YXRpYyB0cmVlIGJ5IGluZGV4XG4gIFZ1ZS5wcm90b3R5cGUuX20gPSBmdW5jdGlvbiByZW5kZXJTdGF0aWMgKFxuICAgIGluZGV4LFxuICAgIGlzSW5Gb3JcbiAgKSB7XG4gICAgdmFyIHRyZWUgPSB0aGlzLl9zdGF0aWNUcmVlc1tpbmRleF07XG4gICAgLy8gaWYgaGFzIGFscmVhZHktcmVuZGVyZWQgc3RhdGljIHRyZWUgYW5kIG5vdCBpbnNpZGUgdi1mb3IsXG4gICAgLy8gd2UgY2FuIHJldXNlIHRoZSBzYW1lIHRyZWUgYnkgZG9pbmcgYSBzaGFsbG93IGNsb25lLlxuICAgIGlmICh0cmVlICYmICFpc0luRm9yKSB7XG4gICAgICByZXR1cm4gQXJyYXkuaXNBcnJheSh0cmVlKVxuICAgICAgICA/IGNsb25lVk5vZGVzKHRyZWUpXG4gICAgICAgIDogY2xvbmVWTm9kZSh0cmVlKVxuICAgIH1cbiAgICAvLyBvdGhlcndpc2UsIHJlbmRlciBhIGZyZXNoIHRyZWUuXG4gICAgdHJlZSA9IHRoaXMuX3N0YXRpY1RyZWVzW2luZGV4XSA9IHRoaXMuJG9wdGlvbnMuc3RhdGljUmVuZGVyRm5zW2luZGV4XS5jYWxsKHRoaXMuX3JlbmRlclByb3h5KTtcbiAgICBtYXJrU3RhdGljKHRyZWUsIChcIl9fc3RhdGljX19cIiArIGluZGV4KSwgZmFsc2UpO1xuICAgIHJldHVybiB0cmVlXG4gIH07XG5cbiAgLy8gbWFyayBub2RlIGFzIHN0YXRpYyAodi1vbmNlKVxuICBWdWUucHJvdG90eXBlLl9vID0gZnVuY3Rpb24gbWFya09uY2UgKFxuICAgIHRyZWUsXG4gICAgaW5kZXgsXG4gICAga2V5XG4gICkge1xuICAgIG1hcmtTdGF0aWModHJlZSwgKFwiX19vbmNlX19cIiArIGluZGV4ICsgKGtleSA/IChcIl9cIiArIGtleSkgOiBcIlwiKSksIHRydWUpO1xuICAgIHJldHVybiB0cmVlXG4gIH07XG5cbiAgZnVuY3Rpb24gbWFya1N0YXRpYyAodHJlZSwga2V5LCBpc09uY2UpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmVlKSkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0cmVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmICh0cmVlW2ldICYmIHR5cGVvZiB0cmVlW2ldICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgIG1hcmtTdGF0aWNOb2RlKHRyZWVbaV0sIChrZXkgKyBcIl9cIiArIGkpLCBpc09uY2UpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIG1hcmtTdGF0aWNOb2RlKHRyZWUsIGtleSwgaXNPbmNlKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBtYXJrU3RhdGljTm9kZSAobm9kZSwga2V5LCBpc09uY2UpIHtcbiAgICBub2RlLmlzU3RhdGljID0gdHJ1ZTtcbiAgICBub2RlLmtleSA9IGtleTtcbiAgICBub2RlLmlzT25jZSA9IGlzT25jZTtcbiAgfVxuXG4gIC8vIGZpbHRlciByZXNvbHV0aW9uIGhlbHBlclxuICB2YXIgaWRlbnRpdHkgPSBmdW5jdGlvbiAoXykgeyByZXR1cm4gXzsgfTtcbiAgVnVlLnByb3RvdHlwZS5fZiA9IGZ1bmN0aW9uIHJlc29sdmVGaWx0ZXIgKGlkKSB7XG4gICAgcmV0dXJuIHJlc29sdmVBc3NldCh0aGlzLiRvcHRpb25zLCAnZmlsdGVycycsIGlkLCB0cnVlKSB8fCBpZGVudGl0eVxuICB9O1xuXG4gIC8vIHJlbmRlciB2LWZvclxuICBWdWUucHJvdG90eXBlLl9sID0gZnVuY3Rpb24gcmVuZGVyTGlzdCAoXG4gICAgdmFsLFxuICAgIHJlbmRlclxuICApIHtcbiAgICB2YXIgcmV0LCBpLCBsLCBrZXlzLCBrZXk7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsKSkge1xuICAgICAgcmV0ID0gbmV3IEFycmF5KHZhbC5sZW5ndGgpO1xuICAgICAgZm9yIChpID0gMCwgbCA9IHZhbC5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgcmV0W2ldID0gcmVuZGVyKHZhbFtpXSwgaSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgICAgcmV0ID0gbmV3IEFycmF5KHZhbCk7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgdmFsOyBpKyspIHtcbiAgICAgICAgcmV0W2ldID0gcmVuZGVyKGkgKyAxLCBpKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGlzT2JqZWN0KHZhbCkpIHtcbiAgICAgIGtleXMgPSBPYmplY3Qua2V5cyh2YWwpO1xuICAgICAgcmV0ID0gbmV3IEFycmF5KGtleXMubGVuZ3RoKTtcbiAgICAgIGZvciAoaSA9IDAsIGwgPSBrZXlzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICBrZXkgPSBrZXlzW2ldO1xuICAgICAgICByZXRbaV0gPSByZW5kZXIodmFsW2tleV0sIGtleSwgaSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXRcbiAgfTtcblxuICAvLyByZW5kZXJTbG90XG4gIFZ1ZS5wcm90b3R5cGUuX3QgPSBmdW5jdGlvbiAoXG4gICAgbmFtZSxcbiAgICBmYWxsYmFja1xuICApIHtcbiAgICB2YXIgc2xvdE5vZGVzID0gdGhpcy4kc2xvdHNbbmFtZV07XG4gICAgLy8gd2FybiBkdXBsaWNhdGUgc2xvdCB1c2FnZVxuICAgIGlmIChzbG90Tm9kZXMgJiYgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgc2xvdE5vZGVzLl9yZW5kZXJlZCAmJiB3YXJuKFxuICAgICAgICBcIkR1cGxpY2F0ZSBwcmVzZW5jZSBvZiBzbG90IFxcXCJcIiArIG5hbWUgKyBcIlxcXCIgZm91bmQgaW4gdGhlIHNhbWUgcmVuZGVyIHRyZWUgXCIgK1xuICAgICAgICBcIi0gdGhpcyB3aWxsIGxpa2VseSBjYXVzZSByZW5kZXIgZXJyb3JzLlwiLFxuICAgICAgICB0aGlzXG4gICAgICApO1xuICAgICAgc2xvdE5vZGVzLl9yZW5kZXJlZCA9IHRydWU7XG4gICAgfVxuICAgIHJldHVybiBzbG90Tm9kZXMgfHwgZmFsbGJhY2tcbiAgfTtcblxuICAvLyBhcHBseSB2LWJpbmQgb2JqZWN0XG4gIFZ1ZS5wcm90b3R5cGUuX2IgPSBmdW5jdGlvbiBiaW5kUHJvcHMgKFxuICAgIGRhdGEsXG4gICAgdGFnLFxuICAgIHZhbHVlLFxuICAgIGFzUHJvcFxuICApIHtcbiAgICBpZiAodmFsdWUpIHtcbiAgICAgIGlmICghaXNPYmplY3QodmFsdWUpKSB7XG4gICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcbiAgICAgICAgICAndi1iaW5kIHdpdGhvdXQgYXJndW1lbnQgZXhwZWN0cyBhbiBPYmplY3Qgb3IgQXJyYXkgdmFsdWUnLFxuICAgICAgICAgIHRoaXNcbiAgICAgICAgKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgIHZhbHVlID0gdG9PYmplY3QodmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIGtleSBpbiB2YWx1ZSkge1xuICAgICAgICAgIGlmIChrZXkgPT09ICdjbGFzcycgfHwga2V5ID09PSAnc3R5bGUnKSB7XG4gICAgICAgICAgICBkYXRhW2tleV0gPSB2YWx1ZVtrZXldO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgaGFzaCA9IGFzUHJvcCB8fCBjb25maWcubXVzdFVzZVByb3AodGFnLCBrZXkpXG4gICAgICAgICAgICAgID8gZGF0YS5kb21Qcm9wcyB8fCAoZGF0YS5kb21Qcm9wcyA9IHt9KVxuICAgICAgICAgICAgICA6IGRhdGEuYXR0cnMgfHwgKGRhdGEuYXR0cnMgPSB7fSk7XG4gICAgICAgICAgICBoYXNoW2tleV0gPSB2YWx1ZVtrZXldO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZGF0YVxuICB9O1xuXG4gIC8vIGV4cG9zZSB2LW9uIGtleUNvZGVzXG4gIFZ1ZS5wcm90b3R5cGUuX2sgPSBmdW5jdGlvbiBnZXRLZXlDb2RlcyAoa2V5KSB7XG4gICAgcmV0dXJuIGNvbmZpZy5rZXlDb2Rlc1trZXldXG4gIH07XG59XG5cbmZ1bmN0aW9uIHJlc29sdmVTbG90cyAoXG4gIHJlbmRlckNoaWxkcmVuLFxuICBjb250ZXh0XG4pIHtcbiAgdmFyIHNsb3RzID0ge307XG4gIGlmICghcmVuZGVyQ2hpbGRyZW4pIHtcbiAgICByZXR1cm4gc2xvdHNcbiAgfVxuICB2YXIgY2hpbGRyZW4gPSBub3JtYWxpemVDaGlsZHJlbihyZW5kZXJDaGlsZHJlbikgfHwgW107XG4gIHZhciBkZWZhdWx0U2xvdCA9IFtdO1xuICB2YXIgbmFtZSwgY2hpbGQ7XG4gIGZvciAodmFyIGkgPSAwLCBsID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgY2hpbGQgPSBjaGlsZHJlbltpXTtcbiAgICAvLyBuYW1lZCBzbG90cyBzaG91bGQgb25seSBiZSByZXNwZWN0ZWQgaWYgdGhlIHZub2RlIHdhcyByZW5kZXJlZCBpbiB0aGVcbiAgICAvLyBzYW1lIGNvbnRleHQuXG4gICAgaWYgKChjaGlsZC5jb250ZXh0ID09PSBjb250ZXh0IHx8IGNoaWxkLmZ1bmN0aW9uYWxDb250ZXh0ID09PSBjb250ZXh0KSAmJlxuICAgICAgICBjaGlsZC5kYXRhICYmIChuYW1lID0gY2hpbGQuZGF0YS5zbG90KSkge1xuICAgICAgdmFyIHNsb3QgPSAoc2xvdHNbbmFtZV0gfHwgKHNsb3RzW25hbWVdID0gW10pKTtcbiAgICAgIGlmIChjaGlsZC50YWcgPT09ICd0ZW1wbGF0ZScpIHtcbiAgICAgICAgc2xvdC5wdXNoLmFwcGx5KHNsb3QsIGNoaWxkLmNoaWxkcmVuKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNsb3QucHVzaChjaGlsZCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlZmF1bHRTbG90LnB1c2goY2hpbGQpO1xuICAgIH1cbiAgfVxuICAvLyBpZ25vcmUgc2luZ2xlIHdoaXRlc3BhY2VcbiAgaWYgKGRlZmF1bHRTbG90Lmxlbmd0aCAmJiAhKFxuICAgIGRlZmF1bHRTbG90Lmxlbmd0aCA9PT0gMSAmJlxuICAgIChkZWZhdWx0U2xvdFswXS50ZXh0ID09PSAnICcgfHwgZGVmYXVsdFNsb3RbMF0uaXNDb21tZW50KVxuICApKSB7XG4gICAgc2xvdHMuZGVmYXVsdCA9IGRlZmF1bHRTbG90O1xuICB9XG4gIHJldHVybiBzbG90c1xufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gaW5pdEV2ZW50cyAodm0pIHtcbiAgdm0uX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIC8vIGluaXQgcGFyZW50IGF0dGFjaGVkIGV2ZW50c1xuICB2YXIgbGlzdGVuZXJzID0gdm0uJG9wdGlvbnMuX3BhcmVudExpc3RlbmVycztcbiAgdmFyIG9uID0gYmluZCQxKHZtLiRvbiwgdm0pO1xuICB2YXIgb2ZmID0gYmluZCQxKHZtLiRvZmYsIHZtKTtcbiAgdm0uX3VwZGF0ZUxpc3RlbmVycyA9IGZ1bmN0aW9uIChsaXN0ZW5lcnMsIG9sZExpc3RlbmVycykge1xuICAgIHVwZGF0ZUxpc3RlbmVycyhsaXN0ZW5lcnMsIG9sZExpc3RlbmVycyB8fCB7fSwgb24sIG9mZiwgdm0pO1xuICB9O1xuICBpZiAobGlzdGVuZXJzKSB7XG4gICAgdm0uX3VwZGF0ZUxpc3RlbmVycyhsaXN0ZW5lcnMpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGV2ZW50c01peGluIChWdWUpIHtcbiAgVnVlLnByb3RvdHlwZS4kb24gPSBmdW5jdGlvbiAoZXZlbnQsIGZuKSB7XG4gICAgdmFyIHZtID0gdGhpczsodm0uX2V2ZW50c1tldmVudF0gfHwgKHZtLl9ldmVudHNbZXZlbnRdID0gW10pKS5wdXNoKGZuKTtcbiAgICByZXR1cm4gdm1cbiAgfTtcblxuICBWdWUucHJvdG90eXBlLiRvbmNlID0gZnVuY3Rpb24gKGV2ZW50LCBmbikge1xuICAgIHZhciB2bSA9IHRoaXM7XG4gICAgZnVuY3Rpb24gb24gKCkge1xuICAgICAgdm0uJG9mZihldmVudCwgb24pO1xuICAgICAgZm4uYXBwbHkodm0sIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIG9uLmZuID0gZm47XG4gICAgdm0uJG9uKGV2ZW50LCBvbik7XG4gICAgcmV0dXJuIHZtXG4gIH07XG5cbiAgVnVlLnByb3RvdHlwZS4kb2ZmID0gZnVuY3Rpb24gKGV2ZW50LCBmbikge1xuICAgIHZhciB2bSA9IHRoaXM7XG4gICAgLy8gYWxsXG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICB2bS5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgIHJldHVybiB2bVxuICAgIH1cbiAgICAvLyBzcGVjaWZpYyBldmVudFxuICAgIHZhciBjYnMgPSB2bS5fZXZlbnRzW2V2ZW50XTtcbiAgICBpZiAoIWNicykge1xuICAgICAgcmV0dXJuIHZtXG4gICAgfVxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgICB2bS5fZXZlbnRzW2V2ZW50XSA9IG51bGw7XG4gICAgICByZXR1cm4gdm1cbiAgICB9XG4gICAgLy8gc3BlY2lmaWMgaGFuZGxlclxuICAgIHZhciBjYjtcbiAgICB2YXIgaSA9IGNicy5sZW5ndGg7XG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgY2IgPSBjYnNbaV07XG4gICAgICBpZiAoY2IgPT09IGZuIHx8IGNiLmZuID09PSBmbikge1xuICAgICAgICBjYnMuc3BsaWNlKGksIDEpO1xuICAgICAgICBicmVha1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdm1cbiAgfTtcblxuICBWdWUucHJvdG90eXBlLiRlbWl0ID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgdmFyIHZtID0gdGhpcztcbiAgICB2YXIgY2JzID0gdm0uX2V2ZW50c1tldmVudF07XG4gICAgaWYgKGNicykge1xuICAgICAgY2JzID0gY2JzLmxlbmd0aCA+IDEgPyB0b0FycmF5KGNicykgOiBjYnM7XG4gICAgICB2YXIgYXJncyA9IHRvQXJyYXkoYXJndW1lbnRzLCAxKTtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gY2JzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICBjYnNbaV0uYXBwbHkodm0sIGFyZ3MpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdm1cbiAgfTtcbn1cblxuLyogICovXG5cbnZhciB1aWQgPSAwO1xuXG5mdW5jdGlvbiBpbml0TWl4aW4gKFZ1ZSkge1xuICBWdWUucHJvdG90eXBlLl9pbml0ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICB2YXIgdm0gPSB0aGlzO1xuICAgIC8vIGEgdWlkXG4gICAgdm0uX3VpZCA9IHVpZCsrO1xuICAgIC8vIGEgZmxhZyB0byBhdm9pZCB0aGlzIGJlaW5nIG9ic2VydmVkXG4gICAgdm0uX2lzVnVlID0gdHJ1ZTtcbiAgICAvLyBtZXJnZSBvcHRpb25zXG4gICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5faXNDb21wb25lbnQpIHtcbiAgICAgIC8vIG9wdGltaXplIGludGVybmFsIGNvbXBvbmVudCBpbnN0YW50aWF0aW9uXG4gICAgICAvLyBzaW5jZSBkeW5hbWljIG9wdGlvbnMgbWVyZ2luZyBpcyBwcmV0dHkgc2xvdywgYW5kIG5vbmUgb2YgdGhlXG4gICAgICAvLyBpbnRlcm5hbCBjb21wb25lbnQgb3B0aW9ucyBuZWVkcyBzcGVjaWFsIHRyZWF0bWVudC5cbiAgICAgIGluaXRJbnRlcm5hbENvbXBvbmVudCh2bSwgb3B0aW9ucyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZtLiRvcHRpb25zID0gbWVyZ2VPcHRpb25zKFxuICAgICAgICByZXNvbHZlQ29uc3RydWN0b3JPcHRpb25zKHZtLmNvbnN0cnVjdG9yKSxcbiAgICAgICAgb3B0aW9ucyB8fCB7fSxcbiAgICAgICAgdm1cbiAgICAgICk7XG4gICAgfVxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGluaXRQcm94eSh2bSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZtLl9yZW5kZXJQcm94eSA9IHZtO1xuICAgIH1cbiAgICAvLyBleHBvc2UgcmVhbCBzZWxmXG4gICAgdm0uX3NlbGYgPSB2bTtcbiAgICBpbml0TGlmZWN5Y2xlKHZtKTtcbiAgICBpbml0RXZlbnRzKHZtKTtcbiAgICBjYWxsSG9vayh2bSwgJ2JlZm9yZUNyZWF0ZScpO1xuICAgIGluaXRTdGF0ZSh2bSk7XG4gICAgY2FsbEhvb2sodm0sICdjcmVhdGVkJyk7XG4gICAgaW5pdFJlbmRlcih2bSk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGluaXRJbnRlcm5hbENvbXBvbmVudCAodm0sIG9wdGlvbnMpIHtcbiAgdmFyIG9wdHMgPSB2bS4kb3B0aW9ucyA9IE9iamVjdC5jcmVhdGUodm0uY29uc3RydWN0b3Iub3B0aW9ucyk7XG4gIC8vIGRvaW5nIHRoaXMgYmVjYXVzZSBpdCdzIGZhc3RlciB0aGFuIGR5bmFtaWMgZW51bWVyYXRpb24uXG4gIG9wdHMucGFyZW50ID0gb3B0aW9ucy5wYXJlbnQ7XG4gIG9wdHMucHJvcHNEYXRhID0gb3B0aW9ucy5wcm9wc0RhdGE7XG4gIG9wdHMuX3BhcmVudFZub2RlID0gb3B0aW9ucy5fcGFyZW50Vm5vZGU7XG4gIG9wdHMuX3BhcmVudExpc3RlbmVycyA9IG9wdGlvbnMuX3BhcmVudExpc3RlbmVycztcbiAgb3B0cy5fcmVuZGVyQ2hpbGRyZW4gPSBvcHRpb25zLl9yZW5kZXJDaGlsZHJlbjtcbiAgb3B0cy5fY29tcG9uZW50VGFnID0gb3B0aW9ucy5fY29tcG9uZW50VGFnO1xuICBpZiAob3B0aW9ucy5yZW5kZXIpIHtcbiAgICBvcHRzLnJlbmRlciA9IG9wdGlvbnMucmVuZGVyO1xuICAgIG9wdHMuc3RhdGljUmVuZGVyRm5zID0gb3B0aW9ucy5zdGF0aWNSZW5kZXJGbnM7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVzb2x2ZUNvbnN0cnVjdG9yT3B0aW9ucyAoQ3Rvcikge1xuICB2YXIgb3B0aW9ucyA9IEN0b3Iub3B0aW9ucztcbiAgaWYgKEN0b3Iuc3VwZXIpIHtcbiAgICB2YXIgc3VwZXJPcHRpb25zID0gQ3Rvci5zdXBlci5vcHRpb25zO1xuICAgIHZhciBjYWNoZWRTdXBlck9wdGlvbnMgPSBDdG9yLnN1cGVyT3B0aW9ucztcbiAgICB2YXIgZXh0ZW5kT3B0aW9ucyA9IEN0b3IuZXh0ZW5kT3B0aW9ucztcbiAgICBpZiAoc3VwZXJPcHRpb25zICE9PSBjYWNoZWRTdXBlck9wdGlvbnMpIHtcbiAgICAgIC8vIHN1cGVyIG9wdGlvbiBjaGFuZ2VkXG4gICAgICBDdG9yLnN1cGVyT3B0aW9ucyA9IHN1cGVyT3B0aW9ucztcbiAgICAgIGV4dGVuZE9wdGlvbnMucmVuZGVyID0gb3B0aW9ucy5yZW5kZXI7XG4gICAgICBleHRlbmRPcHRpb25zLnN0YXRpY1JlbmRlckZucyA9IG9wdGlvbnMuc3RhdGljUmVuZGVyRm5zO1xuICAgICAgb3B0aW9ucyA9IEN0b3Iub3B0aW9ucyA9IG1lcmdlT3B0aW9ucyhzdXBlck9wdGlvbnMsIGV4dGVuZE9wdGlvbnMpO1xuICAgICAgaWYgKG9wdGlvbnMubmFtZSkge1xuICAgICAgICBvcHRpb25zLmNvbXBvbmVudHNbb3B0aW9ucy5uYW1lXSA9IEN0b3I7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBvcHRpb25zXG59XG5cbmZ1bmN0aW9uIFZ1ZSQyIChvcHRpb25zKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmXG4gICAgISh0aGlzIGluc3RhbmNlb2YgVnVlJDIpKSB7XG4gICAgd2FybignVnVlIGlzIGEgY29uc3RydWN0b3IgYW5kIHNob3VsZCBiZSBjYWxsZWQgd2l0aCB0aGUgYG5ld2Aga2V5d29yZCcpO1xuICB9XG4gIHRoaXMuX2luaXQob3B0aW9ucyk7XG59XG5cbmluaXRNaXhpbihWdWUkMik7XG5zdGF0ZU1peGluKFZ1ZSQyKTtcbmV2ZW50c01peGluKFZ1ZSQyKTtcbmxpZmVjeWNsZU1peGluKFZ1ZSQyKTtcbnJlbmRlck1peGluKFZ1ZSQyKTtcblxudmFyIHdhcm4gPSBub29wO1xudmFyIGZvcm1hdENvbXBvbmVudE5hbWU7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHZhciBoYXNDb25zb2xlID0gdHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnO1xuXG4gIHdhcm4gPSBmdW5jdGlvbiAobXNnLCB2bSkge1xuICAgIGlmIChoYXNDb25zb2xlICYmICghY29uZmlnLnNpbGVudCkpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJbVnVlIHdhcm5dOiBcIiArIG1zZyArIFwiIFwiICsgKFxuICAgICAgICB2bSA/IGZvcm1hdExvY2F0aW9uKGZvcm1hdENvbXBvbmVudE5hbWUodm0pKSA6ICcnXG4gICAgICApKTtcbiAgICB9XG4gIH07XG5cbiAgZm9ybWF0Q29tcG9uZW50TmFtZSA9IGZ1bmN0aW9uICh2bSkge1xuICAgIGlmICh2bS4kcm9vdCA9PT0gdm0pIHtcbiAgICAgIHJldHVybiAncm9vdCBpbnN0YW5jZSdcbiAgICB9XG4gICAgdmFyIG5hbWUgPSB2bS5faXNWdWVcbiAgICAgID8gdm0uJG9wdGlvbnMubmFtZSB8fCB2bS4kb3B0aW9ucy5fY29tcG9uZW50VGFnXG4gICAgICA6IHZtLm5hbWU7XG4gICAgcmV0dXJuIChcbiAgICAgIChuYW1lID8gKFwiY29tcG9uZW50IDxcIiArIG5hbWUgKyBcIj5cIikgOiBcImFub255bW91cyBjb21wb25lbnRcIikgK1xuICAgICAgKHZtLl9pc1Z1ZSAmJiB2bS4kb3B0aW9ucy5fX2ZpbGUgPyAoXCIgYXQgXCIgKyAodm0uJG9wdGlvbnMuX19maWxlKSkgOiAnJylcbiAgICApXG4gIH07XG5cbiAgdmFyIGZvcm1hdExvY2F0aW9uID0gZnVuY3Rpb24gKHN0cikge1xuICAgIGlmIChzdHIgPT09ICdhbm9ueW1vdXMgY29tcG9uZW50Jykge1xuICAgICAgc3RyICs9IFwiIC0gdXNlIHRoZSBcXFwibmFtZVxcXCIgb3B0aW9uIGZvciBiZXR0ZXIgZGVidWdnaW5nIG1lc3NhZ2VzLlwiO1xuICAgIH1cbiAgICByZXR1cm4gKFwiXFxuKGZvdW5kIGluIFwiICsgc3RyICsgXCIpXCIpXG4gIH07XG59XG5cbi8qICAqL1xuXG4vKipcbiAqIE9wdGlvbiBvdmVyd3JpdGluZyBzdHJhdGVnaWVzIGFyZSBmdW5jdGlvbnMgdGhhdCBoYW5kbGVcbiAqIGhvdyB0byBtZXJnZSBhIHBhcmVudCBvcHRpb24gdmFsdWUgYW5kIGEgY2hpbGQgb3B0aW9uXG4gKiB2YWx1ZSBpbnRvIHRoZSBmaW5hbCB2YWx1ZS5cbiAqL1xudmFyIHN0cmF0cyA9IGNvbmZpZy5vcHRpb25NZXJnZVN0cmF0ZWdpZXM7XG5cbi8qKlxuICogT3B0aW9ucyB3aXRoIHJlc3RyaWN0aW9uc1xuICovXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICBzdHJhdHMuZWwgPSBzdHJhdHMucHJvcHNEYXRhID0gZnVuY3Rpb24gKHBhcmVudCwgY2hpbGQsIHZtLCBrZXkpIHtcbiAgICBpZiAoIXZtKSB7XG4gICAgICB3YXJuKFxuICAgICAgICBcIm9wdGlvbiBcXFwiXCIgKyBrZXkgKyBcIlxcXCIgY2FuIG9ubHkgYmUgdXNlZCBkdXJpbmcgaW5zdGFuY2UgXCIgK1xuICAgICAgICAnY3JlYXRpb24gd2l0aCB0aGUgYG5ld2Aga2V5d29yZC4nXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4gZGVmYXVsdFN0cmF0KHBhcmVudCwgY2hpbGQpXG4gIH07XG59XG5cbi8qKlxuICogSGVscGVyIHRoYXQgcmVjdXJzaXZlbHkgbWVyZ2VzIHR3byBkYXRhIG9iamVjdHMgdG9nZXRoZXIuXG4gKi9cbmZ1bmN0aW9uIG1lcmdlRGF0YSAodG8sIGZyb20pIHtcbiAgaWYgKCFmcm9tKSB7IHJldHVybiB0byB9XG4gIHZhciBrZXksIHRvVmFsLCBmcm9tVmFsO1xuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGZyb20pO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICBrZXkgPSBrZXlzW2ldO1xuICAgIHRvVmFsID0gdG9ba2V5XTtcbiAgICBmcm9tVmFsID0gZnJvbVtrZXldO1xuICAgIGlmICghaGFzT3duKHRvLCBrZXkpKSB7XG4gICAgICBzZXQodG8sIGtleSwgZnJvbVZhbCk7XG4gICAgfSBlbHNlIGlmIChpc1BsYWluT2JqZWN0KHRvVmFsKSAmJiBpc1BsYWluT2JqZWN0KGZyb21WYWwpKSB7XG4gICAgICBtZXJnZURhdGEodG9WYWwsIGZyb21WYWwpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdG9cbn1cblxuLyoqXG4gKiBEYXRhXG4gKi9cbnN0cmF0cy5kYXRhID0gZnVuY3Rpb24gKFxuICBwYXJlbnRWYWwsXG4gIGNoaWxkVmFsLFxuICB2bVxuKSB7XG4gIGlmICghdm0pIHtcbiAgICAvLyBpbiBhIFZ1ZS5leHRlbmQgbWVyZ2UsIGJvdGggc2hvdWxkIGJlIGZ1bmN0aW9uc1xuICAgIGlmICghY2hpbGRWYWwpIHtcbiAgICAgIHJldHVybiBwYXJlbnRWYWxcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBjaGlsZFZhbCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxuICAgICAgICAnVGhlIFwiZGF0YVwiIG9wdGlvbiBzaG91bGQgYmUgYSBmdW5jdGlvbiAnICtcbiAgICAgICAgJ3RoYXQgcmV0dXJucyBhIHBlci1pbnN0YW5jZSB2YWx1ZSBpbiBjb21wb25lbnQgJyArXG4gICAgICAgICdkZWZpbml0aW9ucy4nLFxuICAgICAgICB2bVxuICAgICAgKTtcbiAgICAgIHJldHVybiBwYXJlbnRWYWxcbiAgICB9XG4gICAgaWYgKCFwYXJlbnRWYWwpIHtcbiAgICAgIHJldHVybiBjaGlsZFZhbFxuICAgIH1cbiAgICAvLyB3aGVuIHBhcmVudFZhbCAmIGNoaWxkVmFsIGFyZSBib3RoIHByZXNlbnQsXG4gICAgLy8gd2UgbmVlZCB0byByZXR1cm4gYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgdGhlXG4gICAgLy8gbWVyZ2VkIHJlc3VsdCBvZiBib3RoIGZ1bmN0aW9ucy4uLiBubyBuZWVkIHRvXG4gICAgLy8gY2hlY2sgaWYgcGFyZW50VmFsIGlzIGEgZnVuY3Rpb24gaGVyZSBiZWNhdXNlXG4gICAgLy8gaXQgaGFzIHRvIGJlIGEgZnVuY3Rpb24gdG8gcGFzcyBwcmV2aW91cyBtZXJnZXMuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIG1lcmdlZERhdGFGbiAoKSB7XG4gICAgICByZXR1cm4gbWVyZ2VEYXRhKFxuICAgICAgICBjaGlsZFZhbC5jYWxsKHRoaXMpLFxuICAgICAgICBwYXJlbnRWYWwuY2FsbCh0aGlzKVxuICAgICAgKVxuICAgIH1cbiAgfSBlbHNlIGlmIChwYXJlbnRWYWwgfHwgY2hpbGRWYWwpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gbWVyZ2VkSW5zdGFuY2VEYXRhRm4gKCkge1xuICAgICAgLy8gaW5zdGFuY2UgbWVyZ2VcbiAgICAgIHZhciBpbnN0YW5jZURhdGEgPSB0eXBlb2YgY2hpbGRWYWwgPT09ICdmdW5jdGlvbidcbiAgICAgICAgPyBjaGlsZFZhbC5jYWxsKHZtKVxuICAgICAgICA6IGNoaWxkVmFsO1xuICAgICAgdmFyIGRlZmF1bHREYXRhID0gdHlwZW9mIHBhcmVudFZhbCA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICA/IHBhcmVudFZhbC5jYWxsKHZtKVxuICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICAgIGlmIChpbnN0YW5jZURhdGEpIHtcbiAgICAgICAgcmV0dXJuIG1lcmdlRGF0YShpbnN0YW5jZURhdGEsIGRlZmF1bHREYXRhKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGRlZmF1bHREYXRhXG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIEhvb2tzIGFuZCBwYXJhbSBhdHRyaWJ1dGVzIGFyZSBtZXJnZWQgYXMgYXJyYXlzLlxuICovXG5mdW5jdGlvbiBtZXJnZUhvb2sgKFxuICBwYXJlbnRWYWwsXG4gIGNoaWxkVmFsXG4pIHtcbiAgcmV0dXJuIGNoaWxkVmFsXG4gICAgPyBwYXJlbnRWYWxcbiAgICAgID8gcGFyZW50VmFsLmNvbmNhdChjaGlsZFZhbClcbiAgICAgIDogQXJyYXkuaXNBcnJheShjaGlsZFZhbClcbiAgICAgICAgPyBjaGlsZFZhbFxuICAgICAgICA6IFtjaGlsZFZhbF1cbiAgICA6IHBhcmVudFZhbFxufVxuXG5jb25maWcuX2xpZmVjeWNsZUhvb2tzLmZvckVhY2goZnVuY3Rpb24gKGhvb2spIHtcbiAgc3RyYXRzW2hvb2tdID0gbWVyZ2VIb29rO1xufSk7XG5cbi8qKlxuICogQXNzZXRzXG4gKlxuICogV2hlbiBhIHZtIGlzIHByZXNlbnQgKGluc3RhbmNlIGNyZWF0aW9uKSwgd2UgbmVlZCB0byBkb1xuICogYSB0aHJlZS13YXkgbWVyZ2UgYmV0d2VlbiBjb25zdHJ1Y3RvciBvcHRpb25zLCBpbnN0YW5jZVxuICogb3B0aW9ucyBhbmQgcGFyZW50IG9wdGlvbnMuXG4gKi9cbmZ1bmN0aW9uIG1lcmdlQXNzZXRzIChwYXJlbnRWYWwsIGNoaWxkVmFsKSB7XG4gIHZhciByZXMgPSBPYmplY3QuY3JlYXRlKHBhcmVudFZhbCB8fCBudWxsKTtcbiAgcmV0dXJuIGNoaWxkVmFsXG4gICAgPyBleHRlbmQocmVzLCBjaGlsZFZhbClcbiAgICA6IHJlc1xufVxuXG5jb25maWcuX2Fzc2V0VHlwZXMuZm9yRWFjaChmdW5jdGlvbiAodHlwZSkge1xuICBzdHJhdHNbdHlwZSArICdzJ10gPSBtZXJnZUFzc2V0cztcbn0pO1xuXG4vKipcbiAqIFdhdGNoZXJzLlxuICpcbiAqIFdhdGNoZXJzIGhhc2hlcyBzaG91bGQgbm90IG92ZXJ3cml0ZSBvbmVcbiAqIGFub3RoZXIsIHNvIHdlIG1lcmdlIHRoZW0gYXMgYXJyYXlzLlxuICovXG5zdHJhdHMud2F0Y2ggPSBmdW5jdGlvbiAocGFyZW50VmFsLCBjaGlsZFZhbCkge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKCFjaGlsZFZhbCkgeyByZXR1cm4gcGFyZW50VmFsIH1cbiAgaWYgKCFwYXJlbnRWYWwpIHsgcmV0dXJuIGNoaWxkVmFsIH1cbiAgdmFyIHJldCA9IHt9O1xuICBleHRlbmQocmV0LCBwYXJlbnRWYWwpO1xuICBmb3IgKHZhciBrZXkgaW4gY2hpbGRWYWwpIHtcbiAgICB2YXIgcGFyZW50ID0gcmV0W2tleV07XG4gICAgdmFyIGNoaWxkID0gY2hpbGRWYWxba2V5XTtcbiAgICBpZiAocGFyZW50ICYmICFBcnJheS5pc0FycmF5KHBhcmVudCkpIHtcbiAgICAgIHBhcmVudCA9IFtwYXJlbnRdO1xuICAgIH1cbiAgICByZXRba2V5XSA9IHBhcmVudFxuICAgICAgPyBwYXJlbnQuY29uY2F0KGNoaWxkKVxuICAgICAgOiBbY2hpbGRdO1xuICB9XG4gIHJldHVybiByZXRcbn07XG5cbi8qKlxuICogT3RoZXIgb2JqZWN0IGhhc2hlcy5cbiAqL1xuc3RyYXRzLnByb3BzID1cbnN0cmF0cy5tZXRob2RzID1cbnN0cmF0cy5jb21wdXRlZCA9IGZ1bmN0aW9uIChwYXJlbnRWYWwsIGNoaWxkVmFsKSB7XG4gIGlmICghY2hpbGRWYWwpIHsgcmV0dXJuIHBhcmVudFZhbCB9XG4gIGlmICghcGFyZW50VmFsKSB7IHJldHVybiBjaGlsZFZhbCB9XG4gIHZhciByZXQgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICBleHRlbmQocmV0LCBwYXJlbnRWYWwpO1xuICBleHRlbmQocmV0LCBjaGlsZFZhbCk7XG4gIHJldHVybiByZXRcbn07XG5cbi8qKlxuICogRGVmYXVsdCBzdHJhdGVneS5cbiAqL1xudmFyIGRlZmF1bHRTdHJhdCA9IGZ1bmN0aW9uIChwYXJlbnRWYWwsIGNoaWxkVmFsKSB7XG4gIHJldHVybiBjaGlsZFZhbCA9PT0gdW5kZWZpbmVkXG4gICAgPyBwYXJlbnRWYWxcbiAgICA6IGNoaWxkVmFsXG59O1xuXG4vKipcbiAqIFZhbGlkYXRlIGNvbXBvbmVudCBuYW1lc1xuICovXG5mdW5jdGlvbiBjaGVja0NvbXBvbmVudHMgKG9wdGlvbnMpIHtcbiAgZm9yICh2YXIga2V5IGluIG9wdGlvbnMuY29tcG9uZW50cykge1xuICAgIHZhciBsb3dlciA9IGtleS50b0xvd2VyQ2FzZSgpO1xuICAgIGlmIChpc0J1aWx0SW5UYWcobG93ZXIpIHx8IGNvbmZpZy5pc1Jlc2VydmVkVGFnKGxvd2VyKSkge1xuICAgICAgd2FybihcbiAgICAgICAgJ0RvIG5vdCB1c2UgYnVpbHQtaW4gb3IgcmVzZXJ2ZWQgSFRNTCBlbGVtZW50cyBhcyBjb21wb25lbnQgJyArXG4gICAgICAgICdpZDogJyArIGtleVxuICAgICAgKTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBFbnN1cmUgYWxsIHByb3BzIG9wdGlvbiBzeW50YXggYXJlIG5vcm1hbGl6ZWQgaW50byB0aGVcbiAqIE9iamVjdC1iYXNlZCBmb3JtYXQuXG4gKi9cbmZ1bmN0aW9uIG5vcm1hbGl6ZVByb3BzIChvcHRpb25zKSB7XG4gIHZhciBwcm9wcyA9IG9wdGlvbnMucHJvcHM7XG4gIGlmICghcHJvcHMpIHsgcmV0dXJuIH1cbiAgdmFyIHJlcyA9IHt9O1xuICB2YXIgaSwgdmFsLCBuYW1lO1xuICBpZiAoQXJyYXkuaXNBcnJheShwcm9wcykpIHtcbiAgICBpID0gcHJvcHMubGVuZ3RoO1xuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIHZhbCA9IHByb3BzW2ldO1xuICAgICAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIG5hbWUgPSBjYW1lbGl6ZSh2YWwpO1xuICAgICAgICByZXNbbmFtZV0gPSB7IHR5cGU6IG51bGwgfTtcbiAgICAgIH0gZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICB3YXJuKCdwcm9wcyBtdXN0IGJlIHN0cmluZ3Mgd2hlbiB1c2luZyBhcnJheSBzeW50YXguJyk7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzUGxhaW5PYmplY3QocHJvcHMpKSB7XG4gICAgZm9yICh2YXIga2V5IGluIHByb3BzKSB7XG4gICAgICB2YWwgPSBwcm9wc1trZXldO1xuICAgICAgbmFtZSA9IGNhbWVsaXplKGtleSk7XG4gICAgICByZXNbbmFtZV0gPSBpc1BsYWluT2JqZWN0KHZhbClcbiAgICAgICAgPyB2YWxcbiAgICAgICAgOiB7IHR5cGU6IHZhbCB9O1xuICAgIH1cbiAgfVxuICBvcHRpb25zLnByb3BzID0gcmVzO1xufVxuXG4vKipcbiAqIE5vcm1hbGl6ZSByYXcgZnVuY3Rpb24gZGlyZWN0aXZlcyBpbnRvIG9iamVjdCBmb3JtYXQuXG4gKi9cbmZ1bmN0aW9uIG5vcm1hbGl6ZURpcmVjdGl2ZXMgKG9wdGlvbnMpIHtcbiAgdmFyIGRpcnMgPSBvcHRpb25zLmRpcmVjdGl2ZXM7XG4gIGlmIChkaXJzKSB7XG4gICAgZm9yICh2YXIga2V5IGluIGRpcnMpIHtcbiAgICAgIHZhciBkZWYgPSBkaXJzW2tleV07XG4gICAgICBpZiAodHlwZW9mIGRlZiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBkaXJzW2tleV0gPSB7IGJpbmQ6IGRlZiwgdXBkYXRlOiBkZWYgfTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBNZXJnZSB0d28gb3B0aW9uIG9iamVjdHMgaW50byBhIG5ldyBvbmUuXG4gKiBDb3JlIHV0aWxpdHkgdXNlZCBpbiBib3RoIGluc3RhbnRpYXRpb24gYW5kIGluaGVyaXRhbmNlLlxuICovXG5mdW5jdGlvbiBtZXJnZU9wdGlvbnMgKFxuICBwYXJlbnQsXG4gIGNoaWxkLFxuICB2bVxuKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgY2hlY2tDb21wb25lbnRzKGNoaWxkKTtcbiAgfVxuICBub3JtYWxpemVQcm9wcyhjaGlsZCk7XG4gIG5vcm1hbGl6ZURpcmVjdGl2ZXMoY2hpbGQpO1xuICB2YXIgZXh0ZW5kc0Zyb20gPSBjaGlsZC5leHRlbmRzO1xuICBpZiAoZXh0ZW5kc0Zyb20pIHtcbiAgICBwYXJlbnQgPSB0eXBlb2YgZXh0ZW5kc0Zyb20gPT09ICdmdW5jdGlvbidcbiAgICAgID8gbWVyZ2VPcHRpb25zKHBhcmVudCwgZXh0ZW5kc0Zyb20ub3B0aW9ucywgdm0pXG4gICAgICA6IG1lcmdlT3B0aW9ucyhwYXJlbnQsIGV4dGVuZHNGcm9tLCB2bSk7XG4gIH1cbiAgaWYgKGNoaWxkLm1peGlucykge1xuICAgIGZvciAodmFyIGkgPSAwLCBsID0gY2hpbGQubWl4aW5zLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgdmFyIG1peGluID0gY2hpbGQubWl4aW5zW2ldO1xuICAgICAgaWYgKG1peGluLnByb3RvdHlwZSBpbnN0YW5jZW9mIFZ1ZSQyKSB7XG4gICAgICAgIG1peGluID0gbWl4aW4ub3B0aW9ucztcbiAgICAgIH1cbiAgICAgIHBhcmVudCA9IG1lcmdlT3B0aW9ucyhwYXJlbnQsIG1peGluLCB2bSk7XG4gICAgfVxuICB9XG4gIHZhciBvcHRpb25zID0ge307XG4gIHZhciBrZXk7XG4gIGZvciAoa2V5IGluIHBhcmVudCkge1xuICAgIG1lcmdlRmllbGQoa2V5KTtcbiAgfVxuICBmb3IgKGtleSBpbiBjaGlsZCkge1xuICAgIGlmICghaGFzT3duKHBhcmVudCwga2V5KSkge1xuICAgICAgbWVyZ2VGaWVsZChrZXkpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBtZXJnZUZpZWxkIChrZXkpIHtcbiAgICB2YXIgc3RyYXQgPSBzdHJhdHNba2V5XSB8fCBkZWZhdWx0U3RyYXQ7XG4gICAgb3B0aW9uc1trZXldID0gc3RyYXQocGFyZW50W2tleV0sIGNoaWxkW2tleV0sIHZtLCBrZXkpO1xuICB9XG4gIHJldHVybiBvcHRpb25zXG59XG5cbi8qKlxuICogUmVzb2x2ZSBhbiBhc3NldC5cbiAqIFRoaXMgZnVuY3Rpb24gaXMgdXNlZCBiZWNhdXNlIGNoaWxkIGluc3RhbmNlcyBuZWVkIGFjY2Vzc1xuICogdG8gYXNzZXRzIGRlZmluZWQgaW4gaXRzIGFuY2VzdG9yIGNoYWluLlxuICovXG5mdW5jdGlvbiByZXNvbHZlQXNzZXQgKFxuICBvcHRpb25zLFxuICB0eXBlLFxuICBpZCxcbiAgd2Fybk1pc3Npbmdcbikge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKHR5cGVvZiBpZCAhPT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm5cbiAgfVxuICB2YXIgYXNzZXRzID0gb3B0aW9uc1t0eXBlXTtcbiAgdmFyIHJlcyA9IGFzc2V0c1tpZF0gfHxcbiAgICAvLyBjYW1lbENhc2UgSURcbiAgICBhc3NldHNbY2FtZWxpemUoaWQpXSB8fFxuICAgIC8vIFBhc2NhbCBDYXNlIElEXG4gICAgYXNzZXRzW2NhcGl0YWxpemUoY2FtZWxpemUoaWQpKV07XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm5NaXNzaW5nICYmICFyZXMpIHtcbiAgICB3YXJuKFxuICAgICAgJ0ZhaWxlZCB0byByZXNvbHZlICcgKyB0eXBlLnNsaWNlKDAsIC0xKSArICc6ICcgKyBpZCxcbiAgICAgIG9wdGlvbnNcbiAgICApO1xuICB9XG4gIHJldHVybiByZXNcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIHZhbGlkYXRlUHJvcCAoXG4gIGtleSxcbiAgcHJvcE9wdGlvbnMsXG4gIHByb3BzRGF0YSxcbiAgdm1cbikge1xuICB2YXIgcHJvcCA9IHByb3BPcHRpb25zW2tleV07XG4gIHZhciBhYnNlbnQgPSAhaGFzT3duKHByb3BzRGF0YSwga2V5KTtcbiAgdmFyIHZhbHVlID0gcHJvcHNEYXRhW2tleV07XG4gIC8vIGhhbmRsZSBib29sZWFuIHByb3BzXG4gIGlmIChpc0Jvb2xlYW5UeXBlKHByb3AudHlwZSkpIHtcbiAgICBpZiAoYWJzZW50ICYmICFoYXNPd24ocHJvcCwgJ2RlZmF1bHQnKSkge1xuICAgICAgdmFsdWUgPSBmYWxzZTtcbiAgICB9IGVsc2UgaWYgKHZhbHVlID09PSAnJyB8fCB2YWx1ZSA9PT0gaHlwaGVuYXRlKGtleSkpIHtcbiAgICAgIHZhbHVlID0gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgLy8gY2hlY2sgZGVmYXVsdCB2YWx1ZVxuICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgIHZhbHVlID0gZ2V0UHJvcERlZmF1bHRWYWx1ZSh2bSwgcHJvcCwga2V5KTtcbiAgICAvLyBzaW5jZSB0aGUgZGVmYXVsdCB2YWx1ZSBpcyBhIGZyZXNoIGNvcHksXG4gICAgLy8gbWFrZSBzdXJlIHRvIG9ic2VydmUgaXQuXG4gICAgdmFyIHByZXZTaG91bGRDb252ZXJ0ID0gb2JzZXJ2ZXJTdGF0ZS5zaG91bGRDb252ZXJ0O1xuICAgIG9ic2VydmVyU3RhdGUuc2hvdWxkQ29udmVydCA9IHRydWU7XG4gICAgb2JzZXJ2ZSh2YWx1ZSk7XG4gICAgb2JzZXJ2ZXJTdGF0ZS5zaG91bGRDb252ZXJ0ID0gcHJldlNob3VsZENvbnZlcnQ7XG4gIH1cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBhc3NlcnRQcm9wKHByb3AsIGtleSwgdmFsdWUsIHZtLCBhYnNlbnQpO1xuICB9XG4gIHJldHVybiB2YWx1ZVxufVxuXG4vKipcbiAqIEdldCB0aGUgZGVmYXVsdCB2YWx1ZSBvZiBhIHByb3AuXG4gKi9cbmZ1bmN0aW9uIGdldFByb3BEZWZhdWx0VmFsdWUgKHZtLCBwcm9wLCBrZXkpIHtcbiAgLy8gbm8gZGVmYXVsdCwgcmV0dXJuIHVuZGVmaW5lZFxuICBpZiAoIWhhc093bihwcm9wLCAnZGVmYXVsdCcpKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZFxuICB9XG4gIHZhciBkZWYgPSBwcm9wLmRlZmF1bHQ7XG4gIC8vIHdhcm4gYWdhaW5zdCBub24tZmFjdG9yeSBkZWZhdWx0cyBmb3IgT2JqZWN0ICYgQXJyYXlcbiAgaWYgKGlzT2JqZWN0KGRlZikpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXG4gICAgICAnSW52YWxpZCBkZWZhdWx0IHZhbHVlIGZvciBwcm9wIFwiJyArIGtleSArICdcIjogJyArXG4gICAgICAnUHJvcHMgd2l0aCB0eXBlIE9iamVjdC9BcnJheSBtdXN0IHVzZSBhIGZhY3RvcnkgZnVuY3Rpb24gJyArXG4gICAgICAndG8gcmV0dXJuIHRoZSBkZWZhdWx0IHZhbHVlLicsXG4gICAgICB2bVxuICAgICk7XG4gIH1cbiAgLy8gdGhlIHJhdyBwcm9wIHZhbHVlIHdhcyBhbHNvIHVuZGVmaW5lZCBmcm9tIHByZXZpb3VzIHJlbmRlcixcbiAgLy8gcmV0dXJuIHByZXZpb3VzIGRlZmF1bHQgdmFsdWUgdG8gYXZvaWQgdW5uZWNlc3Nhcnkgd2F0Y2hlciB0cmlnZ2VyXG4gIGlmICh2bSAmJiB2bS4kb3B0aW9ucy5wcm9wc0RhdGEgJiZcbiAgICB2bS4kb3B0aW9ucy5wcm9wc0RhdGFba2V5XSA9PT0gdW5kZWZpbmVkICYmXG4gICAgdm1ba2V5XSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIHZtW2tleV1cbiAgfVxuICAvLyBjYWxsIGZhY3RvcnkgZnVuY3Rpb24gZm9yIG5vbi1GdW5jdGlvbiB0eXBlc1xuICByZXR1cm4gdHlwZW9mIGRlZiA9PT0gJ2Z1bmN0aW9uJyAmJiBwcm9wLnR5cGUgIT09IEZ1bmN0aW9uXG4gICAgPyBkZWYuY2FsbCh2bSlcbiAgICA6IGRlZlxufVxuXG4vKipcbiAqIEFzc2VydCB3aGV0aGVyIGEgcHJvcCBpcyB2YWxpZC5cbiAqL1xuZnVuY3Rpb24gYXNzZXJ0UHJvcCAoXG4gIHByb3AsXG4gIG5hbWUsXG4gIHZhbHVlLFxuICB2bSxcbiAgYWJzZW50XG4pIHtcbiAgaWYgKHByb3AucmVxdWlyZWQgJiYgYWJzZW50KSB7XG4gICAgd2FybihcbiAgICAgICdNaXNzaW5nIHJlcXVpcmVkIHByb3A6IFwiJyArIG5hbWUgKyAnXCInLFxuICAgICAgdm1cbiAgICApO1xuICAgIHJldHVyblxuICB9XG4gIGlmICh2YWx1ZSA9PSBudWxsICYmICFwcm9wLnJlcXVpcmVkKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgdmFyIHR5cGUgPSBwcm9wLnR5cGU7XG4gIHZhciB2YWxpZCA9ICF0eXBlIHx8IHR5cGUgPT09IHRydWU7XG4gIHZhciBleHBlY3RlZFR5cGVzID0gW107XG4gIGlmICh0eXBlKSB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHR5cGUpKSB7XG4gICAgICB0eXBlID0gW3R5cGVdO1xuICAgIH1cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHR5cGUubGVuZ3RoICYmICF2YWxpZDsgaSsrKSB7XG4gICAgICB2YXIgYXNzZXJ0ZWRUeXBlID0gYXNzZXJ0VHlwZSh2YWx1ZSwgdHlwZVtpXSk7XG4gICAgICBleHBlY3RlZFR5cGVzLnB1c2goYXNzZXJ0ZWRUeXBlLmV4cGVjdGVkVHlwZSk7XG4gICAgICB2YWxpZCA9IGFzc2VydGVkVHlwZS52YWxpZDtcbiAgICB9XG4gIH1cbiAgaWYgKCF2YWxpZCkge1xuICAgIHdhcm4oXG4gICAgICAnSW52YWxpZCBwcm9wOiB0eXBlIGNoZWNrIGZhaWxlZCBmb3IgcHJvcCBcIicgKyBuYW1lICsgJ1wiLicgK1xuICAgICAgJyBFeHBlY3RlZCAnICsgZXhwZWN0ZWRUeXBlcy5tYXAoY2FwaXRhbGl6ZSkuam9pbignLCAnKSArXG4gICAgICAnLCBnb3QgJyArIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSkuc2xpY2UoOCwgLTEpICsgJy4nLFxuICAgICAgdm1cbiAgICApO1xuICAgIHJldHVyblxuICB9XG4gIHZhciB2YWxpZGF0b3IgPSBwcm9wLnZhbGlkYXRvcjtcbiAgaWYgKHZhbGlkYXRvcikge1xuICAgIGlmICghdmFsaWRhdG9yKHZhbHVlKSkge1xuICAgICAgd2FybihcbiAgICAgICAgJ0ludmFsaWQgcHJvcDogY3VzdG9tIHZhbGlkYXRvciBjaGVjayBmYWlsZWQgZm9yIHByb3AgXCInICsgbmFtZSArICdcIi4nLFxuICAgICAgICB2bVxuICAgICAgKTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBBc3NlcnQgdGhlIHR5cGUgb2YgYSB2YWx1ZVxuICovXG5mdW5jdGlvbiBhc3NlcnRUeXBlICh2YWx1ZSwgdHlwZSkge1xuICB2YXIgdmFsaWQ7XG4gIHZhciBleHBlY3RlZFR5cGUgPSBnZXRUeXBlKHR5cGUpO1xuICBpZiAoZXhwZWN0ZWRUeXBlID09PSAnU3RyaW5nJykge1xuICAgIHZhbGlkID0gdHlwZW9mIHZhbHVlID09PSAoZXhwZWN0ZWRUeXBlID0gJ3N0cmluZycpO1xuICB9IGVsc2UgaWYgKGV4cGVjdGVkVHlwZSA9PT0gJ051bWJlcicpIHtcbiAgICB2YWxpZCA9IHR5cGVvZiB2YWx1ZSA9PT0gKGV4cGVjdGVkVHlwZSA9ICdudW1iZXInKTtcbiAgfSBlbHNlIGlmIChleHBlY3RlZFR5cGUgPT09ICdCb29sZWFuJykge1xuICAgIHZhbGlkID0gdHlwZW9mIHZhbHVlID09PSAoZXhwZWN0ZWRUeXBlID0gJ2Jvb2xlYW4nKTtcbiAgfSBlbHNlIGlmIChleHBlY3RlZFR5cGUgPT09ICdGdW5jdGlvbicpIHtcbiAgICB2YWxpZCA9IHR5cGVvZiB2YWx1ZSA9PT0gKGV4cGVjdGVkVHlwZSA9ICdmdW5jdGlvbicpO1xuICB9IGVsc2UgaWYgKGV4cGVjdGVkVHlwZSA9PT0gJ09iamVjdCcpIHtcbiAgICB2YWxpZCA9IGlzUGxhaW5PYmplY3QodmFsdWUpO1xuICB9IGVsc2UgaWYgKGV4cGVjdGVkVHlwZSA9PT0gJ0FycmF5Jykge1xuICAgIHZhbGlkID0gQXJyYXkuaXNBcnJheSh2YWx1ZSk7XG4gIH0gZWxzZSB7XG4gICAgdmFsaWQgPSB2YWx1ZSBpbnN0YW5jZW9mIHR5cGU7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB2YWxpZDogdmFsaWQsXG4gICAgZXhwZWN0ZWRUeXBlOiBleHBlY3RlZFR5cGVcbiAgfVxufVxuXG4vKipcbiAqIFVzZSBmdW5jdGlvbiBzdHJpbmcgbmFtZSB0byBjaGVjayBidWlsdC1pbiB0eXBlcyxcbiAqIGJlY2F1c2UgYSBzaW1wbGUgZXF1YWxpdHkgY2hlY2sgd2lsbCBmYWlsIHdoZW4gcnVubmluZ1xuICogYWNyb3NzIGRpZmZlcmVudCB2bXMgLyBpZnJhbWVzLlxuICovXG5mdW5jdGlvbiBnZXRUeXBlIChmbikge1xuICB2YXIgbWF0Y2ggPSBmbiAmJiBmbi50b1N0cmluZygpLm1hdGNoKC9eXFxzKmZ1bmN0aW9uIChcXHcrKS8pO1xuICByZXR1cm4gbWF0Y2ggJiYgbWF0Y2hbMV1cbn1cblxuZnVuY3Rpb24gaXNCb29sZWFuVHlwZSAoZm4pIHtcbiAgaWYgKCFBcnJheS5pc0FycmF5KGZuKSkge1xuICAgIHJldHVybiBnZXRUeXBlKGZuKSA9PT0gJ0Jvb2xlYW4nXG4gIH1cbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGZuLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgaWYgKGdldFR5cGUoZm5baV0pID09PSAnQm9vbGVhbicpIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICB9XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIHJldHVybiBmYWxzZVxufVxuXG5cblxudmFyIHV0aWwgPSBPYmplY3QuZnJlZXplKHtcblx0ZGVmaW5lUmVhY3RpdmU6IGRlZmluZVJlYWN0aXZlJCQxLFxuXHRfdG9TdHJpbmc6IF90b1N0cmluZyxcblx0dG9OdW1iZXI6IHRvTnVtYmVyLFxuXHRtYWtlTWFwOiBtYWtlTWFwLFxuXHRpc0J1aWx0SW5UYWc6IGlzQnVpbHRJblRhZyxcblx0cmVtb3ZlOiByZW1vdmUkMSxcblx0aGFzT3duOiBoYXNPd24sXG5cdGlzUHJpbWl0aXZlOiBpc1ByaW1pdGl2ZSxcblx0Y2FjaGVkOiBjYWNoZWQsXG5cdGNhbWVsaXplOiBjYW1lbGl6ZSxcblx0Y2FwaXRhbGl6ZTogY2FwaXRhbGl6ZSxcblx0aHlwaGVuYXRlOiBoeXBoZW5hdGUsXG5cdGJpbmQ6IGJpbmQkMSxcblx0dG9BcnJheTogdG9BcnJheSxcblx0ZXh0ZW5kOiBleHRlbmQsXG5cdGlzT2JqZWN0OiBpc09iamVjdCxcblx0aXNQbGFpbk9iamVjdDogaXNQbGFpbk9iamVjdCxcblx0dG9PYmplY3Q6IHRvT2JqZWN0LFxuXHRub29wOiBub29wLFxuXHRubzogbm8sXG5cdGdlblN0YXRpY0tleXM6IGdlblN0YXRpY0tleXMsXG5cdGxvb3NlRXF1YWw6IGxvb3NlRXF1YWwsXG5cdGxvb3NlSW5kZXhPZjogbG9vc2VJbmRleE9mLFxuXHRpc1Jlc2VydmVkOiBpc1Jlc2VydmVkLFxuXHRkZWY6IGRlZixcblx0cGFyc2VQYXRoOiBwYXJzZVBhdGgsXG5cdGhhc1Byb3RvOiBoYXNQcm90byxcblx0aW5Ccm93c2VyOiBpbkJyb3dzZXIsXG5cdFVBOiBVQSxcblx0aXNJRTogaXNJRSxcblx0aXNJRTk6IGlzSUU5LFxuXHRpc0VkZ2U6IGlzRWRnZSxcblx0aXNBbmRyb2lkOiBpc0FuZHJvaWQsXG5cdGlzSU9TOiBpc0lPUyxcblx0ZGV2dG9vbHM6IGRldnRvb2xzLFxuXHRuZXh0VGljazogbmV4dFRpY2ssXG5cdGdldCBfU2V0ICgpIHsgcmV0dXJuIF9TZXQ7IH0sXG5cdG1lcmdlT3B0aW9uczogbWVyZ2VPcHRpb25zLFxuXHRyZXNvbHZlQXNzZXQ6IHJlc29sdmVBc3NldCxcblx0Z2V0IHdhcm4gKCkgeyByZXR1cm4gd2FybjsgfSxcblx0Z2V0IGZvcm1hdENvbXBvbmVudE5hbWUgKCkgeyByZXR1cm4gZm9ybWF0Q29tcG9uZW50TmFtZTsgfSxcblx0dmFsaWRhdGVQcm9wOiB2YWxpZGF0ZVByb3Bcbn0pO1xuXG4vKiAgKi9cblxuZnVuY3Rpb24gaW5pdFVzZSAoVnVlKSB7XG4gIFZ1ZS51c2UgPSBmdW5jdGlvbiAocGx1Z2luKSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKHBsdWdpbi5pbnN0YWxsZWQpIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICAvLyBhZGRpdGlvbmFsIHBhcmFtZXRlcnNcbiAgICB2YXIgYXJncyA9IHRvQXJyYXkoYXJndW1lbnRzLCAxKTtcbiAgICBhcmdzLnVuc2hpZnQodGhpcyk7XG4gICAgaWYgKHR5cGVvZiBwbHVnaW4uaW5zdGFsbCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcGx1Z2luLmluc3RhbGwuYXBwbHkocGx1Z2luLCBhcmdzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcGx1Z2luLmFwcGx5KG51bGwsIGFyZ3MpO1xuICAgIH1cbiAgICBwbHVnaW4uaW5zdGFsbGVkID0gdHJ1ZTtcbiAgICByZXR1cm4gdGhpc1xuICB9O1xufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gaW5pdE1peGluJDEgKFZ1ZSkge1xuICBWdWUubWl4aW4gPSBmdW5jdGlvbiAobWl4aW4pIHtcbiAgICB0aGlzLm9wdGlvbnMgPSBtZXJnZU9wdGlvbnModGhpcy5vcHRpb25zLCBtaXhpbik7XG4gIH07XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBpbml0RXh0ZW5kIChWdWUpIHtcbiAgLyoqXG4gICAqIEVhY2ggaW5zdGFuY2UgY29uc3RydWN0b3IsIGluY2x1ZGluZyBWdWUsIGhhcyBhIHVuaXF1ZVxuICAgKiBjaWQuIFRoaXMgZW5hYmxlcyB1cyB0byBjcmVhdGUgd3JhcHBlZCBcImNoaWxkXG4gICAqIGNvbnN0cnVjdG9yc1wiIGZvciBwcm90b3R5cGFsIGluaGVyaXRhbmNlIGFuZCBjYWNoZSB0aGVtLlxuICAgKi9cbiAgVnVlLmNpZCA9IDA7XG4gIHZhciBjaWQgPSAxO1xuXG4gIC8qKlxuICAgKiBDbGFzcyBpbmhlcml0YW5jZVxuICAgKi9cbiAgVnVlLmV4dGVuZCA9IGZ1bmN0aW9uIChleHRlbmRPcHRpb25zKSB7XG4gICAgZXh0ZW5kT3B0aW9ucyA9IGV4dGVuZE9wdGlvbnMgfHwge307XG4gICAgdmFyIFN1cGVyID0gdGhpcztcbiAgICB2YXIgU3VwZXJJZCA9IFN1cGVyLmNpZDtcbiAgICB2YXIgY2FjaGVkQ3RvcnMgPSBleHRlbmRPcHRpb25zLl9DdG9yIHx8IChleHRlbmRPcHRpb25zLl9DdG9yID0ge30pO1xuICAgIGlmIChjYWNoZWRDdG9yc1tTdXBlcklkXSkge1xuICAgICAgcmV0dXJuIGNhY2hlZEN0b3JzW1N1cGVySWRdXG4gICAgfVxuICAgIHZhciBuYW1lID0gZXh0ZW5kT3B0aW9ucy5uYW1lIHx8IFN1cGVyLm9wdGlvbnMubmFtZTtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgaWYgKCEvXlthLXpBLVpdW1xcdy1dKiQvLnRlc3QobmFtZSkpIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICAnSW52YWxpZCBjb21wb25lbnQgbmFtZTogXCInICsgbmFtZSArICdcIi4gQ29tcG9uZW50IG5hbWVzICcgK1xuICAgICAgICAgICdjYW4gb25seSBjb250YWluIGFscGhhbnVtZXJpYyBjaGFyYWNhdGVycyBhbmQgdGhlIGh5cGhlbi4nXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICAgIHZhciBTdWIgPSBmdW5jdGlvbiBWdWVDb21wb25lbnQgKG9wdGlvbnMpIHtcbiAgICAgIHRoaXMuX2luaXQob3B0aW9ucyk7XG4gICAgfTtcbiAgICBTdWIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShTdXBlci5wcm90b3R5cGUpO1xuICAgIFN1Yi5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBTdWI7XG4gICAgU3ViLmNpZCA9IGNpZCsrO1xuICAgIFN1Yi5vcHRpb25zID0gbWVyZ2VPcHRpb25zKFxuICAgICAgU3VwZXIub3B0aW9ucyxcbiAgICAgIGV4dGVuZE9wdGlvbnNcbiAgICApO1xuICAgIFN1Ylsnc3VwZXInXSA9IFN1cGVyO1xuICAgIC8vIGFsbG93IGZ1cnRoZXIgZXh0ZW5zaW9uL21peGluL3BsdWdpbiB1c2FnZVxuICAgIFN1Yi5leHRlbmQgPSBTdXBlci5leHRlbmQ7XG4gICAgU3ViLm1peGluID0gU3VwZXIubWl4aW47XG4gICAgU3ViLnVzZSA9IFN1cGVyLnVzZTtcbiAgICAvLyBjcmVhdGUgYXNzZXQgcmVnaXN0ZXJzLCBzbyBleHRlbmRlZCBjbGFzc2VzXG4gICAgLy8gY2FuIGhhdmUgdGhlaXIgcHJpdmF0ZSBhc3NldHMgdG9vLlxuICAgIGNvbmZpZy5fYXNzZXRUeXBlcy5mb3JFYWNoKGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICBTdWJbdHlwZV0gPSBTdXBlclt0eXBlXTtcbiAgICB9KTtcbiAgICAvLyBlbmFibGUgcmVjdXJzaXZlIHNlbGYtbG9va3VwXG4gICAgaWYgKG5hbWUpIHtcbiAgICAgIFN1Yi5vcHRpb25zLmNvbXBvbmVudHNbbmFtZV0gPSBTdWI7XG4gICAgfVxuICAgIC8vIGtlZXAgYSByZWZlcmVuY2UgdG8gdGhlIHN1cGVyIG9wdGlvbnMgYXQgZXh0ZW5zaW9uIHRpbWUuXG4gICAgLy8gbGF0ZXIgYXQgaW5zdGFudGlhdGlvbiB3ZSBjYW4gY2hlY2sgaWYgU3VwZXIncyBvcHRpb25zIGhhdmVcbiAgICAvLyBiZWVuIHVwZGF0ZWQuXG4gICAgU3ViLnN1cGVyT3B0aW9ucyA9IFN1cGVyLm9wdGlvbnM7XG4gICAgU3ViLmV4dGVuZE9wdGlvbnMgPSBleHRlbmRPcHRpb25zO1xuICAgIC8vIGNhY2hlIGNvbnN0cnVjdG9yXG4gICAgY2FjaGVkQ3RvcnNbU3VwZXJJZF0gPSBTdWI7XG4gICAgcmV0dXJuIFN1YlxuICB9O1xufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gaW5pdEFzc2V0UmVnaXN0ZXJzIChWdWUpIHtcbiAgLyoqXG4gICAqIENyZWF0ZSBhc3NldCByZWdpc3RyYXRpb24gbWV0aG9kcy5cbiAgICovXG4gIGNvbmZpZy5fYXNzZXRUeXBlcy5mb3JFYWNoKGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgVnVlW3R5cGVdID0gZnVuY3Rpb24gKFxuICAgICAgaWQsXG4gICAgICBkZWZpbml0aW9uXG4gICAgKSB7XG4gICAgICBpZiAoIWRlZmluaXRpb24pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9uc1t0eXBlICsgJ3MnXVtpZF1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgIGlmICh0eXBlID09PSAnY29tcG9uZW50JyAmJiBjb25maWcuaXNSZXNlcnZlZFRhZyhpZCkpIHtcbiAgICAgICAgICAgIHdhcm4oXG4gICAgICAgICAgICAgICdEbyBub3QgdXNlIGJ1aWx0LWluIG9yIHJlc2VydmVkIEhUTUwgZWxlbWVudHMgYXMgY29tcG9uZW50ICcgK1xuICAgICAgICAgICAgICAnaWQ6ICcgKyBpZFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGUgPT09ICdjb21wb25lbnQnICYmIGlzUGxhaW5PYmplY3QoZGVmaW5pdGlvbikpIHtcbiAgICAgICAgICBkZWZpbml0aW9uLm5hbWUgPSBkZWZpbml0aW9uLm5hbWUgfHwgaWQ7XG4gICAgICAgICAgZGVmaW5pdGlvbiA9IHRoaXMub3B0aW9ucy5fYmFzZS5leHRlbmQoZGVmaW5pdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGUgPT09ICdkaXJlY3RpdmUnICYmIHR5cGVvZiBkZWZpbml0aW9uID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgZGVmaW5pdGlvbiA9IHsgYmluZDogZGVmaW5pdGlvbiwgdXBkYXRlOiBkZWZpbml0aW9uIH07XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5vcHRpb25zW3R5cGUgKyAncyddW2lkXSA9IGRlZmluaXRpb247XG4gICAgICAgIHJldHVybiBkZWZpbml0aW9uXG4gICAgICB9XG4gICAgfTtcbiAgfSk7XG59XG5cbnZhciBLZWVwQWxpdmUgPSB7XG4gIG5hbWU6ICdrZWVwLWFsaXZlJyxcbiAgYWJzdHJhY3Q6IHRydWUsXG4gIGNyZWF0ZWQ6IGZ1bmN0aW9uIGNyZWF0ZWQgKCkge1xuICAgIHRoaXMuY2FjaGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICB9LFxuICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlciAoKSB7XG4gICAgdmFyIHZub2RlID0gZ2V0Rmlyc3RDb21wb25lbnRDaGlsZCh0aGlzLiRzbG90cy5kZWZhdWx0KTtcbiAgICBpZiAodm5vZGUgJiYgdm5vZGUuY29tcG9uZW50T3B0aW9ucykge1xuICAgICAgdmFyIG9wdHMgPSB2bm9kZS5jb21wb25lbnRPcHRpb25zO1xuICAgICAgdmFyIGtleSA9IHZub2RlLmtleSA9PSBudWxsXG4gICAgICAgIC8vIHNhbWUgY29uc3RydWN0b3IgbWF5IGdldCByZWdpc3RlcmVkIGFzIGRpZmZlcmVudCBsb2NhbCBjb21wb25lbnRzXG4gICAgICAgIC8vIHNvIGNpZCBhbG9uZSBpcyBub3QgZW5vdWdoICgjMzI2OSlcbiAgICAgICAgPyBvcHRzLkN0b3IuY2lkICsgJzo6JyArIG9wdHMudGFnXG4gICAgICAgIDogdm5vZGUua2V5O1xuICAgICAgaWYgKHRoaXMuY2FjaGVba2V5XSkge1xuICAgICAgICB2bm9kZS5jaGlsZCA9IHRoaXMuY2FjaGVba2V5XS5jaGlsZDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuY2FjaGVba2V5XSA9IHZub2RlO1xuICAgICAgfVxuICAgICAgdm5vZGUuZGF0YS5rZWVwQWxpdmUgPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gdm5vZGVcbiAgfSxcbiAgZGVzdHJveWVkOiBmdW5jdGlvbiBkZXN0cm95ZWQgKCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgZm9yICh2YXIga2V5IGluIHRoaXMuY2FjaGUpIHtcbiAgICAgIHZhciB2bm9kZSA9IHRoaXMkMS5jYWNoZVtrZXldO1xuICAgICAgY2FsbEhvb2sodm5vZGUuY2hpbGQsICdkZWFjdGl2YXRlZCcpO1xuICAgICAgdm5vZGUuY2hpbGQuJGRlc3Ryb3koKTtcbiAgICB9XG4gIH1cbn07XG5cbnZhciBidWlsdEluQ29tcG9uZW50cyA9IHtcbiAgS2VlcEFsaXZlOiBLZWVwQWxpdmVcbn07XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBpbml0R2xvYmFsQVBJIChWdWUpIHtcbiAgLy8gY29uZmlnXG4gIHZhciBjb25maWdEZWYgPSB7fTtcbiAgY29uZmlnRGVmLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvbmZpZzsgfTtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBjb25maWdEZWYuc2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgd2FybihcbiAgICAgICAgJ0RvIG5vdCByZXBsYWNlIHRoZSBWdWUuY29uZmlnIG9iamVjdCwgc2V0IGluZGl2aWR1YWwgZmllbGRzIGluc3RlYWQuJ1xuICAgICAgKTtcbiAgICB9O1xuICB9XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShWdWUsICdjb25maWcnLCBjb25maWdEZWYpO1xuICBWdWUudXRpbCA9IHV0aWw7XG4gIFZ1ZS5zZXQgPSBzZXQ7XG4gIFZ1ZS5kZWxldGUgPSBkZWw7XG4gIFZ1ZS5uZXh0VGljayA9IG5leHRUaWNrO1xuXG4gIFZ1ZS5vcHRpb25zID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgY29uZmlnLl9hc3NldFR5cGVzLmZvckVhY2goZnVuY3Rpb24gKHR5cGUpIHtcbiAgICBWdWUub3B0aW9uc1t0eXBlICsgJ3MnXSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIH0pO1xuXG4gIC8vIHRoaXMgaXMgdXNlZCB0byBpZGVudGlmeSB0aGUgXCJiYXNlXCIgY29uc3RydWN0b3IgdG8gZXh0ZW5kIGFsbCBwbGFpbi1vYmplY3RcbiAgLy8gY29tcG9uZW50cyB3aXRoIGluIFdlZXgncyBtdWx0aS1pbnN0YW5jZSBzY2VuYXJpb3MuXG4gIFZ1ZS5vcHRpb25zLl9iYXNlID0gVnVlO1xuXG4gIGV4dGVuZChWdWUub3B0aW9ucy5jb21wb25lbnRzLCBidWlsdEluQ29tcG9uZW50cyk7XG5cbiAgaW5pdFVzZShWdWUpO1xuICBpbml0TWl4aW4kMShWdWUpO1xuICBpbml0RXh0ZW5kKFZ1ZSk7XG4gIGluaXRBc3NldFJlZ2lzdGVycyhWdWUpO1xufVxuXG5pbml0R2xvYmFsQVBJKFZ1ZSQyKTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFZ1ZSQyLnByb3RvdHlwZSwgJyRpc1NlcnZlcicsIHtcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjb25maWcuX2lzU2VydmVyOyB9XG59KTtcblxuVnVlJDIudmVyc2lvbiA9ICcyLjAuOCc7XG5cbi8qICAqL1xuXG4vLyBhdHRyaWJ1dGVzIHRoYXQgc2hvdWxkIGJlIHVzaW5nIHByb3BzIGZvciBiaW5kaW5nXG52YXIgbXVzdFVzZVByb3AgPSBmdW5jdGlvbiAodGFnLCBhdHRyKSB7XG4gIHJldHVybiAoXG4gICAgKGF0dHIgPT09ICd2YWx1ZScgJiYgKHRhZyA9PT0gJ2lucHV0JyB8fCB0YWcgPT09ICd0ZXh0YXJlYScgfHwgdGFnID09PSAnb3B0aW9uJykpIHx8XG4gICAgKGF0dHIgPT09ICdzZWxlY3RlZCcgJiYgdGFnID09PSAnb3B0aW9uJykgfHxcbiAgICAoYXR0ciA9PT0gJ2NoZWNrZWQnICYmIHRhZyA9PT0gJ2lucHV0JykgfHxcbiAgICAoYXR0ciA9PT0gJ211dGVkJyAmJiB0YWcgPT09ICd2aWRlbycpXG4gIClcbn07XG5cbnZhciBpc0VudW1lcmF0ZWRBdHRyID0gbWFrZU1hcCgnY29udGVudGVkaXRhYmxlLGRyYWdnYWJsZSxzcGVsbGNoZWNrJyk7XG5cbnZhciBpc0Jvb2xlYW5BdHRyID0gbWFrZU1hcChcbiAgJ2FsbG93ZnVsbHNjcmVlbixhc3luYyxhdXRvZm9jdXMsYXV0b3BsYXksY2hlY2tlZCxjb21wYWN0LGNvbnRyb2xzLGRlY2xhcmUsJyArXG4gICdkZWZhdWx0LGRlZmF1bHRjaGVja2VkLGRlZmF1bHRtdXRlZCxkZWZhdWx0c2VsZWN0ZWQsZGVmZXIsZGlzYWJsZWQsJyArXG4gICdlbmFibGVkLGZvcm1ub3ZhbGlkYXRlLGhpZGRlbixpbmRldGVybWluYXRlLGluZXJ0LGlzbWFwLGl0ZW1zY29wZSxsb29wLG11bHRpcGxlLCcgK1xuICAnbXV0ZWQsbm9ocmVmLG5vcmVzaXplLG5vc2hhZGUsbm92YWxpZGF0ZSxub3dyYXAsb3BlbixwYXVzZW9uZXhpdCxyZWFkb25seSwnICtcbiAgJ3JlcXVpcmVkLHJldmVyc2VkLHNjb3BlZCxzZWFtbGVzcyxzZWxlY3RlZCxzb3J0YWJsZSx0cmFuc2xhdGUsJyArXG4gICd0cnVlc3BlZWQsdHlwZW11c3RtYXRjaCx2aXNpYmxlJ1xuKTtcblxudmFyIGlzQXR0ciA9IG1ha2VNYXAoXG4gICdhY2NlcHQsYWNjZXB0LWNoYXJzZXQsYWNjZXNza2V5LGFjdGlvbixhbGlnbixhbHQsYXN5bmMsYXV0b2NvbXBsZXRlLCcgK1xuICAnYXV0b2ZvY3VzLGF1dG9wbGF5LGF1dG9zYXZlLGJnY29sb3IsYm9yZGVyLGJ1ZmZlcmVkLGNoYWxsZW5nZSxjaGFyc2V0LCcgK1xuICAnY2hlY2tlZCxjaXRlLGNsYXNzLGNvZGUsY29kZWJhc2UsY29sb3IsY29scyxjb2xzcGFuLGNvbnRlbnQsaHR0cC1lcXVpdiwnICtcbiAgJ25hbWUsY29udGVudGVkaXRhYmxlLGNvbnRleHRtZW51LGNvbnRyb2xzLGNvb3JkcyxkYXRhLGRhdGV0aW1lLGRlZmF1bHQsJyArXG4gICdkZWZlcixkaXIsZGlybmFtZSxkaXNhYmxlZCxkb3dubG9hZCxkcmFnZ2FibGUsZHJvcHpvbmUsZW5jdHlwZSxtZXRob2QsZm9yLCcgK1xuICAnZm9ybSxmb3JtYWN0aW9uLGhlYWRlcnMsPHRoPixoZWlnaHQsaGlkZGVuLGhpZ2gsaHJlZixocmVmbGFuZyxodHRwLWVxdWl2LCcgK1xuICAnaWNvbixpZCxpc21hcCxpdGVtcHJvcCxrZXl0eXBlLGtpbmQsbGFiZWwsbGFuZyxsYW5ndWFnZSxsaXN0LGxvb3AsbG93LCcgK1xuICAnbWFuaWZlc3QsbWF4LG1heGxlbmd0aCxtZWRpYSxtZXRob2QsR0VULFBPU1QsbWluLG11bHRpcGxlLGVtYWlsLGZpbGUsJyArXG4gICdtdXRlZCxuYW1lLG5vdmFsaWRhdGUsb3BlbixvcHRpbXVtLHBhdHRlcm4scGluZyxwbGFjZWhvbGRlcixwb3N0ZXIsJyArXG4gICdwcmVsb2FkLHJhZGlvZ3JvdXAscmVhZG9ubHkscmVsLHJlcXVpcmVkLHJldmVyc2VkLHJvd3Mscm93c3BhbixzYW5kYm94LCcgK1xuICAnc2NvcGUsc2NvcGVkLHNlYW1sZXNzLHNlbGVjdGVkLHNoYXBlLHNpemUsdHlwZSx0ZXh0LHBhc3N3b3JkLHNpemVzLHNwYW4sJyArXG4gICdzcGVsbGNoZWNrLHNyYyxzcmNkb2Msc3JjbGFuZyxzcmNzZXQsc3RhcnQsc3RlcCxzdHlsZSxzdW1tYXJ5LHRhYmluZGV4LCcgK1xuICAndGFyZ2V0LHRpdGxlLHR5cGUsdXNlbWFwLHZhbHVlLHdpZHRoLHdyYXAnXG4pO1xuXG5cblxudmFyIHhsaW5rTlMgPSAnaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayc7XG5cbnZhciBpc1hsaW5rID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgcmV0dXJuIG5hbWUuY2hhckF0KDUpID09PSAnOicgJiYgbmFtZS5zbGljZSgwLCA1KSA9PT0gJ3hsaW5rJ1xufTtcblxudmFyIGdldFhsaW5rUHJvcCA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gIHJldHVybiBpc1hsaW5rKG5hbWUpID8gbmFtZS5zbGljZSg2LCBuYW1lLmxlbmd0aCkgOiAnJ1xufTtcblxudmFyIGlzRmFsc3lBdHRyVmFsdWUgPSBmdW5jdGlvbiAodmFsKSB7XG4gIHJldHVybiB2YWwgPT0gbnVsbCB8fCB2YWwgPT09IGZhbHNlXG59O1xuXG4vKiAgKi9cblxuZnVuY3Rpb24gZ2VuQ2xhc3NGb3JWbm9kZSAodm5vZGUpIHtcbiAgdmFyIGRhdGEgPSB2bm9kZS5kYXRhO1xuICB2YXIgcGFyZW50Tm9kZSA9IHZub2RlO1xuICB2YXIgY2hpbGROb2RlID0gdm5vZGU7XG4gIHdoaWxlIChjaGlsZE5vZGUuY2hpbGQpIHtcbiAgICBjaGlsZE5vZGUgPSBjaGlsZE5vZGUuY2hpbGQuX3Zub2RlO1xuICAgIGlmIChjaGlsZE5vZGUuZGF0YSkge1xuICAgICAgZGF0YSA9IG1lcmdlQ2xhc3NEYXRhKGNoaWxkTm9kZS5kYXRhLCBkYXRhKTtcbiAgICB9XG4gIH1cbiAgd2hpbGUgKChwYXJlbnROb2RlID0gcGFyZW50Tm9kZS5wYXJlbnQpKSB7XG4gICAgaWYgKHBhcmVudE5vZGUuZGF0YSkge1xuICAgICAgZGF0YSA9IG1lcmdlQ2xhc3NEYXRhKGRhdGEsIHBhcmVudE5vZGUuZGF0YSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBnZW5DbGFzc0Zyb21EYXRhKGRhdGEpXG59XG5cbmZ1bmN0aW9uIG1lcmdlQ2xhc3NEYXRhIChjaGlsZCwgcGFyZW50KSB7XG4gIHJldHVybiB7XG4gICAgc3RhdGljQ2xhc3M6IGNvbmNhdChjaGlsZC5zdGF0aWNDbGFzcywgcGFyZW50LnN0YXRpY0NsYXNzKSxcbiAgICBjbGFzczogY2hpbGQuY2xhc3NcbiAgICAgID8gW2NoaWxkLmNsYXNzLCBwYXJlbnQuY2xhc3NdXG4gICAgICA6IHBhcmVudC5jbGFzc1xuICB9XG59XG5cbmZ1bmN0aW9uIGdlbkNsYXNzRnJvbURhdGEgKGRhdGEpIHtcbiAgdmFyIGR5bmFtaWNDbGFzcyA9IGRhdGEuY2xhc3M7XG4gIHZhciBzdGF0aWNDbGFzcyA9IGRhdGEuc3RhdGljQ2xhc3M7XG4gIGlmIChzdGF0aWNDbGFzcyB8fCBkeW5hbWljQ2xhc3MpIHtcbiAgICByZXR1cm4gY29uY2F0KHN0YXRpY0NsYXNzLCBzdHJpbmdpZnlDbGFzcyhkeW5hbWljQ2xhc3MpKVxuICB9XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIHJldHVybiAnJ1xufVxuXG5mdW5jdGlvbiBjb25jYXQgKGEsIGIpIHtcbiAgcmV0dXJuIGEgPyBiID8gKGEgKyAnICcgKyBiKSA6IGEgOiAoYiB8fCAnJylcbn1cblxuZnVuY3Rpb24gc3RyaW5naWZ5Q2xhc3MgKHZhbHVlKSB7XG4gIHZhciByZXMgPSAnJztcbiAgaWYgKCF2YWx1ZSkge1xuICAgIHJldHVybiByZXNcbiAgfVxuICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiB2YWx1ZVxuICB9XG4gIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgIHZhciBzdHJpbmdpZmllZDtcbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IHZhbHVlLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgaWYgKHZhbHVlW2ldKSB7XG4gICAgICAgIGlmICgoc3RyaW5naWZpZWQgPSBzdHJpbmdpZnlDbGFzcyh2YWx1ZVtpXSkpKSB7XG4gICAgICAgICAgcmVzICs9IHN0cmluZ2lmaWVkICsgJyAnO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXMuc2xpY2UoMCwgLTEpXG4gIH1cbiAgaWYgKGlzT2JqZWN0KHZhbHVlKSkge1xuICAgIGZvciAodmFyIGtleSBpbiB2YWx1ZSkge1xuICAgICAgaWYgKHZhbHVlW2tleV0pIHsgcmVzICs9IGtleSArICcgJzsgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzLnNsaWNlKDAsIC0xKVxuICB9XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIHJldHVybiByZXNcbn1cblxuLyogICovXG5cbnZhciBuYW1lc3BhY2VNYXAgPSB7XG4gIHN2ZzogJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyxcbiAgbWF0aDogJ2h0dHA6Ly93d3cudzMub3JnLzE5OTgvTWF0aC9NYXRoTUwnLFxuICB4aHRtbDogJ2h0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWwnXG59O1xuXG52YXIgaXNIVE1MVGFnID0gbWFrZU1hcChcbiAgJ2h0bWwsYm9keSxiYXNlLGhlYWQsbGluayxtZXRhLHN0eWxlLHRpdGxlLCcgK1xuICAnYWRkcmVzcyxhcnRpY2xlLGFzaWRlLGZvb3RlcixoZWFkZXIsaDEsaDIsaDMsaDQsaDUsaDYsaGdyb3VwLG5hdixzZWN0aW9uLCcgK1xuICAnZGl2LGRkLGRsLGR0LGZpZ2NhcHRpb24sZmlndXJlLGhyLGltZyxsaSxtYWluLG9sLHAscHJlLHVsLCcgK1xuICAnYSxiLGFiYnIsYmRpLGJkbyxicixjaXRlLGNvZGUsZGF0YSxkZm4sZW0saSxrYmQsbWFyayxxLHJwLHJ0LHJ0YyxydWJ5LCcgK1xuICAncyxzYW1wLHNtYWxsLHNwYW4sc3Ryb25nLHN1YixzdXAsdGltZSx1LHZhcix3YnIsYXJlYSxhdWRpbyxtYXAsdHJhY2ssdmlkZW8sJyArXG4gICdlbWJlZCxvYmplY3QscGFyYW0sc291cmNlLGNhbnZhcyxzY3JpcHQsbm9zY3JpcHQsZGVsLGlucywnICtcbiAgJ2NhcHRpb24sY29sLGNvbGdyb3VwLHRhYmxlLHRoZWFkLHRib2R5LHRkLHRoLHRyLCcgK1xuICAnYnV0dG9uLGRhdGFsaXN0LGZpZWxkc2V0LGZvcm0saW5wdXQsbGFiZWwsbGVnZW5kLG1ldGVyLG9wdGdyb3VwLG9wdGlvbiwnICtcbiAgJ291dHB1dCxwcm9ncmVzcyxzZWxlY3QsdGV4dGFyZWEsJyArXG4gICdkZXRhaWxzLGRpYWxvZyxtZW51LG1lbnVpdGVtLHN1bW1hcnksJyArXG4gICdjb250ZW50LGVsZW1lbnQsc2hhZG93LHRlbXBsYXRlJ1xuKTtcblxudmFyIGlzVW5hcnlUYWcgPSBtYWtlTWFwKFxuICAnYXJlYSxiYXNlLGJyLGNvbCxlbWJlZCxmcmFtZSxocixpbWcsaW5wdXQsaXNpbmRleCxrZXlnZW4sJyArXG4gICdsaW5rLG1ldGEscGFyYW0sc291cmNlLHRyYWNrLHdicicsXG4gIHRydWVcbik7XG5cbi8vIEVsZW1lbnRzIHRoYXQgeW91IGNhbiwgaW50ZW50aW9uYWxseSwgbGVhdmUgb3BlblxuLy8gKGFuZCB3aGljaCBjbG9zZSB0aGVtc2VsdmVzKVxudmFyIGNhbkJlTGVmdE9wZW5UYWcgPSBtYWtlTWFwKFxuICAnY29sZ3JvdXAsZGQsZHQsbGksb3B0aW9ucyxwLHRkLHRmb290LHRoLHRoZWFkLHRyLHNvdXJjZScsXG4gIHRydWVcbik7XG5cbi8vIEhUTUw1IHRhZ3MgaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvaW5kaWNlcy5odG1sI2VsZW1lbnRzLTNcbi8vIFBocmFzaW5nIENvbnRlbnQgaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvZG9tLmh0bWwjcGhyYXNpbmctY29udGVudFxudmFyIGlzTm9uUGhyYXNpbmdUYWcgPSBtYWtlTWFwKFxuICAnYWRkcmVzcyxhcnRpY2xlLGFzaWRlLGJhc2UsYmxvY2txdW90ZSxib2R5LGNhcHRpb24sY29sLGNvbGdyb3VwLGRkLCcgK1xuICAnZGV0YWlscyxkaWFsb2csZGl2LGRsLGR0LGZpZWxkc2V0LGZpZ2NhcHRpb24sZmlndXJlLGZvb3Rlcixmb3JtLCcgK1xuICAnaDEsaDIsaDMsaDQsaDUsaDYsaGVhZCxoZWFkZXIsaGdyb3VwLGhyLGh0bWwsbGVnZW5kLGxpLG1lbnVpdGVtLG1ldGEsJyArXG4gICdvcHRncm91cCxvcHRpb24scGFyYW0scnAscnQsc291cmNlLHN0eWxlLHN1bW1hcnksdGJvZHksdGQsdGZvb3QsdGgsdGhlYWQsJyArXG4gICd0aXRsZSx0cix0cmFjaycsXG4gIHRydWVcbik7XG5cbi8vIHRoaXMgbWFwIGlzIGludGVudGlvbmFsbHkgc2VsZWN0aXZlLCBvbmx5IGNvdmVyaW5nIFNWRyBlbGVtZW50cyB0aGF0IG1heVxuLy8gY29udGFpbiBjaGlsZCBlbGVtZW50cy5cbnZhciBpc1NWRyA9IG1ha2VNYXAoXG4gICdzdmcsYW5pbWF0ZSxjaXJjbGUsY2xpcHBhdGgsY3Vyc29yLGRlZnMsZGVzYyxlbGxpcHNlLGZpbHRlcixmb250LCcgK1xuICAnZm9udC1mYWNlLGcsZ2x5cGgsaW1hZ2UsbGluZSxtYXJrZXIsbWFzayxtaXNzaW5nLWdseXBoLHBhdGgscGF0dGVybiwnICtcbiAgJ3BvbHlnb24scG9seWxpbmUscmVjdCxzd2l0Y2gsc3ltYm9sLHRleHQsdGV4dHBhdGgsdHNwYW4sdXNlLHZpZXcnLFxuICB0cnVlXG4pO1xuXG5cblxudmFyIGlzUmVzZXJ2ZWRUYWcgPSBmdW5jdGlvbiAodGFnKSB7XG4gIHJldHVybiBpc0hUTUxUYWcodGFnKSB8fCBpc1NWRyh0YWcpXG59O1xuXG5mdW5jdGlvbiBnZXRUYWdOYW1lc3BhY2UgKHRhZykge1xuICBpZiAoaXNTVkcodGFnKSkge1xuICAgIHJldHVybiAnc3ZnJ1xuICB9XG4gIC8vIGJhc2ljIHN1cHBvcnQgZm9yIE1hdGhNTFxuICAvLyBub3RlIGl0IGRvZXNuJ3Qgc3VwcG9ydCBvdGhlciBNYXRoTUwgZWxlbWVudHMgYmVpbmcgY29tcG9uZW50IHJvb3RzXG4gIGlmICh0YWcgPT09ICdtYXRoJykge1xuICAgIHJldHVybiAnbWF0aCdcbiAgfVxufVxuXG52YXIgdW5rbm93bkVsZW1lbnRDYWNoZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5mdW5jdGlvbiBpc1Vua25vd25FbGVtZW50ICh0YWcpIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmICghaW5Ccm93c2VyKSB7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuICBpZiAoaXNSZXNlcnZlZFRhZyh0YWcpKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbiAgdGFnID0gdGFnLnRvTG93ZXJDYXNlKCk7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAodW5rbm93bkVsZW1lbnRDYWNoZVt0YWddICE9IG51bGwpIHtcbiAgICByZXR1cm4gdW5rbm93bkVsZW1lbnRDYWNoZVt0YWddXG4gIH1cbiAgdmFyIGVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWcpO1xuICBpZiAodGFnLmluZGV4T2YoJy0nKSA+IC0xKSB7XG4gICAgLy8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMjgyMTAzNjQvMTA3MDI0NFxuICAgIHJldHVybiAodW5rbm93bkVsZW1lbnRDYWNoZVt0YWddID0gKFxuICAgICAgZWwuY29uc3RydWN0b3IgPT09IHdpbmRvdy5IVE1MVW5rbm93bkVsZW1lbnQgfHxcbiAgICAgIGVsLmNvbnN0cnVjdG9yID09PSB3aW5kb3cuSFRNTEVsZW1lbnRcbiAgICApKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiAodW5rbm93bkVsZW1lbnRDYWNoZVt0YWddID0gL0hUTUxVbmtub3duRWxlbWVudC8udGVzdChlbC50b1N0cmluZygpKSlcbiAgfVxufVxuXG4vKiAgKi9cblxuLyoqXG4gKiBRdWVyeSBhbiBlbGVtZW50IHNlbGVjdG9yIGlmIGl0J3Mgbm90IGFuIGVsZW1lbnQgYWxyZWFkeS5cbiAqL1xuZnVuY3Rpb24gcXVlcnkgKGVsKSB7XG4gIGlmICh0eXBlb2YgZWwgPT09ICdzdHJpbmcnKSB7XG4gICAgdmFyIHNlbGVjdG9yID0gZWw7XG4gICAgZWwgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKGVsKTtcbiAgICBpZiAoIWVsKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXG4gICAgICAgICdDYW5ub3QgZmluZCBlbGVtZW50OiAnICsgc2VsZWN0b3JcbiAgICAgICk7XG4gICAgICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JylcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGVsXG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBjcmVhdGVFbGVtZW50JDEgKHRhZ05hbWUsIHZub2RlKSB7XG4gIHZhciBlbG0gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZ05hbWUpO1xuICBpZiAodGFnTmFtZSAhPT0gJ3NlbGVjdCcpIHtcbiAgICByZXR1cm4gZWxtXG4gIH1cbiAgaWYgKHZub2RlLmRhdGEgJiYgdm5vZGUuZGF0YS5hdHRycyAmJiAnbXVsdGlwbGUnIGluIHZub2RlLmRhdGEuYXR0cnMpIHtcbiAgICBlbG0uc2V0QXR0cmlidXRlKCdtdWx0aXBsZScsICdtdWx0aXBsZScpO1xuICB9XG4gIHJldHVybiBlbG1cbn1cblxuZnVuY3Rpb24gY3JlYXRlRWxlbWVudE5TIChuYW1lc3BhY2UsIHRhZ05hbWUpIHtcbiAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhuYW1lc3BhY2VNYXBbbmFtZXNwYWNlXSwgdGFnTmFtZSlcbn1cblxuZnVuY3Rpb24gY3JlYXRlVGV4dE5vZGUgKHRleHQpIHtcbiAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHRleHQpXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUNvbW1lbnQgKHRleHQpIHtcbiAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZUNvbW1lbnQodGV4dClcbn1cblxuZnVuY3Rpb24gaW5zZXJ0QmVmb3JlIChwYXJlbnROb2RlLCBuZXdOb2RlLCByZWZlcmVuY2VOb2RlKSB7XG4gIHBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKG5ld05vZGUsIHJlZmVyZW5jZU5vZGUpO1xufVxuXG5mdW5jdGlvbiByZW1vdmVDaGlsZCAobm9kZSwgY2hpbGQpIHtcbiAgbm9kZS5yZW1vdmVDaGlsZChjaGlsZCk7XG59XG5cbmZ1bmN0aW9uIGFwcGVuZENoaWxkIChub2RlLCBjaGlsZCkge1xuICBub2RlLmFwcGVuZENoaWxkKGNoaWxkKTtcbn1cblxuZnVuY3Rpb24gcGFyZW50Tm9kZSAobm9kZSkge1xuICByZXR1cm4gbm9kZS5wYXJlbnROb2RlXG59XG5cbmZ1bmN0aW9uIG5leHRTaWJsaW5nIChub2RlKSB7XG4gIHJldHVybiBub2RlLm5leHRTaWJsaW5nXG59XG5cbmZ1bmN0aW9uIHRhZ05hbWUgKG5vZGUpIHtcbiAgcmV0dXJuIG5vZGUudGFnTmFtZVxufVxuXG5mdW5jdGlvbiBzZXRUZXh0Q29udGVudCAobm9kZSwgdGV4dCkge1xuICBub2RlLnRleHRDb250ZW50ID0gdGV4dDtcbn1cblxuZnVuY3Rpb24gY2hpbGROb2RlcyAobm9kZSkge1xuICByZXR1cm4gbm9kZS5jaGlsZE5vZGVzXG59XG5cbmZ1bmN0aW9uIHNldEF0dHJpYnV0ZSAobm9kZSwga2V5LCB2YWwpIHtcbiAgbm9kZS5zZXRBdHRyaWJ1dGUoa2V5LCB2YWwpO1xufVxuXG5cbnZhciBub2RlT3BzID0gT2JqZWN0LmZyZWV6ZSh7XG5cdGNyZWF0ZUVsZW1lbnQ6IGNyZWF0ZUVsZW1lbnQkMSxcblx0Y3JlYXRlRWxlbWVudE5TOiBjcmVhdGVFbGVtZW50TlMsXG5cdGNyZWF0ZVRleHROb2RlOiBjcmVhdGVUZXh0Tm9kZSxcblx0Y3JlYXRlQ29tbWVudDogY3JlYXRlQ29tbWVudCxcblx0aW5zZXJ0QmVmb3JlOiBpbnNlcnRCZWZvcmUsXG5cdHJlbW92ZUNoaWxkOiByZW1vdmVDaGlsZCxcblx0YXBwZW5kQ2hpbGQ6IGFwcGVuZENoaWxkLFxuXHRwYXJlbnROb2RlOiBwYXJlbnROb2RlLFxuXHRuZXh0U2libGluZzogbmV4dFNpYmxpbmcsXG5cdHRhZ05hbWU6IHRhZ05hbWUsXG5cdHNldFRleHRDb250ZW50OiBzZXRUZXh0Q29udGVudCxcblx0Y2hpbGROb2RlczogY2hpbGROb2Rlcyxcblx0c2V0QXR0cmlidXRlOiBzZXRBdHRyaWJ1dGVcbn0pO1xuXG4vKiAgKi9cblxudmFyIHJlZiA9IHtcbiAgY3JlYXRlOiBmdW5jdGlvbiBjcmVhdGUgKF8sIHZub2RlKSB7XG4gICAgcmVnaXN0ZXJSZWYodm5vZGUpO1xuICB9LFxuICB1cGRhdGU6IGZ1bmN0aW9uIHVwZGF0ZSAob2xkVm5vZGUsIHZub2RlKSB7XG4gICAgaWYgKG9sZFZub2RlLmRhdGEucmVmICE9PSB2bm9kZS5kYXRhLnJlZikge1xuICAgICAgcmVnaXN0ZXJSZWYob2xkVm5vZGUsIHRydWUpO1xuICAgICAgcmVnaXN0ZXJSZWYodm5vZGUpO1xuICAgIH1cbiAgfSxcbiAgZGVzdHJveTogZnVuY3Rpb24gZGVzdHJveSAodm5vZGUpIHtcbiAgICByZWdpc3RlclJlZih2bm9kZSwgdHJ1ZSk7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIHJlZ2lzdGVyUmVmICh2bm9kZSwgaXNSZW1vdmFsKSB7XG4gIHZhciBrZXkgPSB2bm9kZS5kYXRhLnJlZjtcbiAgaWYgKCFrZXkpIHsgcmV0dXJuIH1cblxuICB2YXIgdm0gPSB2bm9kZS5jb250ZXh0O1xuICB2YXIgcmVmID0gdm5vZGUuY2hpbGQgfHwgdm5vZGUuZWxtO1xuICB2YXIgcmVmcyA9IHZtLiRyZWZzO1xuICBpZiAoaXNSZW1vdmFsKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkocmVmc1trZXldKSkge1xuICAgICAgcmVtb3ZlJDEocmVmc1trZXldLCByZWYpO1xuICAgIH0gZWxzZSBpZiAocmVmc1trZXldID09PSByZWYpIHtcbiAgICAgIHJlZnNba2V5XSA9IHVuZGVmaW5lZDtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKHZub2RlLmRhdGEucmVmSW5Gb3IpIHtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHJlZnNba2V5XSkgJiYgcmVmc1trZXldLmluZGV4T2YocmVmKSA8IDApIHtcbiAgICAgICAgcmVmc1trZXldLnB1c2gocmVmKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlZnNba2V5XSA9IFtyZWZdO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICByZWZzW2tleV0gPSByZWY7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogVmlydHVhbCBET00gcGF0Y2hpbmcgYWxnb3JpdGhtIGJhc2VkIG9uIFNuYWJiZG9tIGJ5XG4gKiBTaW1vbiBGcmlpcyBWaW5kdW0gKEBwYWxkZXBpbmQpXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2VcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9wYWxkZXBpbmQvc25hYmJkb20vYmxvYi9tYXN0ZXIvTElDRU5TRVxuICpcbiAqIG1vZGlmaWVkIGJ5IEV2YW4gWW91IChAeXl4OTkwODAzKVxuICpcblxuLypcbiAqIE5vdCB0eXBlLWNoZWNraW5nIHRoaXMgYmVjYXVzZSB0aGlzIGZpbGUgaXMgcGVyZi1jcml0aWNhbCBhbmQgdGhlIGNvc3RcbiAqIG9mIG1ha2luZyBmbG93IHVuZGVyc3RhbmQgaXQgaXMgbm90IHdvcnRoIGl0LlxuICovXG5cbnZhciBlbXB0eU5vZGUgPSBuZXcgVk5vZGUoJycsIHt9LCBbXSk7XG5cbnZhciBob29rcyQxID0gWydjcmVhdGUnLCAndXBkYXRlJywgJ3JlbW92ZScsICdkZXN0cm95J107XG5cbmZ1bmN0aW9uIGlzVW5kZWYgKHMpIHtcbiAgcmV0dXJuIHMgPT0gbnVsbFxufVxuXG5mdW5jdGlvbiBpc0RlZiAocykge1xuICByZXR1cm4gcyAhPSBudWxsXG59XG5cbmZ1bmN0aW9uIHNhbWVWbm9kZSAodm5vZGUxLCB2bm9kZTIpIHtcbiAgcmV0dXJuIChcbiAgICB2bm9kZTEua2V5ID09PSB2bm9kZTIua2V5ICYmXG4gICAgdm5vZGUxLnRhZyA9PT0gdm5vZGUyLnRhZyAmJlxuICAgIHZub2RlMS5pc0NvbW1lbnQgPT09IHZub2RlMi5pc0NvbW1lbnQgJiZcbiAgICAhdm5vZGUxLmRhdGEgPT09ICF2bm9kZTIuZGF0YVxuICApXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUtleVRvT2xkSWR4IChjaGlsZHJlbiwgYmVnaW5JZHgsIGVuZElkeCkge1xuICB2YXIgaSwga2V5O1xuICB2YXIgbWFwID0ge307XG4gIGZvciAoaSA9IGJlZ2luSWR4OyBpIDw9IGVuZElkeDsgKytpKSB7XG4gICAga2V5ID0gY2hpbGRyZW5baV0ua2V5O1xuICAgIGlmIChpc0RlZihrZXkpKSB7IG1hcFtrZXldID0gaTsgfVxuICB9XG4gIHJldHVybiBtYXBcbn1cblxuZnVuY3Rpb24gY3JlYXRlUGF0Y2hGdW5jdGlvbiAoYmFja2VuZCkge1xuICB2YXIgaSwgajtcbiAgdmFyIGNicyA9IHt9O1xuXG4gIHZhciBtb2R1bGVzID0gYmFja2VuZC5tb2R1bGVzO1xuICB2YXIgbm9kZU9wcyA9IGJhY2tlbmQubm9kZU9wcztcblxuICBmb3IgKGkgPSAwOyBpIDwgaG9va3MkMS5sZW5ndGg7ICsraSkge1xuICAgIGNic1tob29rcyQxW2ldXSA9IFtdO1xuICAgIGZvciAoaiA9IDA7IGogPCBtb2R1bGVzLmxlbmd0aDsgKytqKSB7XG4gICAgICBpZiAobW9kdWxlc1tqXVtob29rcyQxW2ldXSAhPT0gdW5kZWZpbmVkKSB7IGNic1tob29rcyQxW2ldXS5wdXNoKG1vZHVsZXNbal1baG9va3MkMVtpXV0pOyB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZW1wdHlOb2RlQXQgKGVsbSkge1xuICAgIHJldHVybiBuZXcgVk5vZGUobm9kZU9wcy50YWdOYW1lKGVsbSkudG9Mb3dlckNhc2UoKSwge30sIFtdLCB1bmRlZmluZWQsIGVsbSlcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZVJtQ2IgKGNoaWxkRWxtLCBsaXN0ZW5lcnMpIHtcbiAgICBmdW5jdGlvbiByZW1vdmUkJDEgKCkge1xuICAgICAgaWYgKC0tcmVtb3ZlJCQxLmxpc3RlbmVycyA9PT0gMCkge1xuICAgICAgICByZW1vdmVFbGVtZW50KGNoaWxkRWxtKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmVtb3ZlJCQxLmxpc3RlbmVycyA9IGxpc3RlbmVycztcbiAgICByZXR1cm4gcmVtb3ZlJCQxXG4gIH1cblxuICBmdW5jdGlvbiByZW1vdmVFbGVtZW50IChlbCkge1xuICAgIHZhciBwYXJlbnQgPSBub2RlT3BzLnBhcmVudE5vZGUoZWwpO1xuICAgIC8vIGVsZW1lbnQgbWF5IGhhdmUgYWxyZWFkeSBiZWVuIHJlbW92ZWQgZHVlIHRvIHYtaHRtbFxuICAgIGlmIChwYXJlbnQpIHtcbiAgICAgIG5vZGVPcHMucmVtb3ZlQ2hpbGQocGFyZW50LCBlbCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlRWxtICh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBuZXN0ZWQpIHtcbiAgICB2YXIgaTtcbiAgICB2YXIgZGF0YSA9IHZub2RlLmRhdGE7XG4gICAgdm5vZGUuaXNSb290SW5zZXJ0ID0gIW5lc3RlZDtcbiAgICBpZiAoaXNEZWYoZGF0YSkpIHtcbiAgICAgIGlmIChpc0RlZihpID0gZGF0YS5ob29rKSAmJiBpc0RlZihpID0gaS5pbml0KSkgeyBpKHZub2RlKTsgfVxuICAgICAgLy8gYWZ0ZXIgY2FsbGluZyB0aGUgaW5pdCBob29rLCBpZiB0aGUgdm5vZGUgaXMgYSBjaGlsZCBjb21wb25lbnRcbiAgICAgIC8vIGl0IHNob3VsZCd2ZSBjcmVhdGVkIGEgY2hpbGQgaW5zdGFuY2UgYW5kIG1vdW50ZWQgaXQuIHRoZSBjaGlsZFxuICAgICAgLy8gY29tcG9uZW50IGFsc28gaGFzIHNldCB0aGUgcGxhY2Vob2xkZXIgdm5vZGUncyBlbG0uXG4gICAgICAvLyBpbiB0aGF0IGNhc2Ugd2UgY2FuIGp1c3QgcmV0dXJuIHRoZSBlbGVtZW50IGFuZCBiZSBkb25lLlxuICAgICAgaWYgKGlzRGVmKGkgPSB2bm9kZS5jaGlsZCkpIHtcbiAgICAgICAgaW5pdENvbXBvbmVudCh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgICAgcmV0dXJuIHZub2RlLmVsbVxuICAgICAgfVxuICAgIH1cbiAgICB2YXIgY2hpbGRyZW4gPSB2bm9kZS5jaGlsZHJlbjtcbiAgICB2YXIgdGFnID0gdm5vZGUudGFnO1xuICAgIGlmIChpc0RlZih0YWcpKSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBpZiAoXG4gICAgICAgICAgIXZub2RlLm5zICYmXG4gICAgICAgICAgIShjb25maWcuaWdub3JlZEVsZW1lbnRzICYmIGNvbmZpZy5pZ25vcmVkRWxlbWVudHMuaW5kZXhPZih0YWcpID4gLTEpICYmXG4gICAgICAgICAgY29uZmlnLmlzVW5rbm93bkVsZW1lbnQodGFnKVxuICAgICAgICApIHtcbiAgICAgICAgICB3YXJuKFxuICAgICAgICAgICAgJ1Vua25vd24gY3VzdG9tIGVsZW1lbnQ6IDwnICsgdGFnICsgJz4gLSBkaWQgeW91ICcgK1xuICAgICAgICAgICAgJ3JlZ2lzdGVyIHRoZSBjb21wb25lbnQgY29ycmVjdGx5PyBGb3IgcmVjdXJzaXZlIGNvbXBvbmVudHMsICcgK1xuICAgICAgICAgICAgJ21ha2Ugc3VyZSB0byBwcm92aWRlIHRoZSBcIm5hbWVcIiBvcHRpb24uJyxcbiAgICAgICAgICAgIHZub2RlLmNvbnRleHRcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB2bm9kZS5lbG0gPSB2bm9kZS5uc1xuICAgICAgICA/IG5vZGVPcHMuY3JlYXRlRWxlbWVudE5TKHZub2RlLm5zLCB0YWcpXG4gICAgICAgIDogbm9kZU9wcy5jcmVhdGVFbGVtZW50KHRhZywgdm5vZGUpO1xuICAgICAgc2V0U2NvcGUodm5vZGUpO1xuICAgICAgY3JlYXRlQ2hpbGRyZW4odm5vZGUsIGNoaWxkcmVuLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgaWYgKGlzRGVmKGRhdGEpKSB7XG4gICAgICAgIGludm9rZUNyZWF0ZUhvb2tzKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodm5vZGUuaXNDb21tZW50KSB7XG4gICAgICB2bm9kZS5lbG0gPSBub2RlT3BzLmNyZWF0ZUNvbW1lbnQodm5vZGUudGV4dCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZub2RlLmVsbSA9IG5vZGVPcHMuY3JlYXRlVGV4dE5vZGUodm5vZGUudGV4dCk7XG4gICAgfVxuICAgIHJldHVybiB2bm9kZS5lbG1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUNoaWxkcmVuICh2bm9kZSwgY2hpbGRyZW4sIGluc2VydGVkVm5vZGVRdWV1ZSkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGNoaWxkcmVuKSkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7ICsraSkge1xuICAgICAgICBub2RlT3BzLmFwcGVuZENoaWxkKHZub2RlLmVsbSwgY3JlYXRlRWxtKGNoaWxkcmVuW2ldLCBpbnNlcnRlZFZub2RlUXVldWUsIHRydWUpKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGlzUHJpbWl0aXZlKHZub2RlLnRleHQpKSB7XG4gICAgICBub2RlT3BzLmFwcGVuZENoaWxkKHZub2RlLmVsbSwgbm9kZU9wcy5jcmVhdGVUZXh0Tm9kZSh2bm9kZS50ZXh0KSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaXNQYXRjaGFibGUgKHZub2RlKSB7XG4gICAgd2hpbGUgKHZub2RlLmNoaWxkKSB7XG4gICAgICB2bm9kZSA9IHZub2RlLmNoaWxkLl92bm9kZTtcbiAgICB9XG4gICAgcmV0dXJuIGlzRGVmKHZub2RlLnRhZylcbiAgfVxuXG4gIGZ1bmN0aW9uIGludm9rZUNyZWF0ZUhvb2tzICh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKSB7XG4gICAgZm9yICh2YXIgaSQxID0gMDsgaSQxIDwgY2JzLmNyZWF0ZS5sZW5ndGg7ICsraSQxKSB7XG4gICAgICBjYnMuY3JlYXRlW2kkMV0oZW1wdHlOb2RlLCB2bm9kZSk7XG4gICAgfVxuICAgIGkgPSB2bm9kZS5kYXRhLmhvb2s7IC8vIFJldXNlIHZhcmlhYmxlXG4gICAgaWYgKGlzRGVmKGkpKSB7XG4gICAgICBpZiAoaS5jcmVhdGUpIHsgaS5jcmVhdGUoZW1wdHlOb2RlLCB2bm9kZSk7IH1cbiAgICAgIGlmIChpLmluc2VydCkgeyBpbnNlcnRlZFZub2RlUXVldWUucHVzaCh2bm9kZSk7IH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBpbml0Q29tcG9uZW50ICh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKSB7XG4gICAgaWYgKHZub2RlLmRhdGEucGVuZGluZ0luc2VydCkge1xuICAgICAgaW5zZXJ0ZWRWbm9kZVF1ZXVlLnB1c2guYXBwbHkoaW5zZXJ0ZWRWbm9kZVF1ZXVlLCB2bm9kZS5kYXRhLnBlbmRpbmdJbnNlcnQpO1xuICAgIH1cbiAgICB2bm9kZS5lbG0gPSB2bm9kZS5jaGlsZC4kZWw7XG4gICAgaWYgKGlzUGF0Y2hhYmxlKHZub2RlKSkge1xuICAgICAgaW52b2tlQ3JlYXRlSG9va3Modm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICBzZXRTY29wZSh2bm9kZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGVtcHR5IGNvbXBvbmVudCByb290LlxuICAgICAgLy8gc2tpcCBhbGwgZWxlbWVudC1yZWxhdGVkIG1vZHVsZXMgZXhjZXB0IGZvciByZWYgKCMzNDU1KVxuICAgICAgcmVnaXN0ZXJSZWYodm5vZGUpO1xuICAgICAgLy8gbWFrZSBzdXJlIHRvIGludm9rZSB0aGUgaW5zZXJ0IGhvb2tcbiAgICAgIGluc2VydGVkVm5vZGVRdWV1ZS5wdXNoKHZub2RlKTtcbiAgICB9XG4gIH1cblxuICAvLyBzZXQgc2NvcGUgaWQgYXR0cmlidXRlIGZvciBzY29wZWQgQ1NTLlxuICAvLyB0aGlzIGlzIGltcGxlbWVudGVkIGFzIGEgc3BlY2lhbCBjYXNlIHRvIGF2b2lkIHRoZSBvdmVyaGVhZFxuICAvLyBvZiBnb2luZyB0aHJvdWdoIHRoZSBub3JtYWwgYXR0cmlidXRlIHBhdGNoaW5nIHByb2Nlc3MuXG4gIGZ1bmN0aW9uIHNldFNjb3BlICh2bm9kZSkge1xuICAgIHZhciBpO1xuICAgIGlmIChpc0RlZihpID0gdm5vZGUuY29udGV4dCkgJiYgaXNEZWYoaSA9IGkuJG9wdGlvbnMuX3Njb3BlSWQpKSB7XG4gICAgICBub2RlT3BzLnNldEF0dHJpYnV0ZSh2bm9kZS5lbG0sIGksICcnKTtcbiAgICB9XG4gICAgaWYgKGlzRGVmKGkgPSBhY3RpdmVJbnN0YW5jZSkgJiZcbiAgICAgICAgaSAhPT0gdm5vZGUuY29udGV4dCAmJlxuICAgICAgICBpc0RlZihpID0gaS4kb3B0aW9ucy5fc2NvcGVJZCkpIHtcbiAgICAgIG5vZGVPcHMuc2V0QXR0cmlidXRlKHZub2RlLmVsbSwgaSwgJycpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGFkZFZub2RlcyAocGFyZW50RWxtLCBiZWZvcmUsIHZub2Rlcywgc3RhcnRJZHgsIGVuZElkeCwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKSB7XG4gICAgZm9yICg7IHN0YXJ0SWR4IDw9IGVuZElkeDsgKytzdGFydElkeCkge1xuICAgICAgbm9kZU9wcy5pbnNlcnRCZWZvcmUocGFyZW50RWxtLCBjcmVhdGVFbG0odm5vZGVzW3N0YXJ0SWR4XSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKSwgYmVmb3JlKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBpbnZva2VEZXN0cm95SG9vayAodm5vZGUpIHtcbiAgICB2YXIgaSwgajtcbiAgICB2YXIgZGF0YSA9IHZub2RlLmRhdGE7XG4gICAgaWYgKGlzRGVmKGRhdGEpKSB7XG4gICAgICBpZiAoaXNEZWYoaSA9IGRhdGEuaG9vaykgJiYgaXNEZWYoaSA9IGkuZGVzdHJveSkpIHsgaSh2bm9kZSk7IH1cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBjYnMuZGVzdHJveS5sZW5ndGg7ICsraSkgeyBjYnMuZGVzdHJveVtpXSh2bm9kZSk7IH1cbiAgICB9XG4gICAgaWYgKGlzRGVmKGkgPSB2bm9kZS5jaGlsZHJlbikpIHtcbiAgICAgIGZvciAoaiA9IDA7IGogPCB2bm9kZS5jaGlsZHJlbi5sZW5ndGg7ICsraikge1xuICAgICAgICBpbnZva2VEZXN0cm95SG9vayh2bm9kZS5jaGlsZHJlbltqXSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVtb3ZlVm5vZGVzIChwYXJlbnRFbG0sIHZub2Rlcywgc3RhcnRJZHgsIGVuZElkeCkge1xuICAgIGZvciAoOyBzdGFydElkeCA8PSBlbmRJZHg7ICsrc3RhcnRJZHgpIHtcbiAgICAgIHZhciBjaCA9IHZub2Rlc1tzdGFydElkeF07XG4gICAgICBpZiAoaXNEZWYoY2gpKSB7XG4gICAgICAgIGlmIChpc0RlZihjaC50YWcpKSB7XG4gICAgICAgICAgcmVtb3ZlQW5kSW52b2tlUmVtb3ZlSG9vayhjaCk7XG4gICAgICAgICAgaW52b2tlRGVzdHJveUhvb2soY2gpO1xuICAgICAgICB9IGVsc2UgeyAvLyBUZXh0IG5vZGVcbiAgICAgICAgICBub2RlT3BzLnJlbW92ZUNoaWxkKHBhcmVudEVsbSwgY2guZWxtKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlbW92ZUFuZEludm9rZVJlbW92ZUhvb2sgKHZub2RlLCBybSkge1xuICAgIGlmIChybSB8fCBpc0RlZih2bm9kZS5kYXRhKSkge1xuICAgICAgdmFyIGxpc3RlbmVycyA9IGNicy5yZW1vdmUubGVuZ3RoICsgMTtcbiAgICAgIGlmICghcm0pIHtcbiAgICAgICAgLy8gZGlyZWN0bHkgcmVtb3ZpbmdcbiAgICAgICAgcm0gPSBjcmVhdGVSbUNiKHZub2RlLmVsbSwgbGlzdGVuZXJzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIHdlIGhhdmUgYSByZWN1cnNpdmVseSBwYXNzZWQgZG93biBybSBjYWxsYmFja1xuICAgICAgICAvLyBpbmNyZWFzZSB0aGUgbGlzdGVuZXJzIGNvdW50XG4gICAgICAgIHJtLmxpc3RlbmVycyArPSBsaXN0ZW5lcnM7XG4gICAgICB9XG4gICAgICAvLyByZWN1cnNpdmVseSBpbnZva2UgaG9va3Mgb24gY2hpbGQgY29tcG9uZW50IHJvb3Qgbm9kZVxuICAgICAgaWYgKGlzRGVmKGkgPSB2bm9kZS5jaGlsZCkgJiYgaXNEZWYoaSA9IGkuX3Zub2RlKSAmJiBpc0RlZihpLmRhdGEpKSB7XG4gICAgICAgIHJlbW92ZUFuZEludm9rZVJlbW92ZUhvb2soaSwgcm0pO1xuICAgICAgfVxuICAgICAgZm9yIChpID0gMDsgaSA8IGNicy5yZW1vdmUubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgY2JzLnJlbW92ZVtpXSh2bm9kZSwgcm0pO1xuICAgICAgfVxuICAgICAgaWYgKGlzRGVmKGkgPSB2bm9kZS5kYXRhLmhvb2spICYmIGlzRGVmKGkgPSBpLnJlbW92ZSkpIHtcbiAgICAgICAgaSh2bm9kZSwgcm0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcm0oKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmVtb3ZlRWxlbWVudCh2bm9kZS5lbG0pO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHVwZGF0ZUNoaWxkcmVuIChwYXJlbnRFbG0sIG9sZENoLCBuZXdDaCwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCByZW1vdmVPbmx5KSB7XG4gICAgdmFyIG9sZFN0YXJ0SWR4ID0gMDtcbiAgICB2YXIgbmV3U3RhcnRJZHggPSAwO1xuICAgIHZhciBvbGRFbmRJZHggPSBvbGRDaC5sZW5ndGggLSAxO1xuICAgIHZhciBvbGRTdGFydFZub2RlID0gb2xkQ2hbMF07XG4gICAgdmFyIG9sZEVuZFZub2RlID0gb2xkQ2hbb2xkRW5kSWR4XTtcbiAgICB2YXIgbmV3RW5kSWR4ID0gbmV3Q2gubGVuZ3RoIC0gMTtcbiAgICB2YXIgbmV3U3RhcnRWbm9kZSA9IG5ld0NoWzBdO1xuICAgIHZhciBuZXdFbmRWbm9kZSA9IG5ld0NoW25ld0VuZElkeF07XG4gICAgdmFyIG9sZEtleVRvSWR4LCBpZHhJbk9sZCwgZWxtVG9Nb3ZlLCBiZWZvcmU7XG5cbiAgICAvLyByZW1vdmVPbmx5IGlzIGEgc3BlY2lhbCBmbGFnIHVzZWQgb25seSBieSA8dHJhbnNpdGlvbi1ncm91cD5cbiAgICAvLyB0byBlbnN1cmUgcmVtb3ZlZCBlbGVtZW50cyBzdGF5IGluIGNvcnJlY3QgcmVsYXRpdmUgcG9zaXRpb25zXG4gICAgLy8gZHVyaW5nIGxlYXZpbmcgdHJhbnNpdGlvbnNcbiAgICB2YXIgY2FuTW92ZSA9ICFyZW1vdmVPbmx5O1xuXG4gICAgd2hpbGUgKG9sZFN0YXJ0SWR4IDw9IG9sZEVuZElkeCAmJiBuZXdTdGFydElkeCA8PSBuZXdFbmRJZHgpIHtcbiAgICAgIGlmIChpc1VuZGVmKG9sZFN0YXJ0Vm5vZGUpKSB7XG4gICAgICAgIG9sZFN0YXJ0Vm5vZGUgPSBvbGRDaFsrK29sZFN0YXJ0SWR4XTsgLy8gVm5vZGUgaGFzIGJlZW4gbW92ZWQgbGVmdFxuICAgICAgfSBlbHNlIGlmIChpc1VuZGVmKG9sZEVuZFZub2RlKSkge1xuICAgICAgICBvbGRFbmRWbm9kZSA9IG9sZENoWy0tb2xkRW5kSWR4XTtcbiAgICAgIH0gZWxzZSBpZiAoc2FtZVZub2RlKG9sZFN0YXJ0Vm5vZGUsIG5ld1N0YXJ0Vm5vZGUpKSB7XG4gICAgICAgIHBhdGNoVm5vZGUob2xkU3RhcnRWbm9kZSwgbmV3U3RhcnRWbm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgICAgb2xkU3RhcnRWbm9kZSA9IG9sZENoWysrb2xkU3RhcnRJZHhdO1xuICAgICAgICBuZXdTdGFydFZub2RlID0gbmV3Q2hbKytuZXdTdGFydElkeF07XG4gICAgICB9IGVsc2UgaWYgKHNhbWVWbm9kZShvbGRFbmRWbm9kZSwgbmV3RW5kVm5vZGUpKSB7XG4gICAgICAgIHBhdGNoVm5vZGUob2xkRW5kVm5vZGUsIG5ld0VuZFZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgICBvbGRFbmRWbm9kZSA9IG9sZENoWy0tb2xkRW5kSWR4XTtcbiAgICAgICAgbmV3RW5kVm5vZGUgPSBuZXdDaFstLW5ld0VuZElkeF07XG4gICAgICB9IGVsc2UgaWYgKHNhbWVWbm9kZShvbGRTdGFydFZub2RlLCBuZXdFbmRWbm9kZSkpIHsgLy8gVm5vZGUgbW92ZWQgcmlnaHRcbiAgICAgICAgcGF0Y2hWbm9kZShvbGRTdGFydFZub2RlLCBuZXdFbmRWbm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgICAgY2FuTW92ZSAmJiBub2RlT3BzLmluc2VydEJlZm9yZShwYXJlbnRFbG0sIG9sZFN0YXJ0Vm5vZGUuZWxtLCBub2RlT3BzLm5leHRTaWJsaW5nKG9sZEVuZFZub2RlLmVsbSkpO1xuICAgICAgICBvbGRTdGFydFZub2RlID0gb2xkQ2hbKytvbGRTdGFydElkeF07XG4gICAgICAgIG5ld0VuZFZub2RlID0gbmV3Q2hbLS1uZXdFbmRJZHhdO1xuICAgICAgfSBlbHNlIGlmIChzYW1lVm5vZGUob2xkRW5kVm5vZGUsIG5ld1N0YXJ0Vm5vZGUpKSB7IC8vIFZub2RlIG1vdmVkIGxlZnRcbiAgICAgICAgcGF0Y2hWbm9kZShvbGRFbmRWbm9kZSwgbmV3U3RhcnRWbm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgICAgY2FuTW92ZSAmJiBub2RlT3BzLmluc2VydEJlZm9yZShwYXJlbnRFbG0sIG9sZEVuZFZub2RlLmVsbSwgb2xkU3RhcnRWbm9kZS5lbG0pO1xuICAgICAgICBvbGRFbmRWbm9kZSA9IG9sZENoWy0tb2xkRW5kSWR4XTtcbiAgICAgICAgbmV3U3RhcnRWbm9kZSA9IG5ld0NoWysrbmV3U3RhcnRJZHhdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGlzVW5kZWYob2xkS2V5VG9JZHgpKSB7IG9sZEtleVRvSWR4ID0gY3JlYXRlS2V5VG9PbGRJZHgob2xkQ2gsIG9sZFN0YXJ0SWR4LCBvbGRFbmRJZHgpOyB9XG4gICAgICAgIGlkeEluT2xkID0gaXNEZWYobmV3U3RhcnRWbm9kZS5rZXkpID8gb2xkS2V5VG9JZHhbbmV3U3RhcnRWbm9kZS5rZXldIDogbnVsbDtcbiAgICAgICAgaWYgKGlzVW5kZWYoaWR4SW5PbGQpKSB7IC8vIE5ldyBlbGVtZW50XG4gICAgICAgICAgbm9kZU9wcy5pbnNlcnRCZWZvcmUocGFyZW50RWxtLCBjcmVhdGVFbG0obmV3U3RhcnRWbm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKSwgb2xkU3RhcnRWbm9kZS5lbG0pO1xuICAgICAgICAgIG5ld1N0YXJ0Vm5vZGUgPSBuZXdDaFsrK25ld1N0YXJ0SWR4XTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBlbG1Ub01vdmUgPSBvbGRDaFtpZHhJbk9sZF07XG4gICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgIWVsbVRvTW92ZSkge1xuICAgICAgICAgICAgd2FybihcbiAgICAgICAgICAgICAgJ0l0IHNlZW1zIHRoZXJlIGFyZSBkdXBsaWNhdGUga2V5cyB0aGF0IGlzIGNhdXNpbmcgYW4gdXBkYXRlIGVycm9yLiAnICtcbiAgICAgICAgICAgICAgJ01ha2Ugc3VyZSBlYWNoIHYtZm9yIGl0ZW0gaGFzIGEgdW5pcXVlIGtleS4nXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoZWxtVG9Nb3ZlLnRhZyAhPT0gbmV3U3RhcnRWbm9kZS50YWcpIHtcbiAgICAgICAgICAgIC8vIHNhbWUga2V5IGJ1dCBkaWZmZXJlbnQgZWxlbWVudC4gdHJlYXQgYXMgbmV3IGVsZW1lbnRcbiAgICAgICAgICAgIG5vZGVPcHMuaW5zZXJ0QmVmb3JlKHBhcmVudEVsbSwgY3JlYXRlRWxtKG5ld1N0YXJ0Vm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSksIG9sZFN0YXJ0Vm5vZGUuZWxtKTtcbiAgICAgICAgICAgIG5ld1N0YXJ0Vm5vZGUgPSBuZXdDaFsrK25ld1N0YXJ0SWR4XTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcGF0Y2hWbm9kZShlbG1Ub01vdmUsIG5ld1N0YXJ0Vm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICAgICAgICBvbGRDaFtpZHhJbk9sZF0gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBjYW5Nb3ZlICYmIG5vZGVPcHMuaW5zZXJ0QmVmb3JlKHBhcmVudEVsbSwgbmV3U3RhcnRWbm9kZS5lbG0sIG9sZFN0YXJ0Vm5vZGUuZWxtKTtcbiAgICAgICAgICAgIG5ld1N0YXJ0Vm5vZGUgPSBuZXdDaFsrK25ld1N0YXJ0SWR4XTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG9sZFN0YXJ0SWR4ID4gb2xkRW5kSWR4KSB7XG4gICAgICBiZWZvcmUgPSBpc1VuZGVmKG5ld0NoW25ld0VuZElkeCArIDFdKSA/IG51bGwgOiBuZXdDaFtuZXdFbmRJZHggKyAxXS5lbG07XG4gICAgICBhZGRWbm9kZXMocGFyZW50RWxtLCBiZWZvcmUsIG5ld0NoLCBuZXdTdGFydElkeCwgbmV3RW5kSWR4LCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgIH0gZWxzZSBpZiAobmV3U3RhcnRJZHggPiBuZXdFbmRJZHgpIHtcbiAgICAgIHJlbW92ZVZub2RlcyhwYXJlbnRFbG0sIG9sZENoLCBvbGRTdGFydElkeCwgb2xkRW5kSWR4KTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBwYXRjaFZub2RlIChvbGRWbm9kZSwgdm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgcmVtb3ZlT25seSkge1xuICAgIGlmIChvbGRWbm9kZSA9PT0gdm5vZGUpIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICAvLyByZXVzZSBlbGVtZW50IGZvciBzdGF0aWMgdHJlZXMuXG4gICAgLy8gbm90ZSB3ZSBvbmx5IGRvIHRoaXMgaWYgdGhlIHZub2RlIGlzIGNsb25lZCAtXG4gICAgLy8gaWYgdGhlIG5ldyBub2RlIGlzIG5vdCBjbG9uZWQgaXQgbWVhbnMgdGhlIHJlbmRlciBmdW5jdGlvbnMgaGF2ZSBiZWVuXG4gICAgLy8gcmVzZXQgYnkgdGhlIGhvdC1yZWxvYWQtYXBpIGFuZCB3ZSBuZWVkIHRvIGRvIGEgcHJvcGVyIHJlLXJlbmRlci5cbiAgICBpZiAodm5vZGUuaXNTdGF0aWMgJiZcbiAgICAgICAgb2xkVm5vZGUuaXNTdGF0aWMgJiZcbiAgICAgICAgdm5vZGUua2V5ID09PSBvbGRWbm9kZS5rZXkgJiZcbiAgICAgICAgKHZub2RlLmlzQ2xvbmVkIHx8IHZub2RlLmlzT25jZSkpIHtcbiAgICAgIHZub2RlLmVsbSA9IG9sZFZub2RlLmVsbTtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICB2YXIgaTtcbiAgICB2YXIgZGF0YSA9IHZub2RlLmRhdGE7XG4gICAgdmFyIGhhc0RhdGEgPSBpc0RlZihkYXRhKTtcbiAgICBpZiAoaGFzRGF0YSAmJiBpc0RlZihpID0gZGF0YS5ob29rKSAmJiBpc0RlZihpID0gaS5wcmVwYXRjaCkpIHtcbiAgICAgIGkob2xkVm5vZGUsIHZub2RlKTtcbiAgICB9XG4gICAgdmFyIGVsbSA9IHZub2RlLmVsbSA9IG9sZFZub2RlLmVsbTtcbiAgICB2YXIgb2xkQ2ggPSBvbGRWbm9kZS5jaGlsZHJlbjtcbiAgICB2YXIgY2ggPSB2bm9kZS5jaGlsZHJlbjtcbiAgICBpZiAoaGFzRGF0YSAmJiBpc1BhdGNoYWJsZSh2bm9kZSkpIHtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBjYnMudXBkYXRlLmxlbmd0aDsgKytpKSB7IGNicy51cGRhdGVbaV0ob2xkVm5vZGUsIHZub2RlKTsgfVxuICAgICAgaWYgKGlzRGVmKGkgPSBkYXRhLmhvb2spICYmIGlzRGVmKGkgPSBpLnVwZGF0ZSkpIHsgaShvbGRWbm9kZSwgdm5vZGUpOyB9XG4gICAgfVxuICAgIGlmIChpc1VuZGVmKHZub2RlLnRleHQpKSB7XG4gICAgICBpZiAoaXNEZWYob2xkQ2gpICYmIGlzRGVmKGNoKSkge1xuICAgICAgICBpZiAob2xkQ2ggIT09IGNoKSB7IHVwZGF0ZUNoaWxkcmVuKGVsbSwgb2xkQ2gsIGNoLCBpbnNlcnRlZFZub2RlUXVldWUsIHJlbW92ZU9ubHkpOyB9XG4gICAgICB9IGVsc2UgaWYgKGlzRGVmKGNoKSkge1xuICAgICAgICBpZiAoaXNEZWYob2xkVm5vZGUudGV4dCkpIHsgbm9kZU9wcy5zZXRUZXh0Q29udGVudChlbG0sICcnKTsgfVxuICAgICAgICBhZGRWbm9kZXMoZWxtLCBudWxsLCBjaCwgMCwgY2gubGVuZ3RoIC0gMSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgIH0gZWxzZSBpZiAoaXNEZWYob2xkQ2gpKSB7XG4gICAgICAgIHJlbW92ZVZub2RlcyhlbG0sIG9sZENoLCAwLCBvbGRDaC5sZW5ndGggLSAxKTtcbiAgICAgIH0gZWxzZSBpZiAoaXNEZWYob2xkVm5vZGUudGV4dCkpIHtcbiAgICAgICAgbm9kZU9wcy5zZXRUZXh0Q29udGVudChlbG0sICcnKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG9sZFZub2RlLnRleHQgIT09IHZub2RlLnRleHQpIHtcbiAgICAgIG5vZGVPcHMuc2V0VGV4dENvbnRlbnQoZWxtLCB2bm9kZS50ZXh0KTtcbiAgICB9XG4gICAgaWYgKGhhc0RhdGEpIHtcbiAgICAgIGlmIChpc0RlZihpID0gZGF0YS5ob29rKSAmJiBpc0RlZihpID0gaS5wb3N0cGF0Y2gpKSB7IGkob2xkVm5vZGUsIHZub2RlKTsgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGludm9rZUluc2VydEhvb2sgKHZub2RlLCBxdWV1ZSwgaW5pdGlhbCkge1xuICAgIC8vIGRlbGF5IGluc2VydCBob29rcyBmb3IgY29tcG9uZW50IHJvb3Qgbm9kZXMsIGludm9rZSB0aGVtIGFmdGVyIHRoZVxuICAgIC8vIGVsZW1lbnQgaXMgcmVhbGx5IGluc2VydGVkXG4gICAgaWYgKGluaXRpYWwgJiYgdm5vZGUucGFyZW50KSB7XG4gICAgICB2bm9kZS5wYXJlbnQuZGF0YS5wZW5kaW5nSW5zZXJ0ID0gcXVldWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcXVldWUubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgcXVldWVbaV0uZGF0YS5ob29rLmluc2VydChxdWV1ZVtpXSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdmFyIGJhaWxlZCA9IGZhbHNlO1xuICBmdW5jdGlvbiBoeWRyYXRlIChlbG0sIHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgaWYgKCFhc3NlcnROb2RlTWF0Y2goZWxtLCB2bm9kZSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG4gICAgfVxuICAgIHZub2RlLmVsbSA9IGVsbTtcbiAgICB2YXIgdGFnID0gdm5vZGUudGFnO1xuICAgIHZhciBkYXRhID0gdm5vZGUuZGF0YTtcbiAgICB2YXIgY2hpbGRyZW4gPSB2bm9kZS5jaGlsZHJlbjtcbiAgICBpZiAoaXNEZWYoZGF0YSkpIHtcbiAgICAgIGlmIChpc0RlZihpID0gZGF0YS5ob29rKSAmJiBpc0RlZihpID0gaS5pbml0KSkgeyBpKHZub2RlLCB0cnVlIC8qIGh5ZHJhdGluZyAqLyk7IH1cbiAgICAgIGlmIChpc0RlZihpID0gdm5vZGUuY2hpbGQpKSB7XG4gICAgICAgIC8vIGNoaWxkIGNvbXBvbmVudC4gaXQgc2hvdWxkIGhhdmUgaHlkcmF0ZWQgaXRzIG93biB0cmVlLlxuICAgICAgICBpbml0Q29tcG9uZW50KHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoaXNEZWYodGFnKSkge1xuICAgICAgaWYgKGlzRGVmKGNoaWxkcmVuKSkge1xuICAgICAgICB2YXIgY2hpbGROb2RlcyA9IG5vZGVPcHMuY2hpbGROb2RlcyhlbG0pO1xuICAgICAgICAvLyBlbXB0eSBlbGVtZW50LCBhbGxvdyBjbGllbnQgdG8gcGljayB1cCBhbmQgcG9wdWxhdGUgY2hpbGRyZW5cbiAgICAgICAgaWYgKCFjaGlsZE5vZGVzLmxlbmd0aCkge1xuICAgICAgICAgIGNyZWF0ZUNoaWxkcmVuKHZub2RlLCBjaGlsZHJlbiwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgY2hpbGRyZW5NYXRjaCA9IHRydWU7XG4gICAgICAgICAgaWYgKGNoaWxkTm9kZXMubGVuZ3RoICE9PSBjaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNoaWxkcmVuTWF0Y2ggPSBmYWxzZTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZm9yICh2YXIgaSQxID0gMDsgaSQxIDwgY2hpbGRyZW4ubGVuZ3RoOyBpJDErKykge1xuICAgICAgICAgICAgICBpZiAoIWh5ZHJhdGUoY2hpbGROb2Rlc1tpJDFdLCBjaGlsZHJlbltpJDFdLCBpbnNlcnRlZFZub2RlUXVldWUpKSB7XG4gICAgICAgICAgICAgICAgY2hpbGRyZW5NYXRjaCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCFjaGlsZHJlbk1hdGNoKSB7XG4gICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJlxuICAgICAgICAgICAgICAgIHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgICAgICAgICAgICFiYWlsZWQpIHtcbiAgICAgICAgICAgICAgYmFpbGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdQYXJlbnQ6ICcsIGVsbSk7XG4gICAgICAgICAgICAgIGNvbnNvbGUud2FybignTWlzbWF0Y2hpbmcgY2hpbGROb2RlcyB2cy4gVk5vZGVzOiAnLCBjaGlsZE5vZGVzLCBjaGlsZHJlbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChpc0RlZihkYXRhKSkge1xuICAgICAgICBpbnZva2VDcmVhdGVIb29rcyh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIGZ1bmN0aW9uIGFzc2VydE5vZGVNYXRjaCAobm9kZSwgdm5vZGUpIHtcbiAgICBpZiAodm5vZGUudGFnKSB7XG4gICAgICByZXR1cm4gKFxuICAgICAgICB2bm9kZS50YWcuaW5kZXhPZigndnVlLWNvbXBvbmVudCcpID09PSAwIHx8XG4gICAgICAgIHZub2RlLnRhZy50b0xvd2VyQ2FzZSgpID09PSBub2RlT3BzLnRhZ05hbWUobm9kZSkudG9Mb3dlckNhc2UoKVxuICAgICAgKVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gX3RvU3RyaW5nKHZub2RlLnRleHQpID09PSBub2RlLmRhdGFcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24gcGF0Y2ggKG9sZFZub2RlLCB2bm9kZSwgaHlkcmF0aW5nLCByZW1vdmVPbmx5KSB7XG4gICAgaWYgKCF2bm9kZSkge1xuICAgICAgaWYgKG9sZFZub2RlKSB7IGludm9rZURlc3Ryb3lIb29rKG9sZFZub2RlKTsgfVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgdmFyIGVsbSwgcGFyZW50O1xuICAgIHZhciBpc0luaXRpYWxQYXRjaCA9IGZhbHNlO1xuICAgIHZhciBpbnNlcnRlZFZub2RlUXVldWUgPSBbXTtcblxuICAgIGlmICghb2xkVm5vZGUpIHtcbiAgICAgIC8vIGVtcHR5IG1vdW50LCBjcmVhdGUgbmV3IHJvb3QgZWxlbWVudFxuICAgICAgaXNJbml0aWFsUGF0Y2ggPSB0cnVlO1xuICAgICAgY3JlYXRlRWxtKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgaXNSZWFsRWxlbWVudCA9IGlzRGVmKG9sZFZub2RlLm5vZGVUeXBlKTtcbiAgICAgIGlmICghaXNSZWFsRWxlbWVudCAmJiBzYW1lVm5vZGUob2xkVm5vZGUsIHZub2RlKSkge1xuICAgICAgICBwYXRjaFZub2RlKG9sZFZub2RlLCB2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCByZW1vdmVPbmx5KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChpc1JlYWxFbGVtZW50KSB7XG4gICAgICAgICAgLy8gbW91bnRpbmcgdG8gYSByZWFsIGVsZW1lbnRcbiAgICAgICAgICAvLyBjaGVjayBpZiB0aGlzIGlzIHNlcnZlci1yZW5kZXJlZCBjb250ZW50IGFuZCBpZiB3ZSBjYW4gcGVyZm9ybVxuICAgICAgICAgIC8vIGEgc3VjY2Vzc2Z1bCBoeWRyYXRpb24uXG4gICAgICAgICAgaWYgKG9sZFZub2RlLm5vZGVUeXBlID09PSAxICYmIG9sZFZub2RlLmhhc0F0dHJpYnV0ZSgnc2VydmVyLXJlbmRlcmVkJykpIHtcbiAgICAgICAgICAgIG9sZFZub2RlLnJlbW92ZUF0dHJpYnV0ZSgnc2VydmVyLXJlbmRlcmVkJyk7XG4gICAgICAgICAgICBoeWRyYXRpbmcgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaHlkcmF0aW5nKSB7XG4gICAgICAgICAgICBpZiAoaHlkcmF0ZShvbGRWbm9kZSwgdm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSkpIHtcbiAgICAgICAgICAgICAgaW52b2tlSW5zZXJ0SG9vayh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCB0cnVlKTtcbiAgICAgICAgICAgICAgcmV0dXJuIG9sZFZub2RlXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAgICAgd2FybihcbiAgICAgICAgICAgICAgICAnVGhlIGNsaWVudC1zaWRlIHJlbmRlcmVkIHZpcnR1YWwgRE9NIHRyZWUgaXMgbm90IG1hdGNoaW5nICcgK1xuICAgICAgICAgICAgICAgICdzZXJ2ZXItcmVuZGVyZWQgY29udGVudC4gVGhpcyBpcyBsaWtlbHkgY2F1c2VkIGJ5IGluY29ycmVjdCAnICtcbiAgICAgICAgICAgICAgICAnSFRNTCBtYXJrdXAsIGZvciBleGFtcGxlIG5lc3RpbmcgYmxvY2stbGV2ZWwgZWxlbWVudHMgaW5zaWRlICcgK1xuICAgICAgICAgICAgICAgICc8cD4sIG9yIG1pc3NpbmcgPHRib2R5Pi4gQmFpbGluZyBoeWRyYXRpb24gYW5kIHBlcmZvcm1pbmcgJyArXG4gICAgICAgICAgICAgICAgJ2Z1bGwgY2xpZW50LXNpZGUgcmVuZGVyLidcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gZWl0aGVyIG5vdCBzZXJ2ZXItcmVuZGVyZWQsIG9yIGh5ZHJhdGlvbiBmYWlsZWQuXG4gICAgICAgICAgLy8gY3JlYXRlIGFuIGVtcHR5IG5vZGUgYW5kIHJlcGxhY2UgaXRcbiAgICAgICAgICBvbGRWbm9kZSA9IGVtcHR5Tm9kZUF0KG9sZFZub2RlKTtcbiAgICAgICAgfVxuICAgICAgICBlbG0gPSBvbGRWbm9kZS5lbG07XG4gICAgICAgIHBhcmVudCA9IG5vZGVPcHMucGFyZW50Tm9kZShlbG0pO1xuXG4gICAgICAgIGNyZWF0ZUVsbSh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcblxuICAgICAgICAvLyBjb21wb25lbnQgcm9vdCBlbGVtZW50IHJlcGxhY2VkLlxuICAgICAgICAvLyB1cGRhdGUgcGFyZW50IHBsYWNlaG9sZGVyIG5vZGUgZWxlbWVudC5cbiAgICAgICAgaWYgKHZub2RlLnBhcmVudCkge1xuICAgICAgICAgIHZub2RlLnBhcmVudC5lbG0gPSB2bm9kZS5lbG07XG4gICAgICAgICAgaWYgKGlzUGF0Y2hhYmxlKHZub2RlKSkge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjYnMuY3JlYXRlLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgIGNicy5jcmVhdGVbaV0oZW1wdHlOb2RlLCB2bm9kZS5wYXJlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwYXJlbnQgIT09IG51bGwpIHtcbiAgICAgICAgICBub2RlT3BzLmluc2VydEJlZm9yZShwYXJlbnQsIHZub2RlLmVsbSwgbm9kZU9wcy5uZXh0U2libGluZyhlbG0pKTtcbiAgICAgICAgICByZW1vdmVWbm9kZXMocGFyZW50LCBbb2xkVm5vZGVdLCAwLCAwKTtcbiAgICAgICAgfSBlbHNlIGlmIChpc0RlZihvbGRWbm9kZS50YWcpKSB7XG4gICAgICAgICAgaW52b2tlRGVzdHJveUhvb2sob2xkVm5vZGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaW52b2tlSW5zZXJ0SG9vayh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBpc0luaXRpYWxQYXRjaCk7XG4gICAgcmV0dXJuIHZub2RlLmVsbVxuICB9XG59XG5cbi8qICAqL1xuXG52YXIgZGlyZWN0aXZlcyA9IHtcbiAgY3JlYXRlOiB1cGRhdGVEaXJlY3RpdmVzLFxuICB1cGRhdGU6IHVwZGF0ZURpcmVjdGl2ZXMsXG4gIGRlc3Ryb3k6IGZ1bmN0aW9uIHVuYmluZERpcmVjdGl2ZXMgKHZub2RlKSB7XG4gICAgdXBkYXRlRGlyZWN0aXZlcyh2bm9kZSwgZW1wdHlOb2RlKTtcbiAgfVxufTtcblxuZnVuY3Rpb24gdXBkYXRlRGlyZWN0aXZlcyAoXG4gIG9sZFZub2RlLFxuICB2bm9kZVxuKSB7XG4gIGlmICghb2xkVm5vZGUuZGF0YS5kaXJlY3RpdmVzICYmICF2bm9kZS5kYXRhLmRpcmVjdGl2ZXMpIHtcbiAgICByZXR1cm5cbiAgfVxuICB2YXIgaXNDcmVhdGUgPSBvbGRWbm9kZSA9PT0gZW1wdHlOb2RlO1xuICB2YXIgb2xkRGlycyA9IG5vcm1hbGl6ZURpcmVjdGl2ZXMkMShvbGRWbm9kZS5kYXRhLmRpcmVjdGl2ZXMsIG9sZFZub2RlLmNvbnRleHQpO1xuICB2YXIgbmV3RGlycyA9IG5vcm1hbGl6ZURpcmVjdGl2ZXMkMSh2bm9kZS5kYXRhLmRpcmVjdGl2ZXMsIHZub2RlLmNvbnRleHQpO1xuXG4gIHZhciBkaXJzV2l0aEluc2VydCA9IFtdO1xuICB2YXIgZGlyc1dpdGhQb3N0cGF0Y2ggPSBbXTtcblxuICB2YXIga2V5LCBvbGREaXIsIGRpcjtcbiAgZm9yIChrZXkgaW4gbmV3RGlycykge1xuICAgIG9sZERpciA9IG9sZERpcnNba2V5XTtcbiAgICBkaXIgPSBuZXdEaXJzW2tleV07XG4gICAgaWYgKCFvbGREaXIpIHtcbiAgICAgIC8vIG5ldyBkaXJlY3RpdmUsIGJpbmRcbiAgICAgIGNhbGxIb29rJDEoZGlyLCAnYmluZCcsIHZub2RlLCBvbGRWbm9kZSk7XG4gICAgICBpZiAoZGlyLmRlZiAmJiBkaXIuZGVmLmluc2VydGVkKSB7XG4gICAgICAgIGRpcnNXaXRoSW5zZXJ0LnB1c2goZGlyKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gZXhpc3RpbmcgZGlyZWN0aXZlLCB1cGRhdGVcbiAgICAgIGRpci5vbGRWYWx1ZSA9IG9sZERpci52YWx1ZTtcbiAgICAgIGNhbGxIb29rJDEoZGlyLCAndXBkYXRlJywgdm5vZGUsIG9sZFZub2RlKTtcbiAgICAgIGlmIChkaXIuZGVmICYmIGRpci5kZWYuY29tcG9uZW50VXBkYXRlZCkge1xuICAgICAgICBkaXJzV2l0aFBvc3RwYXRjaC5wdXNoKGRpcik7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKGRpcnNXaXRoSW5zZXJ0Lmxlbmd0aCkge1xuICAgIHZhciBjYWxsSW5zZXJ0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgZGlyc1dpdGhJbnNlcnQuZm9yRWFjaChmdW5jdGlvbiAoZGlyKSB7XG4gICAgICAgIGNhbGxIb29rJDEoZGlyLCAnaW5zZXJ0ZWQnLCB2bm9kZSwgb2xkVm5vZGUpO1xuICAgICAgfSk7XG4gICAgfTtcbiAgICBpZiAoaXNDcmVhdGUpIHtcbiAgICAgIG1lcmdlVk5vZGVIb29rKHZub2RlLmRhdGEuaG9vayB8fCAodm5vZGUuZGF0YS5ob29rID0ge30pLCAnaW5zZXJ0JywgY2FsbEluc2VydCwgJ2Rpci1pbnNlcnQnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY2FsbEluc2VydCgpO1xuICAgIH1cbiAgfVxuXG4gIGlmIChkaXJzV2l0aFBvc3RwYXRjaC5sZW5ndGgpIHtcbiAgICBtZXJnZVZOb2RlSG9vayh2bm9kZS5kYXRhLmhvb2sgfHwgKHZub2RlLmRhdGEuaG9vayA9IHt9KSwgJ3Bvc3RwYXRjaCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgIGRpcnNXaXRoUG9zdHBhdGNoLmZvckVhY2goZnVuY3Rpb24gKGRpcikge1xuICAgICAgICBjYWxsSG9vayQxKGRpciwgJ2NvbXBvbmVudFVwZGF0ZWQnLCB2bm9kZSwgb2xkVm5vZGUpO1xuICAgICAgfSk7XG4gICAgfSwgJ2Rpci1wb3N0cGF0Y2gnKTtcbiAgfVxuXG4gIGlmICghaXNDcmVhdGUpIHtcbiAgICBmb3IgKGtleSBpbiBvbGREaXJzKSB7XG4gICAgICBpZiAoIW5ld0RpcnNba2V5XSkge1xuICAgICAgICAvLyBubyBsb25nZXIgcHJlc2VudCwgdW5iaW5kXG4gICAgICAgIGNhbGxIb29rJDEob2xkRGlyc1trZXldLCAndW5iaW5kJywgb2xkVm5vZGUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG52YXIgZW1wdHlNb2RpZmllcnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG5mdW5jdGlvbiBub3JtYWxpemVEaXJlY3RpdmVzJDEgKFxuICBkaXJzLFxuICB2bVxuKSB7XG4gIHZhciByZXMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICBpZiAoIWRpcnMpIHtcbiAgICByZXR1cm4gcmVzXG4gIH1cbiAgdmFyIGksIGRpcjtcbiAgZm9yIChpID0gMDsgaSA8IGRpcnMubGVuZ3RoOyBpKyspIHtcbiAgICBkaXIgPSBkaXJzW2ldO1xuICAgIGlmICghZGlyLm1vZGlmaWVycykge1xuICAgICAgZGlyLm1vZGlmaWVycyA9IGVtcHR5TW9kaWZpZXJzO1xuICAgIH1cbiAgICByZXNbZ2V0UmF3RGlyTmFtZShkaXIpXSA9IGRpcjtcbiAgICBkaXIuZGVmID0gcmVzb2x2ZUFzc2V0KHZtLiRvcHRpb25zLCAnZGlyZWN0aXZlcycsIGRpci5uYW1lLCB0cnVlKTtcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbmZ1bmN0aW9uIGdldFJhd0Rpck5hbWUgKGRpcikge1xuICByZXR1cm4gZGlyLnJhd05hbWUgfHwgKChkaXIubmFtZSkgKyBcIi5cIiArIChPYmplY3Qua2V5cyhkaXIubW9kaWZpZXJzIHx8IHt9KS5qb2luKCcuJykpKVxufVxuXG5mdW5jdGlvbiBjYWxsSG9vayQxIChkaXIsIGhvb2ssIHZub2RlLCBvbGRWbm9kZSkge1xuICB2YXIgZm4gPSBkaXIuZGVmICYmIGRpci5kZWZbaG9va107XG4gIGlmIChmbikge1xuICAgIGZuKHZub2RlLmVsbSwgZGlyLCB2bm9kZSwgb2xkVm5vZGUpO1xuICB9XG59XG5cbnZhciBiYXNlTW9kdWxlcyA9IFtcbiAgcmVmLFxuICBkaXJlY3RpdmVzXG5dO1xuXG4vKiAgKi9cblxuZnVuY3Rpb24gdXBkYXRlQXR0cnMgKG9sZFZub2RlLCB2bm9kZSkge1xuICBpZiAoIW9sZFZub2RlLmRhdGEuYXR0cnMgJiYgIXZub2RlLmRhdGEuYXR0cnMpIHtcbiAgICByZXR1cm5cbiAgfVxuICB2YXIga2V5LCBjdXIsIG9sZDtcbiAgdmFyIGVsbSA9IHZub2RlLmVsbTtcbiAgdmFyIG9sZEF0dHJzID0gb2xkVm5vZGUuZGF0YS5hdHRycyB8fCB7fTtcbiAgdmFyIGF0dHJzID0gdm5vZGUuZGF0YS5hdHRycyB8fCB7fTtcbiAgLy8gY2xvbmUgb2JzZXJ2ZWQgb2JqZWN0cywgYXMgdGhlIHVzZXIgcHJvYmFibHkgd2FudHMgdG8gbXV0YXRlIGl0XG4gIGlmIChhdHRycy5fX29iX18pIHtcbiAgICBhdHRycyA9IHZub2RlLmRhdGEuYXR0cnMgPSBleHRlbmQoe30sIGF0dHJzKTtcbiAgfVxuXG4gIGZvciAoa2V5IGluIGF0dHJzKSB7XG4gICAgY3VyID0gYXR0cnNba2V5XTtcbiAgICBvbGQgPSBvbGRBdHRyc1trZXldO1xuICAgIGlmIChvbGQgIT09IGN1cikge1xuICAgICAgc2V0QXR0cihlbG0sIGtleSwgY3VyKTtcbiAgICB9XG4gIH1cbiAgZm9yIChrZXkgaW4gb2xkQXR0cnMpIHtcbiAgICBpZiAoYXR0cnNba2V5XSA9PSBudWxsKSB7XG4gICAgICBpZiAoaXNYbGluayhrZXkpKSB7XG4gICAgICAgIGVsbS5yZW1vdmVBdHRyaWJ1dGVOUyh4bGlua05TLCBnZXRYbGlua1Byb3Aoa2V5KSk7XG4gICAgICB9IGVsc2UgaWYgKCFpc0VudW1lcmF0ZWRBdHRyKGtleSkpIHtcbiAgICAgICAgZWxtLnJlbW92ZUF0dHJpYnV0ZShrZXkpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBzZXRBdHRyIChlbCwga2V5LCB2YWx1ZSkge1xuICBpZiAoaXNCb29sZWFuQXR0cihrZXkpKSB7XG4gICAgLy8gc2V0IGF0dHJpYnV0ZSBmb3IgYmxhbmsgdmFsdWVcbiAgICAvLyBlLmcuIDxvcHRpb24gZGlzYWJsZWQ+U2VsZWN0IG9uZTwvb3B0aW9uPlxuICAgIGlmIChpc0ZhbHN5QXR0clZhbHVlKHZhbHVlKSkge1xuICAgICAgZWwucmVtb3ZlQXR0cmlidXRlKGtleSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsLnNldEF0dHJpYnV0ZShrZXksIGtleSk7XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzRW51bWVyYXRlZEF0dHIoa2V5KSkge1xuICAgIGVsLnNldEF0dHJpYnV0ZShrZXksIGlzRmFsc3lBdHRyVmFsdWUodmFsdWUpIHx8IHZhbHVlID09PSAnZmFsc2UnID8gJ2ZhbHNlJyA6ICd0cnVlJyk7XG4gIH0gZWxzZSBpZiAoaXNYbGluayhrZXkpKSB7XG4gICAgaWYgKGlzRmFsc3lBdHRyVmFsdWUodmFsdWUpKSB7XG4gICAgICBlbC5yZW1vdmVBdHRyaWJ1dGVOUyh4bGlua05TLCBnZXRYbGlua1Byb3Aoa2V5KSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsLnNldEF0dHJpYnV0ZU5TKHhsaW5rTlMsIGtleSwgdmFsdWUpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoaXNGYWxzeUF0dHJWYWx1ZSh2YWx1ZSkpIHtcbiAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZShrZXkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbC5zZXRBdHRyaWJ1dGUoa2V5LCB2YWx1ZSk7XG4gICAgfVxuICB9XG59XG5cbnZhciBhdHRycyA9IHtcbiAgY3JlYXRlOiB1cGRhdGVBdHRycyxcbiAgdXBkYXRlOiB1cGRhdGVBdHRyc1xufTtcblxuLyogICovXG5cbmZ1bmN0aW9uIHVwZGF0ZUNsYXNzIChvbGRWbm9kZSwgdm5vZGUpIHtcbiAgdmFyIGVsID0gdm5vZGUuZWxtO1xuICB2YXIgZGF0YSA9IHZub2RlLmRhdGE7XG4gIHZhciBvbGREYXRhID0gb2xkVm5vZGUuZGF0YTtcbiAgaWYgKCFkYXRhLnN0YXRpY0NsYXNzICYmICFkYXRhLmNsYXNzICYmXG4gICAgICAoIW9sZERhdGEgfHwgKCFvbGREYXRhLnN0YXRpY0NsYXNzICYmICFvbGREYXRhLmNsYXNzKSkpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIHZhciBjbHMgPSBnZW5DbGFzc0ZvclZub2RlKHZub2RlKTtcblxuICAvLyBoYW5kbGUgdHJhbnNpdGlvbiBjbGFzc2VzXG4gIHZhciB0cmFuc2l0aW9uQ2xhc3MgPSBlbC5fdHJhbnNpdGlvbkNsYXNzZXM7XG4gIGlmICh0cmFuc2l0aW9uQ2xhc3MpIHtcbiAgICBjbHMgPSBjb25jYXQoY2xzLCBzdHJpbmdpZnlDbGFzcyh0cmFuc2l0aW9uQ2xhc3MpKTtcbiAgfVxuXG4gIC8vIHNldCB0aGUgY2xhc3NcbiAgaWYgKGNscyAhPT0gZWwuX3ByZXZDbGFzcykge1xuICAgIGVsLnNldEF0dHJpYnV0ZSgnY2xhc3MnLCBjbHMpO1xuICAgIGVsLl9wcmV2Q2xhc3MgPSBjbHM7XG4gIH1cbn1cblxudmFyIGtsYXNzID0ge1xuICBjcmVhdGU6IHVwZGF0ZUNsYXNzLFxuICB1cGRhdGU6IHVwZGF0ZUNsYXNzXG59O1xuXG4vLyBza2lwIHR5cGUgY2hlY2tpbmcgdGhpcyBmaWxlIGJlY2F1c2Ugd2UgbmVlZCB0byBhdHRhY2ggcHJpdmF0ZSBwcm9wZXJ0aWVzXG4vLyB0byBlbGVtZW50c1xuXG5mdW5jdGlvbiB1cGRhdGVET01MaXN0ZW5lcnMgKG9sZFZub2RlLCB2bm9kZSkge1xuICBpZiAoIW9sZFZub2RlLmRhdGEub24gJiYgIXZub2RlLmRhdGEub24pIHtcbiAgICByZXR1cm5cbiAgfVxuICB2YXIgb24gPSB2bm9kZS5kYXRhLm9uIHx8IHt9O1xuICB2YXIgb2xkT24gPSBvbGRWbm9kZS5kYXRhLm9uIHx8IHt9O1xuICB2YXIgYWRkID0gdm5vZGUuZWxtLl92X2FkZCB8fCAodm5vZGUuZWxtLl92X2FkZCA9IGZ1bmN0aW9uIChldmVudCwgaGFuZGxlciwgY2FwdHVyZSkge1xuICAgIHZub2RlLmVsbS5hZGRFdmVudExpc3RlbmVyKGV2ZW50LCBoYW5kbGVyLCBjYXB0dXJlKTtcbiAgfSk7XG4gIHZhciByZW1vdmUgPSB2bm9kZS5lbG0uX3ZfcmVtb3ZlIHx8ICh2bm9kZS5lbG0uX3ZfcmVtb3ZlID0gZnVuY3Rpb24gKGV2ZW50LCBoYW5kbGVyKSB7XG4gICAgdm5vZGUuZWxtLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnQsIGhhbmRsZXIpO1xuICB9KTtcbiAgdXBkYXRlTGlzdGVuZXJzKG9uLCBvbGRPbiwgYWRkLCByZW1vdmUsIHZub2RlLmNvbnRleHQpO1xufVxuXG52YXIgZXZlbnRzID0ge1xuICBjcmVhdGU6IHVwZGF0ZURPTUxpc3RlbmVycyxcbiAgdXBkYXRlOiB1cGRhdGVET01MaXN0ZW5lcnNcbn07XG5cbi8qICAqL1xuXG5mdW5jdGlvbiB1cGRhdGVET01Qcm9wcyAob2xkVm5vZGUsIHZub2RlKSB7XG4gIGlmICghb2xkVm5vZGUuZGF0YS5kb21Qcm9wcyAmJiAhdm5vZGUuZGF0YS5kb21Qcm9wcykge1xuICAgIHJldHVyblxuICB9XG4gIHZhciBrZXksIGN1cjtcbiAgdmFyIGVsbSA9IHZub2RlLmVsbTtcbiAgdmFyIG9sZFByb3BzID0gb2xkVm5vZGUuZGF0YS5kb21Qcm9wcyB8fCB7fTtcbiAgdmFyIHByb3BzID0gdm5vZGUuZGF0YS5kb21Qcm9wcyB8fCB7fTtcbiAgLy8gY2xvbmUgb2JzZXJ2ZWQgb2JqZWN0cywgYXMgdGhlIHVzZXIgcHJvYmFibHkgd2FudHMgdG8gbXV0YXRlIGl0XG4gIGlmIChwcm9wcy5fX29iX18pIHtcbiAgICBwcm9wcyA9IHZub2RlLmRhdGEuZG9tUHJvcHMgPSBleHRlbmQoe30sIHByb3BzKTtcbiAgfVxuXG4gIGZvciAoa2V5IGluIG9sZFByb3BzKSB7XG4gICAgaWYgKHByb3BzW2tleV0gPT0gbnVsbCkge1xuICAgICAgZWxtW2tleV0gPSAnJztcbiAgICB9XG4gIH1cbiAgZm9yIChrZXkgaW4gcHJvcHMpIHtcbiAgICBjdXIgPSBwcm9wc1trZXldO1xuICAgIC8vIGlnbm9yZSBjaGlsZHJlbiBpZiB0aGUgbm9kZSBoYXMgdGV4dENvbnRlbnQgb3IgaW5uZXJIVE1MLFxuICAgIC8vIGFzIHRoZXNlIHdpbGwgdGhyb3cgYXdheSBleGlzdGluZyBET00gbm9kZXMgYW5kIGNhdXNlIHJlbW92YWwgZXJyb3JzXG4gICAgLy8gb24gc3Vic2VxdWVudCBwYXRjaGVzICgjMzM2MClcbiAgICBpZiAoa2V5ID09PSAndGV4dENvbnRlbnQnIHx8IGtleSA9PT0gJ2lubmVySFRNTCcpIHtcbiAgICAgIGlmICh2bm9kZS5jaGlsZHJlbikgeyB2bm9kZS5jaGlsZHJlbi5sZW5ndGggPSAwOyB9XG4gICAgICBpZiAoY3VyID09PSBvbGRQcm9wc1trZXldKSB7IGNvbnRpbnVlIH1cbiAgICB9XG4gICAgaWYgKGtleSA9PT0gJ3ZhbHVlJykge1xuICAgICAgLy8gc3RvcmUgdmFsdWUgYXMgX3ZhbHVlIGFzIHdlbGwgc2luY2VcbiAgICAgIC8vIG5vbi1zdHJpbmcgdmFsdWVzIHdpbGwgYmUgc3RyaW5naWZpZWRcbiAgICAgIGVsbS5fdmFsdWUgPSBjdXI7XG4gICAgICAvLyBhdm9pZCByZXNldHRpbmcgY3Vyc29yIHBvc2l0aW9uIHdoZW4gdmFsdWUgaXMgdGhlIHNhbWVcbiAgICAgIHZhciBzdHJDdXIgPSBjdXIgPT0gbnVsbCA/ICcnIDogU3RyaW5nKGN1cik7XG4gICAgICBpZiAoZWxtLnZhbHVlICE9PSBzdHJDdXIgJiYgIWVsbS5jb21wb3NpbmcpIHtcbiAgICAgICAgZWxtLnZhbHVlID0gc3RyQ3VyO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBlbG1ba2V5XSA9IGN1cjtcbiAgICB9XG4gIH1cbn1cblxudmFyIGRvbVByb3BzID0ge1xuICBjcmVhdGU6IHVwZGF0ZURPTVByb3BzLFxuICB1cGRhdGU6IHVwZGF0ZURPTVByb3BzXG59O1xuXG4vKiAgKi9cblxudmFyIHBhcnNlU3R5bGVUZXh0ID0gY2FjaGVkKGZ1bmN0aW9uIChjc3NUZXh0KSB7XG4gIHZhciByZXMgPSB7fTtcbiAgdmFyIGhhc0JhY2tncm91bmQgPSBjc3NUZXh0LmluZGV4T2YoJ2JhY2tncm91bmQnKSA+PSAwO1xuICAvLyBtYXliZSB3aXRoIGJhY2tncm91bmQtaW1hZ2U6IHVybChodHRwOi8veHh4KSBvciBiYXNlNjQgaW1nXG4gIHZhciBsaXN0RGVsaW1pdGVyID0gaGFzQmFja2dyb3VuZCA/IC87KD8hW14oXSpcXCkpL2cgOiAnOyc7XG4gIHZhciBwcm9wZXJ0eURlbGltaXRlciA9IGhhc0JhY2tncm91bmQgPyAvOiguKykvIDogJzonO1xuICBjc3NUZXh0LnNwbGl0KGxpc3REZWxpbWl0ZXIpLmZvckVhY2goZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICBpZiAoaXRlbSkge1xuICAgICAgdmFyIHRtcCA9IGl0ZW0uc3BsaXQocHJvcGVydHlEZWxpbWl0ZXIpO1xuICAgICAgdG1wLmxlbmd0aCA+IDEgJiYgKHJlc1t0bXBbMF0udHJpbSgpXSA9IHRtcFsxXS50cmltKCkpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiByZXNcbn0pO1xuXG4vLyBtZXJnZSBzdGF0aWMgYW5kIGR5bmFtaWMgc3R5bGUgZGF0YSBvbiB0aGUgc2FtZSB2bm9kZVxuZnVuY3Rpb24gbm9ybWFsaXplU3R5bGVEYXRhIChkYXRhKSB7XG4gIHZhciBzdHlsZSA9IG5vcm1hbGl6ZVN0eWxlQmluZGluZyhkYXRhLnN0eWxlKTtcbiAgLy8gc3RhdGljIHN0eWxlIGlzIHByZS1wcm9jZXNzZWQgaW50byBhbiBvYmplY3QgZHVyaW5nIGNvbXBpbGF0aW9uXG4gIC8vIGFuZCBpcyBhbHdheXMgYSBmcmVzaCBvYmplY3QsIHNvIGl0J3Mgc2FmZSB0byBtZXJnZSBpbnRvIGl0XG4gIHJldHVybiBkYXRhLnN0YXRpY1N0eWxlXG4gICAgPyBleHRlbmQoZGF0YS5zdGF0aWNTdHlsZSwgc3R5bGUpXG4gICAgOiBzdHlsZVxufVxuXG4vLyBub3JtYWxpemUgcG9zc2libGUgYXJyYXkgLyBzdHJpbmcgdmFsdWVzIGludG8gT2JqZWN0XG5mdW5jdGlvbiBub3JtYWxpemVTdHlsZUJpbmRpbmcgKGJpbmRpbmdTdHlsZSkge1xuICBpZiAoQXJyYXkuaXNBcnJheShiaW5kaW5nU3R5bGUpKSB7XG4gICAgcmV0dXJuIHRvT2JqZWN0KGJpbmRpbmdTdHlsZSlcbiAgfVxuICBpZiAodHlwZW9mIGJpbmRpbmdTdHlsZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gcGFyc2VTdHlsZVRleHQoYmluZGluZ1N0eWxlKVxuICB9XG4gIHJldHVybiBiaW5kaW5nU3R5bGVcbn1cblxuLyoqXG4gKiBwYXJlbnQgY29tcG9uZW50IHN0eWxlIHNob3VsZCBiZSBhZnRlciBjaGlsZCdzXG4gKiBzbyB0aGF0IHBhcmVudCBjb21wb25lbnQncyBzdHlsZSBjb3VsZCBvdmVycmlkZSBpdFxuICovXG5mdW5jdGlvbiBnZXRTdHlsZSAodm5vZGUsIGNoZWNrQ2hpbGQpIHtcbiAgdmFyIHJlcyA9IHt9O1xuICB2YXIgc3R5bGVEYXRhO1xuXG4gIGlmIChjaGVja0NoaWxkKSB7XG4gICAgdmFyIGNoaWxkTm9kZSA9IHZub2RlO1xuICAgIHdoaWxlIChjaGlsZE5vZGUuY2hpbGQpIHtcbiAgICAgIGNoaWxkTm9kZSA9IGNoaWxkTm9kZS5jaGlsZC5fdm5vZGU7XG4gICAgICBpZiAoY2hpbGROb2RlLmRhdGEgJiYgKHN0eWxlRGF0YSA9IG5vcm1hbGl6ZVN0eWxlRGF0YShjaGlsZE5vZGUuZGF0YSkpKSB7XG4gICAgICAgIGV4dGVuZChyZXMsIHN0eWxlRGF0YSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKChzdHlsZURhdGEgPSBub3JtYWxpemVTdHlsZURhdGEodm5vZGUuZGF0YSkpKSB7XG4gICAgZXh0ZW5kKHJlcywgc3R5bGVEYXRhKTtcbiAgfVxuXG4gIHZhciBwYXJlbnROb2RlID0gdm5vZGU7XG4gIHdoaWxlICgocGFyZW50Tm9kZSA9IHBhcmVudE5vZGUucGFyZW50KSkge1xuICAgIGlmIChwYXJlbnROb2RlLmRhdGEgJiYgKHN0eWxlRGF0YSA9IG5vcm1hbGl6ZVN0eWxlRGF0YShwYXJlbnROb2RlLmRhdGEpKSkge1xuICAgICAgZXh0ZW5kKHJlcywgc3R5bGVEYXRhKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG4vKiAgKi9cblxudmFyIGNzc1ZhclJFID0gL14tLS87XG52YXIgc2V0UHJvcCA9IGZ1bmN0aW9uIChlbCwgbmFtZSwgdmFsKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoY3NzVmFyUkUudGVzdChuYW1lKSkge1xuICAgIGVsLnN0eWxlLnNldFByb3BlcnR5KG5hbWUsIHZhbCk7XG4gIH0gZWxzZSB7XG4gICAgZWwuc3R5bGVbbm9ybWFsaXplKG5hbWUpXSA9IHZhbDtcbiAgfVxufTtcblxudmFyIHByZWZpeGVzID0gWydXZWJraXQnLCAnTW96JywgJ21zJ107XG5cbnZhciB0ZXN0RWw7XG52YXIgbm9ybWFsaXplID0gY2FjaGVkKGZ1bmN0aW9uIChwcm9wKSB7XG4gIHRlc3RFbCA9IHRlc3RFbCB8fCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgcHJvcCA9IGNhbWVsaXplKHByb3ApO1xuICBpZiAocHJvcCAhPT0gJ2ZpbHRlcicgJiYgKHByb3AgaW4gdGVzdEVsLnN0eWxlKSkge1xuICAgIHJldHVybiBwcm9wXG4gIH1cbiAgdmFyIHVwcGVyID0gcHJvcC5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHByb3Auc2xpY2UoMSk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcHJlZml4ZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgcHJlZml4ZWQgPSBwcmVmaXhlc1tpXSArIHVwcGVyO1xuICAgIGlmIChwcmVmaXhlZCBpbiB0ZXN0RWwuc3R5bGUpIHtcbiAgICAgIHJldHVybiBwcmVmaXhlZFxuICAgIH1cbiAgfVxufSk7XG5cbmZ1bmN0aW9uIHVwZGF0ZVN0eWxlIChvbGRWbm9kZSwgdm5vZGUpIHtcbiAgdmFyIGRhdGEgPSB2bm9kZS5kYXRhO1xuICB2YXIgb2xkRGF0YSA9IG9sZFZub2RlLmRhdGE7XG5cbiAgaWYgKCFkYXRhLnN0YXRpY1N0eWxlICYmICFkYXRhLnN0eWxlICYmXG4gICAgICAhb2xkRGF0YS5zdGF0aWNTdHlsZSAmJiAhb2xkRGF0YS5zdHlsZSkge1xuICAgIHJldHVyblxuICB9XG5cbiAgdmFyIGN1ciwgbmFtZTtcbiAgdmFyIGVsID0gdm5vZGUuZWxtO1xuICB2YXIgb2xkU3RhdGljU3R5bGUgPSBvbGRWbm9kZS5kYXRhLnN0YXRpY1N0eWxlO1xuICB2YXIgb2xkU3R5bGVCaW5kaW5nID0gb2xkVm5vZGUuZGF0YS5zdHlsZSB8fCB7fTtcblxuICAvLyBpZiBzdGF0aWMgc3R5bGUgZXhpc3RzLCBzdHlsZWJpbmRpbmcgYWxyZWFkeSBtZXJnZWQgaW50byBpdCB3aGVuIGRvaW5nIG5vcm1hbGl6ZVN0eWxlRGF0YVxuICB2YXIgb2xkU3R5bGUgPSBvbGRTdGF0aWNTdHlsZSB8fCBvbGRTdHlsZUJpbmRpbmc7XG5cbiAgdmFyIHN0eWxlID0gbm9ybWFsaXplU3R5bGVCaW5kaW5nKHZub2RlLmRhdGEuc3R5bGUpIHx8IHt9O1xuXG4gIHZub2RlLmRhdGEuc3R5bGUgPSBzdHlsZS5fX29iX18gPyBleHRlbmQoe30sIHN0eWxlKSA6IHN0eWxlO1xuXG4gIHZhciBuZXdTdHlsZSA9IGdldFN0eWxlKHZub2RlLCB0cnVlKTtcblxuICBmb3IgKG5hbWUgaW4gb2xkU3R5bGUpIHtcbiAgICBpZiAobmV3U3R5bGVbbmFtZV0gPT0gbnVsbCkge1xuICAgICAgc2V0UHJvcChlbCwgbmFtZSwgJycpO1xuICAgIH1cbiAgfVxuICBmb3IgKG5hbWUgaW4gbmV3U3R5bGUpIHtcbiAgICBjdXIgPSBuZXdTdHlsZVtuYW1lXTtcbiAgICBpZiAoY3VyICE9PSBvbGRTdHlsZVtuYW1lXSkge1xuICAgICAgLy8gaWU5IHNldHRpbmcgdG8gbnVsbCBoYXMgbm8gZWZmZWN0LCBtdXN0IHVzZSBlbXB0eSBzdHJpbmdcbiAgICAgIHNldFByb3AoZWwsIG5hbWUsIGN1ciA9PSBudWxsID8gJycgOiBjdXIpO1xuICAgIH1cbiAgfVxufVxuXG52YXIgc3R5bGUgPSB7XG4gIGNyZWF0ZTogdXBkYXRlU3R5bGUsXG4gIHVwZGF0ZTogdXBkYXRlU3R5bGVcbn07XG5cbi8qICAqL1xuXG4vKipcbiAqIEFkZCBjbGFzcyB3aXRoIGNvbXBhdGliaWxpdHkgZm9yIFNWRyBzaW5jZSBjbGFzc0xpc3QgaXMgbm90IHN1cHBvcnRlZCBvblxuICogU1ZHIGVsZW1lbnRzIGluIElFXG4gKi9cbmZ1bmN0aW9uIGFkZENsYXNzIChlbCwgY2xzKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoIWNscyB8fCAhY2xzLnRyaW0oKSkge1xuICAgIHJldHVyblxuICB9XG5cbiAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgaWYgKGVsLmNsYXNzTGlzdCkge1xuICAgIGlmIChjbHMuaW5kZXhPZignICcpID4gLTEpIHtcbiAgICAgIGNscy5zcGxpdCgvXFxzKy8pLmZvckVhY2goZnVuY3Rpb24gKGMpIHsgcmV0dXJuIGVsLmNsYXNzTGlzdC5hZGQoYyk7IH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbC5jbGFzc0xpc3QuYWRkKGNscyk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciBjdXIgPSAnICcgKyBlbC5nZXRBdHRyaWJ1dGUoJ2NsYXNzJykgKyAnICc7XG4gICAgaWYgKGN1ci5pbmRleE9mKCcgJyArIGNscyArICcgJykgPCAwKSB7XG4gICAgICBlbC5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgKGN1ciArIGNscykudHJpbSgpKTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBSZW1vdmUgY2xhc3Mgd2l0aCBjb21wYXRpYmlsaXR5IGZvciBTVkcgc2luY2UgY2xhc3NMaXN0IGlzIG5vdCBzdXBwb3J0ZWQgb25cbiAqIFNWRyBlbGVtZW50cyBpbiBJRVxuICovXG5mdW5jdGlvbiByZW1vdmVDbGFzcyAoZWwsIGNscykge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKCFjbHMgfHwgIWNscy50cmltKCkpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gIGlmIChlbC5jbGFzc0xpc3QpIHtcbiAgICBpZiAoY2xzLmluZGV4T2YoJyAnKSA+IC0xKSB7XG4gICAgICBjbHMuc3BsaXQoL1xccysvKS5mb3JFYWNoKGZ1bmN0aW9uIChjKSB7IHJldHVybiBlbC5jbGFzc0xpc3QucmVtb3ZlKGMpOyB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZWwuY2xhc3NMaXN0LnJlbW92ZShjbHMpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YXIgY3VyID0gJyAnICsgZWwuZ2V0QXR0cmlidXRlKCdjbGFzcycpICsgJyAnO1xuICAgIHZhciB0YXIgPSAnICcgKyBjbHMgKyAnICc7XG4gICAgd2hpbGUgKGN1ci5pbmRleE9mKHRhcikgPj0gMCkge1xuICAgICAgY3VyID0gY3VyLnJlcGxhY2UodGFyLCAnICcpO1xuICAgIH1cbiAgICBlbC5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgY3VyLnRyaW0oKSk7XG4gIH1cbn1cblxuLyogICovXG5cbnZhciBoYXNUcmFuc2l0aW9uID0gaW5Ccm93c2VyICYmICFpc0lFOTtcbnZhciBUUkFOU0lUSU9OID0gJ3RyYW5zaXRpb24nO1xudmFyIEFOSU1BVElPTiA9ICdhbmltYXRpb24nO1xuXG4vLyBUcmFuc2l0aW9uIHByb3BlcnR5L2V2ZW50IHNuaWZmaW5nXG52YXIgdHJhbnNpdGlvblByb3AgPSAndHJhbnNpdGlvbic7XG52YXIgdHJhbnNpdGlvbkVuZEV2ZW50ID0gJ3RyYW5zaXRpb25lbmQnO1xudmFyIGFuaW1hdGlvblByb3AgPSAnYW5pbWF0aW9uJztcbnZhciBhbmltYXRpb25FbmRFdmVudCA9ICdhbmltYXRpb25lbmQnO1xuaWYgKGhhc1RyYW5zaXRpb24pIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmICh3aW5kb3cub250cmFuc2l0aW9uZW5kID09PSB1bmRlZmluZWQgJiZcbiAgICB3aW5kb3cub253ZWJraXR0cmFuc2l0aW9uZW5kICE9PSB1bmRlZmluZWQpIHtcbiAgICB0cmFuc2l0aW9uUHJvcCA9ICdXZWJraXRUcmFuc2l0aW9uJztcbiAgICB0cmFuc2l0aW9uRW5kRXZlbnQgPSAnd2Via2l0VHJhbnNpdGlvbkVuZCc7XG4gIH1cbiAgaWYgKHdpbmRvdy5vbmFuaW1hdGlvbmVuZCA9PT0gdW5kZWZpbmVkICYmXG4gICAgd2luZG93Lm9ud2Via2l0YW5pbWF0aW9uZW5kICE9PSB1bmRlZmluZWQpIHtcbiAgICBhbmltYXRpb25Qcm9wID0gJ1dlYmtpdEFuaW1hdGlvbic7XG4gICAgYW5pbWF0aW9uRW5kRXZlbnQgPSAnd2Via2l0QW5pbWF0aW9uRW5kJztcbiAgfVxufVxuXG52YXIgcmFmID0gKGluQnJvd3NlciAmJiB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKSB8fCBzZXRUaW1lb3V0O1xuZnVuY3Rpb24gbmV4dEZyYW1lIChmbikge1xuICByYWYoZnVuY3Rpb24gKCkge1xuICAgIHJhZihmbik7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBhZGRUcmFuc2l0aW9uQ2xhc3MgKGVsLCBjbHMpIHtcbiAgKGVsLl90cmFuc2l0aW9uQ2xhc3NlcyB8fCAoZWwuX3RyYW5zaXRpb25DbGFzc2VzID0gW10pKS5wdXNoKGNscyk7XG4gIGFkZENsYXNzKGVsLCBjbHMpO1xufVxuXG5mdW5jdGlvbiByZW1vdmVUcmFuc2l0aW9uQ2xhc3MgKGVsLCBjbHMpIHtcbiAgaWYgKGVsLl90cmFuc2l0aW9uQ2xhc3Nlcykge1xuICAgIHJlbW92ZSQxKGVsLl90cmFuc2l0aW9uQ2xhc3NlcywgY2xzKTtcbiAgfVxuICByZW1vdmVDbGFzcyhlbCwgY2xzKTtcbn1cblxuZnVuY3Rpb24gd2hlblRyYW5zaXRpb25FbmRzIChcbiAgZWwsXG4gIGV4cGVjdGVkVHlwZSxcbiAgY2Jcbikge1xuICB2YXIgcmVmID0gZ2V0VHJhbnNpdGlvbkluZm8oZWwsIGV4cGVjdGVkVHlwZSk7XG4gIHZhciB0eXBlID0gcmVmLnR5cGU7XG4gIHZhciB0aW1lb3V0ID0gcmVmLnRpbWVvdXQ7XG4gIHZhciBwcm9wQ291bnQgPSByZWYucHJvcENvdW50O1xuICBpZiAoIXR5cGUpIHsgcmV0dXJuIGNiKCkgfVxuICB2YXIgZXZlbnQgPSB0eXBlID09PSBUUkFOU0lUSU9OID8gdHJhbnNpdGlvbkVuZEV2ZW50IDogYW5pbWF0aW9uRW5kRXZlbnQ7XG4gIHZhciBlbmRlZCA9IDA7XG4gIHZhciBlbmQgPSBmdW5jdGlvbiAoKSB7XG4gICAgZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudCwgb25FbmQpO1xuICAgIGNiKCk7XG4gIH07XG4gIHZhciBvbkVuZCA9IGZ1bmN0aW9uIChlKSB7XG4gICAgaWYgKGUudGFyZ2V0ID09PSBlbCkge1xuICAgICAgaWYgKCsrZW5kZWQgPj0gcHJvcENvdW50KSB7XG4gICAgICAgIGVuZCgpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGVuZGVkIDwgcHJvcENvdW50KSB7XG4gICAgICBlbmQoKTtcbiAgICB9XG4gIH0sIHRpbWVvdXQgKyAxKTtcbiAgZWwuYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgb25FbmQpO1xufVxuXG52YXIgdHJhbnNmb3JtUkUgPSAvXFxiKHRyYW5zZm9ybXxhbGwpKCx8JCkvO1xuXG5mdW5jdGlvbiBnZXRUcmFuc2l0aW9uSW5mbyAoZWwsIGV4cGVjdGVkVHlwZSkge1xuICB2YXIgc3R5bGVzID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWwpO1xuICB2YXIgdHJhbnNpdGlvbmVEZWxheXMgPSBzdHlsZXNbdHJhbnNpdGlvblByb3AgKyAnRGVsYXknXS5zcGxpdCgnLCAnKTtcbiAgdmFyIHRyYW5zaXRpb25EdXJhdGlvbnMgPSBzdHlsZXNbdHJhbnNpdGlvblByb3AgKyAnRHVyYXRpb24nXS5zcGxpdCgnLCAnKTtcbiAgdmFyIHRyYW5zaXRpb25UaW1lb3V0ID0gZ2V0VGltZW91dCh0cmFuc2l0aW9uZURlbGF5cywgdHJhbnNpdGlvbkR1cmF0aW9ucyk7XG4gIHZhciBhbmltYXRpb25EZWxheXMgPSBzdHlsZXNbYW5pbWF0aW9uUHJvcCArICdEZWxheSddLnNwbGl0KCcsICcpO1xuICB2YXIgYW5pbWF0aW9uRHVyYXRpb25zID0gc3R5bGVzW2FuaW1hdGlvblByb3AgKyAnRHVyYXRpb24nXS5zcGxpdCgnLCAnKTtcbiAgdmFyIGFuaW1hdGlvblRpbWVvdXQgPSBnZXRUaW1lb3V0KGFuaW1hdGlvbkRlbGF5cywgYW5pbWF0aW9uRHVyYXRpb25zKTtcblxuICB2YXIgdHlwZTtcbiAgdmFyIHRpbWVvdXQgPSAwO1xuICB2YXIgcHJvcENvdW50ID0gMDtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChleHBlY3RlZFR5cGUgPT09IFRSQU5TSVRJT04pIHtcbiAgICBpZiAodHJhbnNpdGlvblRpbWVvdXQgPiAwKSB7XG4gICAgICB0eXBlID0gVFJBTlNJVElPTjtcbiAgICAgIHRpbWVvdXQgPSB0cmFuc2l0aW9uVGltZW91dDtcbiAgICAgIHByb3BDb3VudCA9IHRyYW5zaXRpb25EdXJhdGlvbnMubGVuZ3RoO1xuICAgIH1cbiAgfSBlbHNlIGlmIChleHBlY3RlZFR5cGUgPT09IEFOSU1BVElPTikge1xuICAgIGlmIChhbmltYXRpb25UaW1lb3V0ID4gMCkge1xuICAgICAgdHlwZSA9IEFOSU1BVElPTjtcbiAgICAgIHRpbWVvdXQgPSBhbmltYXRpb25UaW1lb3V0O1xuICAgICAgcHJvcENvdW50ID0gYW5pbWF0aW9uRHVyYXRpb25zLmxlbmd0aDtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdGltZW91dCA9IE1hdGgubWF4KHRyYW5zaXRpb25UaW1lb3V0LCBhbmltYXRpb25UaW1lb3V0KTtcbiAgICB0eXBlID0gdGltZW91dCA+IDBcbiAgICAgID8gdHJhbnNpdGlvblRpbWVvdXQgPiBhbmltYXRpb25UaW1lb3V0XG4gICAgICAgID8gVFJBTlNJVElPTlxuICAgICAgICA6IEFOSU1BVElPTlxuICAgICAgOiBudWxsO1xuICAgIHByb3BDb3VudCA9IHR5cGVcbiAgICAgID8gdHlwZSA9PT0gVFJBTlNJVElPTlxuICAgICAgICA/IHRyYW5zaXRpb25EdXJhdGlvbnMubGVuZ3RoXG4gICAgICAgIDogYW5pbWF0aW9uRHVyYXRpb25zLmxlbmd0aFxuICAgICAgOiAwO1xuICB9XG4gIHZhciBoYXNUcmFuc2Zvcm0gPVxuICAgIHR5cGUgPT09IFRSQU5TSVRJT04gJiZcbiAgICB0cmFuc2Zvcm1SRS50ZXN0KHN0eWxlc1t0cmFuc2l0aW9uUHJvcCArICdQcm9wZXJ0eSddKTtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiB0eXBlLFxuICAgIHRpbWVvdXQ6IHRpbWVvdXQsXG4gICAgcHJvcENvdW50OiBwcm9wQ291bnQsXG4gICAgaGFzVHJhbnNmb3JtOiBoYXNUcmFuc2Zvcm1cbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRUaW1lb3V0IChkZWxheXMsIGR1cmF0aW9ucykge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICB3aGlsZSAoZGVsYXlzLmxlbmd0aCA8IGR1cmF0aW9ucy5sZW5ndGgpIHtcbiAgICBkZWxheXMgPSBkZWxheXMuY29uY2F0KGRlbGF5cyk7XG4gIH1cblxuICByZXR1cm4gTWF0aC5tYXguYXBwbHkobnVsbCwgZHVyYXRpb25zLm1hcChmdW5jdGlvbiAoZCwgaSkge1xuICAgIHJldHVybiB0b01zKGQpICsgdG9NcyhkZWxheXNbaV0pXG4gIH0pKVxufVxuXG5mdW5jdGlvbiB0b01zIChzKSB7XG4gIHJldHVybiBOdW1iZXIocy5zbGljZSgwLCAtMSkpICogMTAwMFxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gZW50ZXIgKHZub2RlKSB7XG4gIHZhciBlbCA9IHZub2RlLmVsbTtcblxuICAvLyBjYWxsIGxlYXZlIGNhbGxiYWNrIG5vd1xuICBpZiAoZWwuX2xlYXZlQ2IpIHtcbiAgICBlbC5fbGVhdmVDYi5jYW5jZWxsZWQgPSB0cnVlO1xuICAgIGVsLl9sZWF2ZUNiKCk7XG4gIH1cblxuICB2YXIgZGF0YSA9IHJlc29sdmVUcmFuc2l0aW9uKHZub2RlLmRhdGEudHJhbnNpdGlvbik7XG4gIGlmICghZGF0YSkge1xuICAgIHJldHVyblxuICB9XG5cbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChlbC5fZW50ZXJDYiB8fCBlbC5ub2RlVHlwZSAhPT0gMSkge1xuICAgIHJldHVyblxuICB9XG5cbiAgdmFyIGNzcyA9IGRhdGEuY3NzO1xuICB2YXIgdHlwZSA9IGRhdGEudHlwZTtcbiAgdmFyIGVudGVyQ2xhc3MgPSBkYXRhLmVudGVyQ2xhc3M7XG4gIHZhciBlbnRlckFjdGl2ZUNsYXNzID0gZGF0YS5lbnRlckFjdGl2ZUNsYXNzO1xuICB2YXIgYXBwZWFyQ2xhc3MgPSBkYXRhLmFwcGVhckNsYXNzO1xuICB2YXIgYXBwZWFyQWN0aXZlQ2xhc3MgPSBkYXRhLmFwcGVhckFjdGl2ZUNsYXNzO1xuICB2YXIgYmVmb3JlRW50ZXIgPSBkYXRhLmJlZm9yZUVudGVyO1xuICB2YXIgZW50ZXIgPSBkYXRhLmVudGVyO1xuICB2YXIgYWZ0ZXJFbnRlciA9IGRhdGEuYWZ0ZXJFbnRlcjtcbiAgdmFyIGVudGVyQ2FuY2VsbGVkID0gZGF0YS5lbnRlckNhbmNlbGxlZDtcbiAgdmFyIGJlZm9yZUFwcGVhciA9IGRhdGEuYmVmb3JlQXBwZWFyO1xuICB2YXIgYXBwZWFyID0gZGF0YS5hcHBlYXI7XG4gIHZhciBhZnRlckFwcGVhciA9IGRhdGEuYWZ0ZXJBcHBlYXI7XG4gIHZhciBhcHBlYXJDYW5jZWxsZWQgPSBkYXRhLmFwcGVhckNhbmNlbGxlZDtcblxuICAvLyBhY3RpdmVJbnN0YW5jZSB3aWxsIGFsd2F5cyBiZSB0aGUgPHRyYW5zaXRpb24+IGNvbXBvbmVudCBtYW5hZ2luZyB0aGlzXG4gIC8vIHRyYW5zaXRpb24uIE9uZSBlZGdlIGNhc2UgdG8gY2hlY2sgaXMgd2hlbiB0aGUgPHRyYW5zaXRpb24+IGlzIHBsYWNlZFxuICAvLyBhcyB0aGUgcm9vdCBub2RlIG9mIGEgY2hpbGQgY29tcG9uZW50LiBJbiB0aGF0IGNhc2Ugd2UgbmVlZCB0byBjaGVja1xuICAvLyA8dHJhbnNpdGlvbj4ncyBwYXJlbnQgZm9yIGFwcGVhciBjaGVjay5cbiAgdmFyIHRyYW5zaXRpb25Ob2RlID0gYWN0aXZlSW5zdGFuY2UuJHZub2RlO1xuICB2YXIgY29udGV4dCA9IHRyYW5zaXRpb25Ob2RlICYmIHRyYW5zaXRpb25Ob2RlLnBhcmVudFxuICAgID8gdHJhbnNpdGlvbk5vZGUucGFyZW50LmNvbnRleHRcbiAgICA6IGFjdGl2ZUluc3RhbmNlO1xuXG4gIHZhciBpc0FwcGVhciA9ICFjb250ZXh0Ll9pc01vdW50ZWQgfHwgIXZub2RlLmlzUm9vdEluc2VydDtcblxuICBpZiAoaXNBcHBlYXIgJiYgIWFwcGVhciAmJiBhcHBlYXIgIT09ICcnKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICB2YXIgc3RhcnRDbGFzcyA9IGlzQXBwZWFyID8gYXBwZWFyQ2xhc3MgOiBlbnRlckNsYXNzO1xuICB2YXIgYWN0aXZlQ2xhc3MgPSBpc0FwcGVhciA/IGFwcGVhckFjdGl2ZUNsYXNzIDogZW50ZXJBY3RpdmVDbGFzcztcbiAgdmFyIGJlZm9yZUVudGVySG9vayA9IGlzQXBwZWFyID8gKGJlZm9yZUFwcGVhciB8fCBiZWZvcmVFbnRlcikgOiBiZWZvcmVFbnRlcjtcbiAgdmFyIGVudGVySG9vayA9IGlzQXBwZWFyID8gKHR5cGVvZiBhcHBlYXIgPT09ICdmdW5jdGlvbicgPyBhcHBlYXIgOiBlbnRlcikgOiBlbnRlcjtcbiAgdmFyIGFmdGVyRW50ZXJIb29rID0gaXNBcHBlYXIgPyAoYWZ0ZXJBcHBlYXIgfHwgYWZ0ZXJFbnRlcikgOiBhZnRlckVudGVyO1xuICB2YXIgZW50ZXJDYW5jZWxsZWRIb29rID0gaXNBcHBlYXIgPyAoYXBwZWFyQ2FuY2VsbGVkIHx8IGVudGVyQ2FuY2VsbGVkKSA6IGVudGVyQ2FuY2VsbGVkO1xuXG4gIHZhciBleHBlY3RzQ1NTID0gY3NzICE9PSBmYWxzZSAmJiAhaXNJRTk7XG4gIHZhciB1c2VyV2FudHNDb250cm9sID1cbiAgICBlbnRlckhvb2sgJiZcbiAgICAvLyBlbnRlckhvb2sgbWF5IGJlIGEgYm91bmQgbWV0aG9kIHdoaWNoIGV4cG9zZXNcbiAgICAvLyB0aGUgbGVuZ3RoIG9mIG9yaWdpbmFsIGZuIGFzIF9sZW5ndGhcbiAgICAoZW50ZXJIb29rLl9sZW5ndGggfHwgZW50ZXJIb29rLmxlbmd0aCkgPiAxO1xuXG4gIHZhciBjYiA9IGVsLl9lbnRlckNiID0gb25jZShmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGV4cGVjdHNDU1MpIHtcbiAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgYWN0aXZlQ2xhc3MpO1xuICAgIH1cbiAgICBpZiAoY2IuY2FuY2VsbGVkKSB7XG4gICAgICBpZiAoZXhwZWN0c0NTUykge1xuICAgICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIHN0YXJ0Q2xhc3MpO1xuICAgICAgfVxuICAgICAgZW50ZXJDYW5jZWxsZWRIb29rICYmIGVudGVyQ2FuY2VsbGVkSG9vayhlbCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFmdGVyRW50ZXJIb29rICYmIGFmdGVyRW50ZXJIb29rKGVsKTtcbiAgICB9XG4gICAgZWwuX2VudGVyQ2IgPSBudWxsO1xuICB9KTtcblxuICBpZiAoIXZub2RlLmRhdGEuc2hvdykge1xuICAgIC8vIHJlbW92ZSBwZW5kaW5nIGxlYXZlIGVsZW1lbnQgb24gZW50ZXIgYnkgaW5qZWN0aW5nIGFuIGluc2VydCBob29rXG4gICAgbWVyZ2VWTm9kZUhvb2sodm5vZGUuZGF0YS5ob29rIHx8ICh2bm9kZS5kYXRhLmhvb2sgPSB7fSksICdpbnNlcnQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgcGFyZW50ID0gZWwucGFyZW50Tm9kZTtcbiAgICAgIHZhciBwZW5kaW5nTm9kZSA9IHBhcmVudCAmJiBwYXJlbnQuX3BlbmRpbmcgJiYgcGFyZW50Ll9wZW5kaW5nW3Zub2RlLmtleV07XG4gICAgICBpZiAocGVuZGluZ05vZGUgJiYgcGVuZGluZ05vZGUudGFnID09PSB2bm9kZS50YWcgJiYgcGVuZGluZ05vZGUuZWxtLl9sZWF2ZUNiKSB7XG4gICAgICAgIHBlbmRpbmdOb2RlLmVsbS5fbGVhdmVDYigpO1xuICAgICAgfVxuICAgICAgZW50ZXJIb29rICYmIGVudGVySG9vayhlbCwgY2IpO1xuICAgIH0sICd0cmFuc2l0aW9uLWluc2VydCcpO1xuICB9XG5cbiAgLy8gc3RhcnQgZW50ZXIgdHJhbnNpdGlvblxuICBiZWZvcmVFbnRlckhvb2sgJiYgYmVmb3JlRW50ZXJIb29rKGVsKTtcbiAgaWYgKGV4cGVjdHNDU1MpIHtcbiAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIHN0YXJ0Q2xhc3MpO1xuICAgIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgYWN0aXZlQ2xhc3MpO1xuICAgIG5leHRGcmFtZShmdW5jdGlvbiAoKSB7XG4gICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIHN0YXJ0Q2xhc3MpO1xuICAgICAgaWYgKCFjYi5jYW5jZWxsZWQgJiYgIXVzZXJXYW50c0NvbnRyb2wpIHtcbiAgICAgICAgd2hlblRyYW5zaXRpb25FbmRzKGVsLCB0eXBlLCBjYik7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBpZiAodm5vZGUuZGF0YS5zaG93KSB7XG4gICAgZW50ZXJIb29rICYmIGVudGVySG9vayhlbCwgY2IpO1xuICB9XG5cbiAgaWYgKCFleHBlY3RzQ1NTICYmICF1c2VyV2FudHNDb250cm9sKSB7XG4gICAgY2IoKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBsZWF2ZSAodm5vZGUsIHJtKSB7XG4gIHZhciBlbCA9IHZub2RlLmVsbTtcblxuICAvLyBjYWxsIGVudGVyIGNhbGxiYWNrIG5vd1xuICBpZiAoZWwuX2VudGVyQ2IpIHtcbiAgICBlbC5fZW50ZXJDYi5jYW5jZWxsZWQgPSB0cnVlO1xuICAgIGVsLl9lbnRlckNiKCk7XG4gIH1cblxuICB2YXIgZGF0YSA9IHJlc29sdmVUcmFuc2l0aW9uKHZub2RlLmRhdGEudHJhbnNpdGlvbik7XG4gIGlmICghZGF0YSkge1xuICAgIHJldHVybiBybSgpXG4gIH1cblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKGVsLl9sZWF2ZUNiIHx8IGVsLm5vZGVUeXBlICE9PSAxKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICB2YXIgY3NzID0gZGF0YS5jc3M7XG4gIHZhciB0eXBlID0gZGF0YS50eXBlO1xuICB2YXIgbGVhdmVDbGFzcyA9IGRhdGEubGVhdmVDbGFzcztcbiAgdmFyIGxlYXZlQWN0aXZlQ2xhc3MgPSBkYXRhLmxlYXZlQWN0aXZlQ2xhc3M7XG4gIHZhciBiZWZvcmVMZWF2ZSA9IGRhdGEuYmVmb3JlTGVhdmU7XG4gIHZhciBsZWF2ZSA9IGRhdGEubGVhdmU7XG4gIHZhciBhZnRlckxlYXZlID0gZGF0YS5hZnRlckxlYXZlO1xuICB2YXIgbGVhdmVDYW5jZWxsZWQgPSBkYXRhLmxlYXZlQ2FuY2VsbGVkO1xuICB2YXIgZGVsYXlMZWF2ZSA9IGRhdGEuZGVsYXlMZWF2ZTtcblxuICB2YXIgZXhwZWN0c0NTUyA9IGNzcyAhPT0gZmFsc2UgJiYgIWlzSUU5O1xuICB2YXIgdXNlcldhbnRzQ29udHJvbCA9XG4gICAgbGVhdmUgJiZcbiAgICAvLyBsZWF2ZSBob29rIG1heSBiZSBhIGJvdW5kIG1ldGhvZCB3aGljaCBleHBvc2VzXG4gICAgLy8gdGhlIGxlbmd0aCBvZiBvcmlnaW5hbCBmbiBhcyBfbGVuZ3RoXG4gICAgKGxlYXZlLl9sZW5ndGggfHwgbGVhdmUubGVuZ3RoKSA+IDE7XG5cbiAgdmFyIGNiID0gZWwuX2xlYXZlQ2IgPSBvbmNlKGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoZWwucGFyZW50Tm9kZSAmJiBlbC5wYXJlbnROb2RlLl9wZW5kaW5nKSB7XG4gICAgICBlbC5wYXJlbnROb2RlLl9wZW5kaW5nW3Zub2RlLmtleV0gPSBudWxsO1xuICAgIH1cbiAgICBpZiAoZXhwZWN0c0NTUykge1xuICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZUFjdGl2ZUNsYXNzKTtcbiAgICB9XG4gICAgaWYgKGNiLmNhbmNlbGxlZCkge1xuICAgICAgaWYgKGV4cGVjdHNDU1MpIHtcbiAgICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZUNsYXNzKTtcbiAgICAgIH1cbiAgICAgIGxlYXZlQ2FuY2VsbGVkICYmIGxlYXZlQ2FuY2VsbGVkKGVsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcm0oKTtcbiAgICAgIGFmdGVyTGVhdmUgJiYgYWZ0ZXJMZWF2ZShlbCk7XG4gICAgfVxuICAgIGVsLl9sZWF2ZUNiID0gbnVsbDtcbiAgfSk7XG5cbiAgaWYgKGRlbGF5TGVhdmUpIHtcbiAgICBkZWxheUxlYXZlKHBlcmZvcm1MZWF2ZSk7XG4gIH0gZWxzZSB7XG4gICAgcGVyZm9ybUxlYXZlKCk7XG4gIH1cblxuICBmdW5jdGlvbiBwZXJmb3JtTGVhdmUgKCkge1xuICAgIC8vIHRoZSBkZWxheWVkIGxlYXZlIG1heSBoYXZlIGFscmVhZHkgYmVlbiBjYW5jZWxsZWRcbiAgICBpZiAoY2IuY2FuY2VsbGVkKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgLy8gcmVjb3JkIGxlYXZpbmcgZWxlbWVudFxuICAgIGlmICghdm5vZGUuZGF0YS5zaG93KSB7XG4gICAgICAoZWwucGFyZW50Tm9kZS5fcGVuZGluZyB8fCAoZWwucGFyZW50Tm9kZS5fcGVuZGluZyA9IHt9KSlbdm5vZGUua2V5XSA9IHZub2RlO1xuICAgIH1cbiAgICBiZWZvcmVMZWF2ZSAmJiBiZWZvcmVMZWF2ZShlbCk7XG4gICAgaWYgKGV4cGVjdHNDU1MpIHtcbiAgICAgIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgbGVhdmVDbGFzcyk7XG4gICAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIGxlYXZlQWN0aXZlQ2xhc3MpO1xuICAgICAgbmV4dEZyYW1lKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZUNsYXNzKTtcbiAgICAgICAgaWYgKCFjYi5jYW5jZWxsZWQgJiYgIXVzZXJXYW50c0NvbnRyb2wpIHtcbiAgICAgICAgICB3aGVuVHJhbnNpdGlvbkVuZHMoZWwsIHR5cGUsIGNiKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIGxlYXZlICYmIGxlYXZlKGVsLCBjYik7XG4gICAgaWYgKCFleHBlY3RzQ1NTICYmICF1c2VyV2FudHNDb250cm9sKSB7XG4gICAgICBjYigpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiByZXNvbHZlVHJhbnNpdGlvbiAoZGVmJCQxKSB7XG4gIGlmICghZGVmJCQxKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgaWYgKHR5cGVvZiBkZWYkJDEgPT09ICdvYmplY3QnKSB7XG4gICAgdmFyIHJlcyA9IHt9O1xuICAgIGlmIChkZWYkJDEuY3NzICE9PSBmYWxzZSkge1xuICAgICAgZXh0ZW5kKHJlcywgYXV0b0Nzc1RyYW5zaXRpb24oZGVmJCQxLm5hbWUgfHwgJ3YnKSk7XG4gICAgfVxuICAgIGV4dGVuZChyZXMsIGRlZiQkMSk7XG4gICAgcmV0dXJuIHJlc1xuICB9IGVsc2UgaWYgKHR5cGVvZiBkZWYkJDEgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGF1dG9Dc3NUcmFuc2l0aW9uKGRlZiQkMSlcbiAgfVxufVxuXG52YXIgYXV0b0Nzc1RyYW5zaXRpb24gPSBjYWNoZWQoZnVuY3Rpb24gKG5hbWUpIHtcbiAgcmV0dXJuIHtcbiAgICBlbnRlckNsYXNzOiAobmFtZSArIFwiLWVudGVyXCIpLFxuICAgIGxlYXZlQ2xhc3M6IChuYW1lICsgXCItbGVhdmVcIiksXG4gICAgYXBwZWFyQ2xhc3M6IChuYW1lICsgXCItZW50ZXJcIiksXG4gICAgZW50ZXJBY3RpdmVDbGFzczogKG5hbWUgKyBcIi1lbnRlci1hY3RpdmVcIiksXG4gICAgbGVhdmVBY3RpdmVDbGFzczogKG5hbWUgKyBcIi1sZWF2ZS1hY3RpdmVcIiksXG4gICAgYXBwZWFyQWN0aXZlQ2xhc3M6IChuYW1lICsgXCItZW50ZXItYWN0aXZlXCIpXG4gIH1cbn0pO1xuXG5mdW5jdGlvbiBvbmNlIChmbikge1xuICB2YXIgY2FsbGVkID0gZmFsc2U7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCFjYWxsZWQpIHtcbiAgICAgIGNhbGxlZCA9IHRydWU7XG4gICAgICBmbigpO1xuICAgIH1cbiAgfVxufVxuXG52YXIgdHJhbnNpdGlvbiA9IGluQnJvd3NlciA/IHtcbiAgY3JlYXRlOiBmdW5jdGlvbiBjcmVhdGUgKF8sIHZub2RlKSB7XG4gICAgaWYgKCF2bm9kZS5kYXRhLnNob3cpIHtcbiAgICAgIGVudGVyKHZub2RlKTtcbiAgICB9XG4gIH0sXG4gIHJlbW92ZTogZnVuY3Rpb24gcmVtb3ZlICh2bm9kZSwgcm0pIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgIGlmICghdm5vZGUuZGF0YS5zaG93KSB7XG4gICAgICBsZWF2ZSh2bm9kZSwgcm0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBybSgpO1xuICAgIH1cbiAgfVxufSA6IHt9O1xuXG52YXIgcGxhdGZvcm1Nb2R1bGVzID0gW1xuICBhdHRycyxcbiAga2xhc3MsXG4gIGV2ZW50cyxcbiAgZG9tUHJvcHMsXG4gIHN0eWxlLFxuICB0cmFuc2l0aW9uXG5dO1xuXG4vKiAgKi9cblxuLy8gdGhlIGRpcmVjdGl2ZSBtb2R1bGUgc2hvdWxkIGJlIGFwcGxpZWQgbGFzdCwgYWZ0ZXIgYWxsXG4vLyBidWlsdC1pbiBtb2R1bGVzIGhhdmUgYmVlbiBhcHBsaWVkLlxudmFyIG1vZHVsZXMgPSBwbGF0Zm9ybU1vZHVsZXMuY29uY2F0KGJhc2VNb2R1bGVzKTtcblxudmFyIHBhdGNoJDEgPSBjcmVhdGVQYXRjaEZ1bmN0aW9uKHsgbm9kZU9wczogbm9kZU9wcywgbW9kdWxlczogbW9kdWxlcyB9KTtcblxuLyoqXG4gKiBOb3QgdHlwZSBjaGVja2luZyB0aGlzIGZpbGUgYmVjYXVzZSBmbG93IGRvZXNuJ3QgbGlrZSBhdHRhY2hpbmdcbiAqIHByb3BlcnRpZXMgdG8gRWxlbWVudHMuXG4gKi9cblxudmFyIG1vZGVsYWJsZVRhZ1JFID0gL15pbnB1dHxzZWxlY3R8dGV4dGFyZWF8dnVlLWNvbXBvbmVudC1bMC05XSsoLVswLTlhLXpBLVpfLV0qKT8kLztcblxuLyogaXN0YW5idWwgaWdub3JlIGlmICovXG5pZiAoaXNJRTkpIHtcbiAgLy8gaHR0cDovL3d3dy5tYXR0czQxMS5jb20vcG9zdC9pbnRlcm5ldC1leHBsb3Jlci05LW9uaW5wdXQvXG4gIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3NlbGVjdGlvbmNoYW5nZScsIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZWwgPSBkb2N1bWVudC5hY3RpdmVFbGVtZW50O1xuICAgIGlmIChlbCAmJiBlbC52bW9kZWwpIHtcbiAgICAgIHRyaWdnZXIoZWwsICdpbnB1dCcpO1xuICAgIH1cbiAgfSk7XG59XG5cbnZhciBtb2RlbCA9IHtcbiAgaW5zZXJ0ZWQ6IGZ1bmN0aW9uIGluc2VydGVkIChlbCwgYmluZGluZywgdm5vZGUpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgaWYgKCFtb2RlbGFibGVUYWdSRS50ZXN0KHZub2RlLnRhZykpIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICBcInYtbW9kZWwgaXMgbm90IHN1cHBvcnRlZCBvbiBlbGVtZW50IHR5cGU6IDxcIiArICh2bm9kZS50YWcpICsgXCI+LiBcIiArXG4gICAgICAgICAgJ0lmIHlvdSBhcmUgd29ya2luZyB3aXRoIGNvbnRlbnRlZGl0YWJsZSwgaXRcXCdzIHJlY29tbWVuZGVkIHRvICcgK1xuICAgICAgICAgICd3cmFwIGEgbGlicmFyeSBkZWRpY2F0ZWQgZm9yIHRoYXQgcHVycG9zZSBpbnNpZGUgYSBjdXN0b20gY29tcG9uZW50LicsXG4gICAgICAgICAgdm5vZGUuY29udGV4dFxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodm5vZGUudGFnID09PSAnc2VsZWN0Jykge1xuICAgICAgdmFyIGNiID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBzZXRTZWxlY3RlZChlbCwgYmluZGluZywgdm5vZGUuY29udGV4dCk7XG4gICAgICB9O1xuICAgICAgY2IoKTtcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgaWYgKGlzSUUgfHwgaXNFZGdlKSB7XG4gICAgICAgIHNldFRpbWVvdXQoY2IsIDApO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoXG4gICAgICAodm5vZGUudGFnID09PSAndGV4dGFyZWEnIHx8IGVsLnR5cGUgPT09ICd0ZXh0JykgJiZcbiAgICAgICFiaW5kaW5nLm1vZGlmaWVycy5sYXp5XG4gICAgKSB7XG4gICAgICBpZiAoIWlzQW5kcm9pZCkge1xuICAgICAgICBlbC5hZGRFdmVudExpc3RlbmVyKCdjb21wb3NpdGlvbnN0YXJ0Jywgb25Db21wb3NpdGlvblN0YXJ0KTtcbiAgICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcignY29tcG9zaXRpb25lbmQnLCBvbkNvbXBvc2l0aW9uRW5kKTtcbiAgICAgIH1cbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgaWYgKGlzSUU5KSB7XG4gICAgICAgIGVsLnZtb2RlbCA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9LFxuICBjb21wb25lbnRVcGRhdGVkOiBmdW5jdGlvbiBjb21wb25lbnRVcGRhdGVkIChlbCwgYmluZGluZywgdm5vZGUpIHtcbiAgICBpZiAodm5vZGUudGFnID09PSAnc2VsZWN0Jykge1xuICAgICAgc2V0U2VsZWN0ZWQoZWwsIGJpbmRpbmcsIHZub2RlLmNvbnRleHQpO1xuICAgICAgLy8gaW4gY2FzZSB0aGUgb3B0aW9ucyByZW5kZXJlZCBieSB2LWZvciBoYXZlIGNoYW5nZWQsXG4gICAgICAvLyBpdCdzIHBvc3NpYmxlIHRoYXQgdGhlIHZhbHVlIGlzIG91dC1vZi1zeW5jIHdpdGggdGhlIHJlbmRlcmVkIG9wdGlvbnMuXG4gICAgICAvLyBkZXRlY3Qgc3VjaCBjYXNlcyBhbmQgZmlsdGVyIG91dCB2YWx1ZXMgdGhhdCBubyBsb25nZXIgaGFzIGEgbWF0Y2hpbmdcbiAgICAgIC8vIG9wdGlvbiBpbiB0aGUgRE9NLlxuICAgICAgdmFyIG5lZWRSZXNldCA9IGVsLm11bHRpcGxlXG4gICAgICAgID8gYmluZGluZy52YWx1ZS5zb21lKGZ1bmN0aW9uICh2KSB7IHJldHVybiBoYXNOb01hdGNoaW5nT3B0aW9uKHYsIGVsLm9wdGlvbnMpOyB9KVxuICAgICAgICA6IGJpbmRpbmcudmFsdWUgIT09IGJpbmRpbmcub2xkVmFsdWUgJiYgaGFzTm9NYXRjaGluZ09wdGlvbihiaW5kaW5nLnZhbHVlLCBlbC5vcHRpb25zKTtcbiAgICAgIGlmIChuZWVkUmVzZXQpIHtcbiAgICAgICAgdHJpZ2dlcihlbCwgJ2NoYW5nZScpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxuZnVuY3Rpb24gc2V0U2VsZWN0ZWQgKGVsLCBiaW5kaW5nLCB2bSkge1xuICB2YXIgdmFsdWUgPSBiaW5kaW5nLnZhbHVlO1xuICB2YXIgaXNNdWx0aXBsZSA9IGVsLm11bHRpcGxlO1xuICBpZiAoaXNNdWx0aXBsZSAmJiAhQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXG4gICAgICBcIjxzZWxlY3QgbXVsdGlwbGUgdi1tb2RlbD1cXFwiXCIgKyAoYmluZGluZy5leHByZXNzaW9uKSArIFwiXFxcIj4gXCIgK1xuICAgICAgXCJleHBlY3RzIGFuIEFycmF5IHZhbHVlIGZvciBpdHMgYmluZGluZywgYnV0IGdvdCBcIiArIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpLnNsaWNlKDgsIC0xKSksXG4gICAgICB2bVxuICAgICk7XG4gICAgcmV0dXJuXG4gIH1cbiAgdmFyIHNlbGVjdGVkLCBvcHRpb247XG4gIGZvciAodmFyIGkgPSAwLCBsID0gZWwub3B0aW9ucy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBvcHRpb24gPSBlbC5vcHRpb25zW2ldO1xuICAgIGlmIChpc011bHRpcGxlKSB7XG4gICAgICBzZWxlY3RlZCA9IGxvb3NlSW5kZXhPZih2YWx1ZSwgZ2V0VmFsdWUob3B0aW9uKSkgPiAtMTtcbiAgICAgIGlmIChvcHRpb24uc2VsZWN0ZWQgIT09IHNlbGVjdGVkKSB7XG4gICAgICAgIG9wdGlvbi5zZWxlY3RlZCA9IHNlbGVjdGVkO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAobG9vc2VFcXVhbChnZXRWYWx1ZShvcHRpb24pLCB2YWx1ZSkpIHtcbiAgICAgICAgaWYgKGVsLnNlbGVjdGVkSW5kZXggIT09IGkpIHtcbiAgICAgICAgICBlbC5zZWxlY3RlZEluZGV4ID0gaTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKCFpc011bHRpcGxlKSB7XG4gICAgZWwuc2VsZWN0ZWRJbmRleCA9IC0xO1xuICB9XG59XG5cbmZ1bmN0aW9uIGhhc05vTWF0Y2hpbmdPcHRpb24gKHZhbHVlLCBvcHRpb25zKSB7XG4gIGZvciAodmFyIGkgPSAwLCBsID0gb3B0aW9ucy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBpZiAobG9vc2VFcXVhbChnZXRWYWx1ZShvcHRpb25zW2ldKSwgdmFsdWUpKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWVcbn1cblxuZnVuY3Rpb24gZ2V0VmFsdWUgKG9wdGlvbikge1xuICByZXR1cm4gJ192YWx1ZScgaW4gb3B0aW9uXG4gICAgPyBvcHRpb24uX3ZhbHVlXG4gICAgOiBvcHRpb24udmFsdWVcbn1cblxuZnVuY3Rpb24gb25Db21wb3NpdGlvblN0YXJ0IChlKSB7XG4gIGUudGFyZ2V0LmNvbXBvc2luZyA9IHRydWU7XG59XG5cbmZ1bmN0aW9uIG9uQ29tcG9zaXRpb25FbmQgKGUpIHtcbiAgZS50YXJnZXQuY29tcG9zaW5nID0gZmFsc2U7XG4gIHRyaWdnZXIoZS50YXJnZXQsICdpbnB1dCcpO1xufVxuXG5mdW5jdGlvbiB0cmlnZ2VyIChlbCwgdHlwZSkge1xuICB2YXIgZSA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdIVE1MRXZlbnRzJyk7XG4gIGUuaW5pdEV2ZW50KHR5cGUsIHRydWUsIHRydWUpO1xuICBlbC5kaXNwYXRjaEV2ZW50KGUpO1xufVxuXG4vKiAgKi9cblxuLy8gcmVjdXJzaXZlbHkgc2VhcmNoIGZvciBwb3NzaWJsZSB0cmFuc2l0aW9uIGRlZmluZWQgaW5zaWRlIHRoZSBjb21wb25lbnQgcm9vdFxuZnVuY3Rpb24gbG9jYXRlTm9kZSAodm5vZGUpIHtcbiAgcmV0dXJuIHZub2RlLmNoaWxkICYmICghdm5vZGUuZGF0YSB8fCAhdm5vZGUuZGF0YS50cmFuc2l0aW9uKVxuICAgID8gbG9jYXRlTm9kZSh2bm9kZS5jaGlsZC5fdm5vZGUpXG4gICAgOiB2bm9kZVxufVxuXG52YXIgc2hvdyA9IHtcbiAgYmluZDogZnVuY3Rpb24gYmluZCAoZWwsIHJlZiwgdm5vZGUpIHtcbiAgICB2YXIgdmFsdWUgPSByZWYudmFsdWU7XG5cbiAgICB2bm9kZSA9IGxvY2F0ZU5vZGUodm5vZGUpO1xuICAgIHZhciB0cmFuc2l0aW9uID0gdm5vZGUuZGF0YSAmJiB2bm9kZS5kYXRhLnRyYW5zaXRpb247XG4gICAgaWYgKHZhbHVlICYmIHRyYW5zaXRpb24gJiYgIWlzSUU5KSB7XG4gICAgICBlbnRlcih2bm9kZSk7XG4gICAgfVxuICAgIHZhciBvcmlnaW5hbERpc3BsYXkgPSBlbC5zdHlsZS5kaXNwbGF5ID09PSAnbm9uZScgPyAnJyA6IGVsLnN0eWxlLmRpc3BsYXk7XG4gICAgZWwuc3R5bGUuZGlzcGxheSA9IHZhbHVlID8gb3JpZ2luYWxEaXNwbGF5IDogJ25vbmUnO1xuICAgIGVsLl9fdk9yaWdpbmFsRGlzcGxheSA9IG9yaWdpbmFsRGlzcGxheTtcbiAgfSxcbiAgdXBkYXRlOiBmdW5jdGlvbiB1cGRhdGUgKGVsLCByZWYsIHZub2RlKSB7XG4gICAgdmFyIHZhbHVlID0gcmVmLnZhbHVlO1xuICAgIHZhciBvbGRWYWx1ZSA9IHJlZi5vbGRWYWx1ZTtcblxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmICh2YWx1ZSA9PT0gb2xkVmFsdWUpIHsgcmV0dXJuIH1cbiAgICB2bm9kZSA9IGxvY2F0ZU5vZGUodm5vZGUpO1xuICAgIHZhciB0cmFuc2l0aW9uID0gdm5vZGUuZGF0YSAmJiB2bm9kZS5kYXRhLnRyYW5zaXRpb247XG4gICAgaWYgKHRyYW5zaXRpb24gJiYgIWlzSUU5KSB7XG4gICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgZW50ZXIodm5vZGUpO1xuICAgICAgICBlbC5zdHlsZS5kaXNwbGF5ID0gZWwuX192T3JpZ2luYWxEaXNwbGF5O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGVhdmUodm5vZGUsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBlbC5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZWwuc3R5bGUuZGlzcGxheSA9IHZhbHVlID8gZWwuX192T3JpZ2luYWxEaXNwbGF5IDogJ25vbmUnO1xuICAgIH1cbiAgfVxufTtcblxudmFyIHBsYXRmb3JtRGlyZWN0aXZlcyA9IHtcbiAgbW9kZWw6IG1vZGVsLFxuICBzaG93OiBzaG93XG59O1xuXG4vKiAgKi9cblxuLy8gUHJvdmlkZXMgdHJhbnNpdGlvbiBzdXBwb3J0IGZvciBhIHNpbmdsZSBlbGVtZW50L2NvbXBvbmVudC5cbi8vIHN1cHBvcnRzIHRyYW5zaXRpb24gbW9kZSAob3V0LWluIC8gaW4tb3V0KVxuXG52YXIgdHJhbnNpdGlvblByb3BzID0ge1xuICBuYW1lOiBTdHJpbmcsXG4gIGFwcGVhcjogQm9vbGVhbixcbiAgY3NzOiBCb29sZWFuLFxuICBtb2RlOiBTdHJpbmcsXG4gIHR5cGU6IFN0cmluZyxcbiAgZW50ZXJDbGFzczogU3RyaW5nLFxuICBsZWF2ZUNsYXNzOiBTdHJpbmcsXG4gIGVudGVyQWN0aXZlQ2xhc3M6IFN0cmluZyxcbiAgbGVhdmVBY3RpdmVDbGFzczogU3RyaW5nLFxuICBhcHBlYXJDbGFzczogU3RyaW5nLFxuICBhcHBlYXJBY3RpdmVDbGFzczogU3RyaW5nXG59O1xuXG4vLyBpbiBjYXNlIHRoZSBjaGlsZCBpcyBhbHNvIGFuIGFic3RyYWN0IGNvbXBvbmVudCwgZS5nLiA8a2VlcC1hbGl2ZT5cbi8vIHdlIHdhbnQgdG8gcmVjdXJzaXZlbHkgcmV0cmlldmUgdGhlIHJlYWwgY29tcG9uZW50IHRvIGJlIHJlbmRlcmVkXG5mdW5jdGlvbiBnZXRSZWFsQ2hpbGQgKHZub2RlKSB7XG4gIHZhciBjb21wT3B0aW9ucyA9IHZub2RlICYmIHZub2RlLmNvbXBvbmVudE9wdGlvbnM7XG4gIGlmIChjb21wT3B0aW9ucyAmJiBjb21wT3B0aW9ucy5DdG9yLm9wdGlvbnMuYWJzdHJhY3QpIHtcbiAgICByZXR1cm4gZ2V0UmVhbENoaWxkKGdldEZpcnN0Q29tcG9uZW50Q2hpbGQoY29tcE9wdGlvbnMuY2hpbGRyZW4pKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiB2bm9kZVxuICB9XG59XG5cbmZ1bmN0aW9uIGV4dHJhY3RUcmFuc2l0aW9uRGF0YSAoY29tcCkge1xuICB2YXIgZGF0YSA9IHt9O1xuICB2YXIgb3B0aW9ucyA9IGNvbXAuJG9wdGlvbnM7XG4gIC8vIHByb3BzXG4gIGZvciAodmFyIGtleSBpbiBvcHRpb25zLnByb3BzRGF0YSkge1xuICAgIGRhdGFba2V5XSA9IGNvbXBba2V5XTtcbiAgfVxuICAvLyBldmVudHMuXG4gIC8vIGV4dHJhY3QgbGlzdGVuZXJzIGFuZCBwYXNzIHRoZW0gZGlyZWN0bHkgdG8gdGhlIHRyYW5zaXRpb24gbWV0aG9kc1xuICB2YXIgbGlzdGVuZXJzID0gb3B0aW9ucy5fcGFyZW50TGlzdGVuZXJzO1xuICBmb3IgKHZhciBrZXkkMSBpbiBsaXN0ZW5lcnMpIHtcbiAgICBkYXRhW2NhbWVsaXplKGtleSQxKV0gPSBsaXN0ZW5lcnNba2V5JDFdLmZuO1xuICB9XG4gIHJldHVybiBkYXRhXG59XG5cbmZ1bmN0aW9uIHBsYWNlaG9sZGVyIChoLCByYXdDaGlsZCkge1xuICByZXR1cm4gL1xcZC1rZWVwLWFsaXZlJC8udGVzdChyYXdDaGlsZC50YWcpXG4gICAgPyBoKCdrZWVwLWFsaXZlJylcbiAgICA6IG51bGxcbn1cblxuZnVuY3Rpb24gaGFzUGFyZW50VHJhbnNpdGlvbiAodm5vZGUpIHtcbiAgd2hpbGUgKCh2bm9kZSA9IHZub2RlLnBhcmVudCkpIHtcbiAgICBpZiAodm5vZGUuZGF0YS50cmFuc2l0aW9uKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgfVxufVxuXG52YXIgVHJhbnNpdGlvbiA9IHtcbiAgbmFtZTogJ3RyYW5zaXRpb24nLFxuICBwcm9wczogdHJhbnNpdGlvblByb3BzLFxuICBhYnN0cmFjdDogdHJ1ZSxcbiAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIgKGgpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIHZhciBjaGlsZHJlbiA9IHRoaXMuJHNsb3RzLmRlZmF1bHQ7XG4gICAgaWYgKCFjaGlsZHJlbikge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgLy8gZmlsdGVyIG91dCB0ZXh0IG5vZGVzIChwb3NzaWJsZSB3aGl0ZXNwYWNlcylcbiAgICBjaGlsZHJlbiA9IGNoaWxkcmVuLmZpbHRlcihmdW5jdGlvbiAoYykgeyByZXR1cm4gYy50YWc7IH0pO1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmICghY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICAvLyB3YXJuIG11bHRpcGxlIGVsZW1lbnRzXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgY2hpbGRyZW4ubGVuZ3RoID4gMSkge1xuICAgICAgd2FybihcbiAgICAgICAgJzx0cmFuc2l0aW9uPiBjYW4gb25seSBiZSB1c2VkIG9uIGEgc2luZ2xlIGVsZW1lbnQuIFVzZSAnICtcbiAgICAgICAgJzx0cmFuc2l0aW9uLWdyb3VwPiBmb3IgbGlzdHMuJyxcbiAgICAgICAgdGhpcy4kcGFyZW50XG4gICAgICApO1xuICAgIH1cblxuICAgIHZhciBtb2RlID0gdGhpcy5tb2RlO1xuXG4gICAgLy8gd2FybiBpbnZhbGlkIG1vZGVcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJlxuICAgICAgICBtb2RlICYmIG1vZGUgIT09ICdpbi1vdXQnICYmIG1vZGUgIT09ICdvdXQtaW4nKSB7XG4gICAgICB3YXJuKFxuICAgICAgICAnaW52YWxpZCA8dHJhbnNpdGlvbj4gbW9kZTogJyArIG1vZGUsXG4gICAgICAgIHRoaXMuJHBhcmVudFxuICAgICAgKTtcbiAgICB9XG5cbiAgICB2YXIgcmF3Q2hpbGQgPSBjaGlsZHJlblswXTtcblxuICAgIC8vIGlmIHRoaXMgaXMgYSBjb21wb25lbnQgcm9vdCBub2RlIGFuZCB0aGUgY29tcG9uZW50J3NcbiAgICAvLyBwYXJlbnQgY29udGFpbmVyIG5vZGUgYWxzbyBoYXMgdHJhbnNpdGlvbiwgc2tpcC5cbiAgICBpZiAoaGFzUGFyZW50VHJhbnNpdGlvbih0aGlzLiR2bm9kZSkpIHtcbiAgICAgIHJldHVybiByYXdDaGlsZFxuICAgIH1cblxuICAgIC8vIGFwcGx5IHRyYW5zaXRpb24gZGF0YSB0byBjaGlsZFxuICAgIC8vIHVzZSBnZXRSZWFsQ2hpbGQoKSB0byBpZ25vcmUgYWJzdHJhY3QgY29tcG9uZW50cyBlLmcuIGtlZXAtYWxpdmVcbiAgICB2YXIgY2hpbGQgPSBnZXRSZWFsQ2hpbGQocmF3Q2hpbGQpO1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmICghY2hpbGQpIHtcbiAgICAgIHJldHVybiByYXdDaGlsZFxuICAgIH1cblxuICAgIGlmICh0aGlzLl9sZWF2aW5nKSB7XG4gICAgICByZXR1cm4gcGxhY2Vob2xkZXIoaCwgcmF3Q2hpbGQpXG4gICAgfVxuXG4gICAgdmFyIGtleSA9IGNoaWxkLmtleSA9IGNoaWxkLmtleSA9PSBudWxsIHx8IGNoaWxkLmlzU3RhdGljXG4gICAgICA/IChcIl9fdlwiICsgKGNoaWxkLnRhZyArIHRoaXMuX3VpZCkgKyBcIl9fXCIpXG4gICAgICA6IGNoaWxkLmtleTtcbiAgICB2YXIgZGF0YSA9IChjaGlsZC5kYXRhIHx8IChjaGlsZC5kYXRhID0ge30pKS50cmFuc2l0aW9uID0gZXh0cmFjdFRyYW5zaXRpb25EYXRhKHRoaXMpO1xuICAgIHZhciBvbGRSYXdDaGlsZCA9IHRoaXMuX3Zub2RlO1xuICAgIHZhciBvbGRDaGlsZCA9IGdldFJlYWxDaGlsZChvbGRSYXdDaGlsZCk7XG5cbiAgICAvLyBtYXJrIHYtc2hvd1xuICAgIC8vIHNvIHRoYXQgdGhlIHRyYW5zaXRpb24gbW9kdWxlIGNhbiBoYW5kIG92ZXIgdGhlIGNvbnRyb2wgdG8gdGhlIGRpcmVjdGl2ZVxuICAgIGlmIChjaGlsZC5kYXRhLmRpcmVjdGl2ZXMgJiYgY2hpbGQuZGF0YS5kaXJlY3RpdmVzLnNvbWUoZnVuY3Rpb24gKGQpIHsgcmV0dXJuIGQubmFtZSA9PT0gJ3Nob3cnOyB9KSkge1xuICAgICAgY2hpbGQuZGF0YS5zaG93ID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAob2xkQ2hpbGQgJiYgb2xkQ2hpbGQuZGF0YSAmJiBvbGRDaGlsZC5rZXkgIT09IGtleSkge1xuICAgICAgLy8gcmVwbGFjZSBvbGQgY2hpbGQgdHJhbnNpdGlvbiBkYXRhIHdpdGggZnJlc2ggb25lXG4gICAgICAvLyBpbXBvcnRhbnQgZm9yIGR5bmFtaWMgdHJhbnNpdGlvbnMhXG4gICAgICB2YXIgb2xkRGF0YSA9IG9sZENoaWxkLmRhdGEudHJhbnNpdGlvbiA9IGV4dGVuZCh7fSwgZGF0YSk7XG5cbiAgICAgIC8vIGhhbmRsZSB0cmFuc2l0aW9uIG1vZGVcbiAgICAgIGlmIChtb2RlID09PSAnb3V0LWluJykge1xuICAgICAgICAvLyByZXR1cm4gcGxhY2Vob2xkZXIgbm9kZSBhbmQgcXVldWUgdXBkYXRlIHdoZW4gbGVhdmUgZmluaXNoZXNcbiAgICAgICAgdGhpcy5fbGVhdmluZyA9IHRydWU7XG4gICAgICAgIG1lcmdlVk5vZGVIb29rKG9sZERhdGEsICdhZnRlckxlYXZlJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHRoaXMkMS5fbGVhdmluZyA9IGZhbHNlO1xuICAgICAgICAgIHRoaXMkMS4kZm9yY2VVcGRhdGUoKTtcbiAgICAgICAgfSwga2V5KTtcbiAgICAgICAgcmV0dXJuIHBsYWNlaG9sZGVyKGgsIHJhd0NoaWxkKVxuICAgICAgfSBlbHNlIGlmIChtb2RlID09PSAnaW4tb3V0Jykge1xuICAgICAgICB2YXIgZGVsYXllZExlYXZlO1xuICAgICAgICB2YXIgcGVyZm9ybUxlYXZlID0gZnVuY3Rpb24gKCkgeyBkZWxheWVkTGVhdmUoKTsgfTtcbiAgICAgICAgbWVyZ2VWTm9kZUhvb2soZGF0YSwgJ2FmdGVyRW50ZXInLCBwZXJmb3JtTGVhdmUsIGtleSk7XG4gICAgICAgIG1lcmdlVk5vZGVIb29rKGRhdGEsICdlbnRlckNhbmNlbGxlZCcsIHBlcmZvcm1MZWF2ZSwga2V5KTtcbiAgICAgICAgbWVyZ2VWTm9kZUhvb2sob2xkRGF0YSwgJ2RlbGF5TGVhdmUnLCBmdW5jdGlvbiAobGVhdmUpIHtcbiAgICAgICAgICBkZWxheWVkTGVhdmUgPSBsZWF2ZTtcbiAgICAgICAgfSwga2V5KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmF3Q2hpbGRcbiAgfVxufTtcblxuLyogICovXG5cbi8vIFByb3ZpZGVzIHRyYW5zaXRpb24gc3VwcG9ydCBmb3IgbGlzdCBpdGVtcy5cbi8vIHN1cHBvcnRzIG1vdmUgdHJhbnNpdGlvbnMgdXNpbmcgdGhlIEZMSVAgdGVjaG5pcXVlLlxuXG4vLyBCZWNhdXNlIHRoZSB2ZG9tJ3MgY2hpbGRyZW4gdXBkYXRlIGFsZ29yaXRobSBpcyBcInVuc3RhYmxlXCIgLSBpLmUuXG4vLyBpdCBkb2Vzbid0IGd1YXJhbnRlZSB0aGUgcmVsYXRpdmUgcG9zaXRpb25pbmcgb2YgcmVtb3ZlZCBlbGVtZW50cyxcbi8vIHdlIGZvcmNlIHRyYW5zaXRpb24tZ3JvdXAgdG8gdXBkYXRlIGl0cyBjaGlsZHJlbiBpbnRvIHR3byBwYXNzZXM6XG4vLyBpbiB0aGUgZmlyc3QgcGFzcywgd2UgcmVtb3ZlIGFsbCBub2RlcyB0aGF0IG5lZWQgdG8gYmUgcmVtb3ZlZCxcbi8vIHRyaWdnZXJpbmcgdGhlaXIgbGVhdmluZyB0cmFuc2l0aW9uOyBpbiB0aGUgc2Vjb25kIHBhc3MsIHdlIGluc2VydC9tb3ZlXG4vLyBpbnRvIHRoZSBmaW5hbCBkaXNpcmVkIHN0YXRlLiBUaGlzIHdheSBpbiB0aGUgc2Vjb25kIHBhc3MgcmVtb3ZlZFxuLy8gbm9kZXMgd2lsbCByZW1haW4gd2hlcmUgdGhleSBzaG91bGQgYmUuXG5cbnZhciBwcm9wcyA9IGV4dGVuZCh7XG4gIHRhZzogU3RyaW5nLFxuICBtb3ZlQ2xhc3M6IFN0cmluZ1xufSwgdHJhbnNpdGlvblByb3BzKTtcblxuZGVsZXRlIHByb3BzLm1vZGU7XG5cbnZhciBUcmFuc2l0aW9uR3JvdXAgPSB7XG4gIHByb3BzOiBwcm9wcyxcblxuICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlciAoaCkge1xuICAgIHZhciB0YWcgPSB0aGlzLnRhZyB8fCB0aGlzLiR2bm9kZS5kYXRhLnRhZyB8fCAnc3Bhbic7XG4gICAgdmFyIG1hcCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdmFyIHByZXZDaGlsZHJlbiA9IHRoaXMucHJldkNoaWxkcmVuID0gdGhpcy5jaGlsZHJlbjtcbiAgICB2YXIgcmF3Q2hpbGRyZW4gPSB0aGlzLiRzbG90cy5kZWZhdWx0IHx8IFtdO1xuICAgIHZhciBjaGlsZHJlbiA9IHRoaXMuY2hpbGRyZW4gPSBbXTtcbiAgICB2YXIgdHJhbnNpdGlvbkRhdGEgPSBleHRyYWN0VHJhbnNpdGlvbkRhdGEodGhpcyk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJhd0NoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgYyA9IHJhd0NoaWxkcmVuW2ldO1xuICAgICAgaWYgKGMudGFnKSB7XG4gICAgICAgIGlmIChjLmtleSAhPSBudWxsICYmIFN0cmluZyhjLmtleSkuaW5kZXhPZignX192bGlzdCcpICE9PSAwKSB7XG4gICAgICAgICAgY2hpbGRyZW4ucHVzaChjKTtcbiAgICAgICAgICBtYXBbYy5rZXldID0gY1xuICAgICAgICAgIDsoYy5kYXRhIHx8IChjLmRhdGEgPSB7fSkpLnRyYW5zaXRpb24gPSB0cmFuc2l0aW9uRGF0YTtcbiAgICAgICAgfSBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgdmFyIG9wdHMgPSBjLmNvbXBvbmVudE9wdGlvbnM7XG4gICAgICAgICAgdmFyIG5hbWUgPSBvcHRzXG4gICAgICAgICAgICA/IChvcHRzLkN0b3Iub3B0aW9ucy5uYW1lIHx8IG9wdHMudGFnKVxuICAgICAgICAgICAgOiBjLnRhZztcbiAgICAgICAgICB3YXJuKChcIjx0cmFuc2l0aW9uLWdyb3VwPiBjaGlsZHJlbiBtdXN0IGJlIGtleWVkOiA8XCIgKyBuYW1lICsgXCI+XCIpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChwcmV2Q2hpbGRyZW4pIHtcbiAgICAgIHZhciBrZXB0ID0gW107XG4gICAgICB2YXIgcmVtb3ZlZCA9IFtdO1xuICAgICAgZm9yICh2YXIgaSQxID0gMDsgaSQxIDwgcHJldkNoaWxkcmVuLmxlbmd0aDsgaSQxKyspIHtcbiAgICAgICAgdmFyIGMkMSA9IHByZXZDaGlsZHJlbltpJDFdO1xuICAgICAgICBjJDEuZGF0YS50cmFuc2l0aW9uID0gdHJhbnNpdGlvbkRhdGE7XG4gICAgICAgIGMkMS5kYXRhLnBvcyA9IGMkMS5lbG0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIGlmIChtYXBbYyQxLmtleV0pIHtcbiAgICAgICAgICBrZXB0LnB1c2goYyQxKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZW1vdmVkLnB1c2goYyQxKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5rZXB0ID0gaCh0YWcsIG51bGwsIGtlcHQpO1xuICAgICAgdGhpcy5yZW1vdmVkID0gcmVtb3ZlZDtcbiAgICB9XG5cbiAgICByZXR1cm4gaCh0YWcsIG51bGwsIGNoaWxkcmVuKVxuICB9LFxuXG4gIGJlZm9yZVVwZGF0ZTogZnVuY3Rpb24gYmVmb3JlVXBkYXRlICgpIHtcbiAgICAvLyBmb3JjZSByZW1vdmluZyBwYXNzXG4gICAgdGhpcy5fX3BhdGNoX18oXG4gICAgICB0aGlzLl92bm9kZSxcbiAgICAgIHRoaXMua2VwdCxcbiAgICAgIGZhbHNlLCAvLyBoeWRyYXRpbmdcbiAgICAgIHRydWUgLy8gcmVtb3ZlT25seSAoIWltcG9ydGFudCwgYXZvaWRzIHVubmVjZXNzYXJ5IG1vdmVzKVxuICAgICk7XG4gICAgdGhpcy5fdm5vZGUgPSB0aGlzLmtlcHQ7XG4gIH0sXG5cbiAgdXBkYXRlZDogZnVuY3Rpb24gdXBkYXRlZCAoKSB7XG4gICAgdmFyIGNoaWxkcmVuID0gdGhpcy5wcmV2Q2hpbGRyZW47XG4gICAgdmFyIG1vdmVDbGFzcyA9IHRoaXMubW92ZUNsYXNzIHx8ICgodGhpcy5uYW1lIHx8ICd2JykgKyAnLW1vdmUnKTtcbiAgICBpZiAoIWNoaWxkcmVuLmxlbmd0aCB8fCAhdGhpcy5oYXNNb3ZlKGNoaWxkcmVuWzBdLmVsbSwgbW92ZUNsYXNzKSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgLy8gd2UgZGl2aWRlIHRoZSB3b3JrIGludG8gdGhyZWUgbG9vcHMgdG8gYXZvaWQgbWl4aW5nIERPTSByZWFkcyBhbmQgd3JpdGVzXG4gICAgLy8gaW4gZWFjaCBpdGVyYXRpb24gLSB3aGljaCBoZWxwcyBwcmV2ZW50IGxheW91dCB0aHJhc2hpbmcuXG4gICAgY2hpbGRyZW4uZm9yRWFjaChjYWxsUGVuZGluZ0Nicyk7XG4gICAgY2hpbGRyZW4uZm9yRWFjaChyZWNvcmRQb3NpdGlvbik7XG4gICAgY2hpbGRyZW4uZm9yRWFjaChhcHBseVRyYW5zbGF0aW9uKTtcblxuICAgIC8vIGZvcmNlIHJlZmxvdyB0byBwdXQgZXZlcnl0aGluZyBpbiBwb3NpdGlvblxuICAgIHZhciBmID0gZG9jdW1lbnQuYm9keS5vZmZzZXRIZWlnaHQ7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcblxuICAgIGNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGMpIHtcbiAgICAgIGlmIChjLmRhdGEubW92ZWQpIHtcbiAgICAgICAgdmFyIGVsID0gYy5lbG07XG4gICAgICAgIHZhciBzID0gZWwuc3R5bGU7XG4gICAgICAgIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgbW92ZUNsYXNzKTtcbiAgICAgICAgcy50cmFuc2Zvcm0gPSBzLldlYmtpdFRyYW5zZm9ybSA9IHMudHJhbnNpdGlvbkR1cmF0aW9uID0gJyc7XG4gICAgICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIodHJhbnNpdGlvbkVuZEV2ZW50LCBlbC5fbW92ZUNiID0gZnVuY3Rpb24gY2IgKGUpIHtcbiAgICAgICAgICBpZiAoIWUgfHwgL3RyYW5zZm9ybSQvLnRlc3QoZS5wcm9wZXJ0eU5hbWUpKSB7XG4gICAgICAgICAgICBlbC5yZW1vdmVFdmVudExpc3RlbmVyKHRyYW5zaXRpb25FbmRFdmVudCwgY2IpO1xuICAgICAgICAgICAgZWwuX21vdmVDYiA9IG51bGw7XG4gICAgICAgICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIG1vdmVDbGFzcyk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSxcblxuICBtZXRob2RzOiB7XG4gICAgaGFzTW92ZTogZnVuY3Rpb24gaGFzTW92ZSAoZWwsIG1vdmVDbGFzcykge1xuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICBpZiAoIWhhc1RyYW5zaXRpb24pIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG4gICAgICBpZiAodGhpcy5faGFzTW92ZSAhPSBudWxsKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9oYXNNb3ZlXG4gICAgICB9XG4gICAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIG1vdmVDbGFzcyk7XG4gICAgICB2YXIgaW5mbyA9IGdldFRyYW5zaXRpb25JbmZvKGVsKTtcbiAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgbW92ZUNsYXNzKTtcbiAgICAgIHJldHVybiAodGhpcy5faGFzTW92ZSA9IGluZm8uaGFzVHJhbnNmb3JtKVxuICAgIH1cbiAgfVxufTtcblxuZnVuY3Rpb24gY2FsbFBlbmRpbmdDYnMgKGMpIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChjLmVsbS5fbW92ZUNiKSB7XG4gICAgYy5lbG0uX21vdmVDYigpO1xuICB9XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoYy5lbG0uX2VudGVyQ2IpIHtcbiAgICBjLmVsbS5fZW50ZXJDYigpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlY29yZFBvc2l0aW9uIChjKSB7XG4gIGMuZGF0YS5uZXdQb3MgPSBjLmVsbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbn1cblxuZnVuY3Rpb24gYXBwbHlUcmFuc2xhdGlvbiAoYykge1xuICB2YXIgb2xkUG9zID0gYy5kYXRhLnBvcztcbiAgdmFyIG5ld1BvcyA9IGMuZGF0YS5uZXdQb3M7XG4gIHZhciBkeCA9IG9sZFBvcy5sZWZ0IC0gbmV3UG9zLmxlZnQ7XG4gIHZhciBkeSA9IG9sZFBvcy50b3AgLSBuZXdQb3MudG9wO1xuICBpZiAoZHggfHwgZHkpIHtcbiAgICBjLmRhdGEubW92ZWQgPSB0cnVlO1xuICAgIHZhciBzID0gYy5lbG0uc3R5bGU7XG4gICAgcy50cmFuc2Zvcm0gPSBzLldlYmtpdFRyYW5zZm9ybSA9IFwidHJhbnNsYXRlKFwiICsgZHggKyBcInB4LFwiICsgZHkgKyBcInB4KVwiO1xuICAgIHMudHJhbnNpdGlvbkR1cmF0aW9uID0gJzBzJztcbiAgfVxufVxuXG52YXIgcGxhdGZvcm1Db21wb25lbnRzID0ge1xuICBUcmFuc2l0aW9uOiBUcmFuc2l0aW9uLFxuICBUcmFuc2l0aW9uR3JvdXA6IFRyYW5zaXRpb25Hcm91cFxufTtcblxuLyogICovXG5cbi8vIGluc3RhbGwgcGxhdGZvcm0gc3BlY2lmaWMgdXRpbHNcblZ1ZSQyLmNvbmZpZy5pc1Vua25vd25FbGVtZW50ID0gaXNVbmtub3duRWxlbWVudDtcblZ1ZSQyLmNvbmZpZy5pc1Jlc2VydmVkVGFnID0gaXNSZXNlcnZlZFRhZztcblZ1ZSQyLmNvbmZpZy5nZXRUYWdOYW1lc3BhY2UgPSBnZXRUYWdOYW1lc3BhY2U7XG5WdWUkMi5jb25maWcubXVzdFVzZVByb3AgPSBtdXN0VXNlUHJvcDtcblxuLy8gaW5zdGFsbCBwbGF0Zm9ybSBydW50aW1lIGRpcmVjdGl2ZXMgJiBjb21wb25lbnRzXG5leHRlbmQoVnVlJDIub3B0aW9ucy5kaXJlY3RpdmVzLCBwbGF0Zm9ybURpcmVjdGl2ZXMpO1xuZXh0ZW5kKFZ1ZSQyLm9wdGlvbnMuY29tcG9uZW50cywgcGxhdGZvcm1Db21wb25lbnRzKTtcblxuLy8gaW5zdGFsbCBwbGF0Zm9ybSBwYXRjaCBmdW5jdGlvblxuVnVlJDIucHJvdG90eXBlLl9fcGF0Y2hfXyA9IGNvbmZpZy5faXNTZXJ2ZXIgPyBub29wIDogcGF0Y2gkMTtcblxuLy8gd3JhcCBtb3VudFxuVnVlJDIucHJvdG90eXBlLiRtb3VudCA9IGZ1bmN0aW9uIChcbiAgZWwsXG4gIGh5ZHJhdGluZ1xuKSB7XG4gIGVsID0gZWwgJiYgIWNvbmZpZy5faXNTZXJ2ZXIgPyBxdWVyeShlbCkgOiB1bmRlZmluZWQ7XG4gIHJldHVybiB0aGlzLl9tb3VudChlbCwgaHlkcmF0aW5nKVxufTtcblxuLy8gZGV2dG9vbHMgZ2xvYmFsIGhvb2tcbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5zZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgaWYgKGNvbmZpZy5kZXZ0b29scykge1xuICAgIGlmIChkZXZ0b29scykge1xuICAgICAgZGV2dG9vbHMuZW1pdCgnaW5pdCcsIFZ1ZSQyKTtcbiAgICB9IGVsc2UgaWYgKFxuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJlxuICAgICAgaW5Ccm93c2VyICYmIC9DaHJvbWVcXC9cXGQrLy50ZXN0KHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50KVxuICAgICkge1xuICAgICAgY29uc29sZS5sb2coXG4gICAgICAgICdEb3dubG9hZCB0aGUgVnVlIERldnRvb2xzIGZvciBhIGJldHRlciBkZXZlbG9wbWVudCBleHBlcmllbmNlOlxcbicgK1xuICAgICAgICAnaHR0cHM6Ly9naXRodWIuY29tL3Z1ZWpzL3Z1ZS1kZXZ0b29scydcbiAgICAgICk7XG4gICAgfVxuICB9XG59LCAwKTtcblxubW9kdWxlLmV4cG9ydHMgPSBWdWUkMjtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi8uMi4wLjhAdnVlL2Rpc3QvdnVlLmNvbW1vbi5qc1xuLy8gbW9kdWxlIGlkID0gMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ },
/* 2 */
/***/ function(module, exports) {

	eval("// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+Ly4wLjExLjlAcHJvY2Vzcy9icm93c2VyLmpzPzNiZWUiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixzQkFBc0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsVUFBVSIsImZpbGUiOiIyLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gc2hpbSBmb3IgdXNpbmcgcHJvY2VzcyBpbiBicm93c2VyXG52YXIgcHJvY2VzcyA9IG1vZHVsZS5leHBvcnRzID0ge307XG5cbi8vIGNhY2hlZCBmcm9tIHdoYXRldmVyIGdsb2JhbCBpcyBwcmVzZW50IHNvIHRoYXQgdGVzdCBydW5uZXJzIHRoYXQgc3R1YiBpdFxuLy8gZG9uJ3QgYnJlYWsgdGhpbmdzLiAgQnV0IHdlIG5lZWQgdG8gd3JhcCBpdCBpbiBhIHRyeSBjYXRjaCBpbiBjYXNlIGl0IGlzXG4vLyB3cmFwcGVkIGluIHN0cmljdCBtb2RlIGNvZGUgd2hpY2ggZG9lc24ndCBkZWZpbmUgYW55IGdsb2JhbHMuICBJdCdzIGluc2lkZSBhXG4vLyBmdW5jdGlvbiBiZWNhdXNlIHRyeS9jYXRjaGVzIGRlb3B0aW1pemUgaW4gY2VydGFpbiBlbmdpbmVzLlxuXG52YXIgY2FjaGVkU2V0VGltZW91dDtcbnZhciBjYWNoZWRDbGVhclRpbWVvdXQ7XG5cbmZ1bmN0aW9uIGRlZmF1bHRTZXRUaW1vdXQoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdzZXRUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG5mdW5jdGlvbiBkZWZhdWx0Q2xlYXJUaW1lb3V0ICgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2NsZWFyVGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuKGZ1bmN0aW9uICgpIHtcbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIHNldFRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIGNsZWFyVGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICB9XG59ICgpKVxuZnVuY3Rpb24gcnVuVGltZW91dChmdW4pIHtcbiAgICBpZiAoY2FjaGVkU2V0VGltZW91dCA9PT0gc2V0VGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgLy8gaWYgc2V0VGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZFNldFRpbWVvdXQgPT09IGRlZmF1bHRTZXRUaW1vdXQgfHwgIWNhY2hlZFNldFRpbWVvdXQpICYmIHNldFRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9IGNhdGNoKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0IHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKG51bGwsIGZ1biwgMCk7XG4gICAgICAgIH0gY2F0Y2goZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvclxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbCh0aGlzLCBmdW4sIDApO1xuICAgICAgICB9XG4gICAgfVxuXG5cbn1cbmZ1bmN0aW9uIHJ1bkNsZWFyVGltZW91dChtYXJrZXIpIHtcbiAgICBpZiAoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgLy8gaWYgY2xlYXJUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBkZWZhdWx0Q2xlYXJUaW1lb3V0IHx8ICFjYWNoZWRDbGVhclRpbWVvdXQpICYmIGNsZWFyVGltZW91dCkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfSBjYXRjaCAoZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgIHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwobnVsbCwgbWFya2VyKTtcbiAgICAgICAgfSBjYXRjaCAoZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvci5cbiAgICAgICAgICAgIC8vIFNvbWUgdmVyc2lvbnMgb2YgSS5FLiBoYXZlIGRpZmZlcmVudCBydWxlcyBmb3IgY2xlYXJUaW1lb3V0IHZzIHNldFRpbWVvdXRcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbCh0aGlzLCBtYXJrZXIpO1xuICAgICAgICB9XG4gICAgfVxuXG5cblxufVxudmFyIHF1ZXVlID0gW107XG52YXIgZHJhaW5pbmcgPSBmYWxzZTtcbnZhciBjdXJyZW50UXVldWU7XG52YXIgcXVldWVJbmRleCA9IC0xO1xuXG5mdW5jdGlvbiBjbGVhblVwTmV4dFRpY2soKSB7XG4gICAgaWYgKCFkcmFpbmluZyB8fCAhY3VycmVudFF1ZXVlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBpZiAoY3VycmVudFF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBxdWV1ZSA9IGN1cnJlbnRRdWV1ZS5jb25jYXQocXVldWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICB9XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBkcmFpblF1ZXVlKCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBkcmFpblF1ZXVlKCkge1xuICAgIGlmIChkcmFpbmluZykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciB0aW1lb3V0ID0gcnVuVGltZW91dChjbGVhblVwTmV4dFRpY2spO1xuICAgIGRyYWluaW5nID0gdHJ1ZTtcblxuICAgIHZhciBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgd2hpbGUobGVuKSB7XG4gICAgICAgIGN1cnJlbnRRdWV1ZSA9IHF1ZXVlO1xuICAgICAgICBxdWV1ZSA9IFtdO1xuICAgICAgICB3aGlsZSAoKytxdWV1ZUluZGV4IDwgbGVuKSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudFF1ZXVlKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFF1ZXVlW3F1ZXVlSW5kZXhdLnJ1bigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICAgICAgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIH1cbiAgICBjdXJyZW50UXVldWUgPSBudWxsO1xuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgcnVuQ2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xufVxuXG5wcm9jZXNzLm5leHRUaWNrID0gZnVuY3Rpb24gKGZ1bikge1xuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHF1ZXVlLnB1c2gobmV3IEl0ZW0oZnVuLCBhcmdzKSk7XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCA9PT0gMSAmJiAhZHJhaW5pbmcpIHtcbiAgICAgICAgcnVuVGltZW91dChkcmFpblF1ZXVlKTtcbiAgICB9XG59O1xuXG4vLyB2OCBsaWtlcyBwcmVkaWN0aWJsZSBvYmplY3RzXG5mdW5jdGlvbiBJdGVtKGZ1biwgYXJyYXkpIHtcbiAgICB0aGlzLmZ1biA9IGZ1bjtcbiAgICB0aGlzLmFycmF5ID0gYXJyYXk7XG59XG5JdGVtLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5mdW4uYXBwbHkobnVsbCwgdGhpcy5hcnJheSk7XG59O1xucHJvY2Vzcy50aXRsZSA9ICdicm93c2VyJztcbnByb2Nlc3MuYnJvd3NlciA9IHRydWU7XG5wcm9jZXNzLmVudiA9IHt9O1xucHJvY2Vzcy5hcmd2ID0gW107XG5wcm9jZXNzLnZlcnNpb24gPSAnJzsgLy8gZW1wdHkgc3RyaW5nIHRvIGF2b2lkIHJlZ2V4cCBpc3N1ZXNcbnByb2Nlc3MudmVyc2lvbnMgPSB7fTtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbnByb2Nlc3Mub24gPSBub29wO1xucHJvY2Vzcy5hZGRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLm9uY2UgPSBub29wO1xucHJvY2Vzcy5vZmYgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUFsbExpc3RlbmVycyA9IG5vb3A7XG5wcm9jZXNzLmVtaXQgPSBub29wO1xuXG5wcm9jZXNzLmJpbmRpbmcgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5cbnByb2Nlc3MuY3dkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJy8nIH07XG5wcm9jZXNzLmNoZGlyID0gZnVuY3Rpb24gKGRpcikge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xucHJvY2Vzcy51bWFzayA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gMDsgfTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi8uMC4xMS45QHByb2Nlc3MvYnJvd3Nlci5qc1xuLy8gbW9kdWxlIGlkID0gMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAgMSJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ },
/* 3 */,
/* 4 */,
/* 5 */,
/* 6 */
/***/ function(module, exports) {

	eval("/*\r\n\tMIT License http://www.opensource.org/licenses/mit-license.php\r\n\tAuthor Tobias Koppers @sokra\r\n*/\r\n// css base code, injected by the css-loader\r\nmodule.exports = function() {\r\n\tvar list = [];\r\n\r\n\t// return the list of modules as css string\r\n\tlist.toString = function toString() {\r\n\t\tvar result = [];\r\n\t\tfor(var i = 0; i < this.length; i++) {\r\n\t\t\tvar item = this[i];\r\n\t\t\tif(item[2]) {\r\n\t\t\t\tresult.push(\"@media \" + item[2] + \"{\" + item[1] + \"}\");\r\n\t\t\t} else {\r\n\t\t\t\tresult.push(item[1]);\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn result.join(\"\");\r\n\t};\r\n\r\n\t// import a list of modules into the list\r\n\tlist.i = function(modules, mediaQuery) {\r\n\t\tif(typeof modules === \"string\")\r\n\t\t\tmodules = [[null, modules, \"\"]];\r\n\t\tvar alreadyImportedModules = {};\r\n\t\tfor(var i = 0; i < this.length; i++) {\r\n\t\t\tvar id = this[i][0];\r\n\t\t\tif(typeof id === \"number\")\r\n\t\t\t\talreadyImportedModules[id] = true;\r\n\t\t}\r\n\t\tfor(i = 0; i < modules.length; i++) {\r\n\t\t\tvar item = modules[i];\r\n\t\t\t// skip already imported module\r\n\t\t\t// this implementation is not 100% perfect for weird media query combinations\r\n\t\t\t//  when a module is imported multiple times with different media queries.\r\n\t\t\t//  I hope this will never occur (Hey this way we have smaller bundles)\r\n\t\t\tif(typeof item[0] !== \"number\" || !alreadyImportedModules[item[0]]) {\r\n\t\t\t\tif(mediaQuery && !item[2]) {\r\n\t\t\t\t\titem[2] = mediaQuery;\r\n\t\t\t\t} else if(mediaQuery) {\r\n\t\t\t\t\titem[2] = \"(\" + item[2] + \") and (\" + mediaQuery + \")\";\r\n\t\t\t\t}\r\n\t\t\t\tlist.push(item);\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n\treturn list;\r\n};\r\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+Ly4wLjI1LjBAY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanM/ZmU5MCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsaUJBQWlCO0FBQ2pDO0FBQ0E7QUFDQSx3Q0FBd0MsZ0JBQWdCO0FBQ3hELElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsaUJBQWlCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxvQkFBb0I7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6IjYuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKlxyXG5cdE1JVCBMaWNlbnNlIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXHJcblx0QXV0aG9yIFRvYmlhcyBLb3BwZXJzIEBzb2tyYVxyXG4qL1xyXG4vLyBjc3MgYmFzZSBjb2RlLCBpbmplY3RlZCBieSB0aGUgY3NzLWxvYWRlclxyXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKCkge1xyXG5cdHZhciBsaXN0ID0gW107XHJcblxyXG5cdC8vIHJldHVybiB0aGUgbGlzdCBvZiBtb2R1bGVzIGFzIGNzcyBzdHJpbmdcclxuXHRsaXN0LnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XHJcblx0XHR2YXIgcmVzdWx0ID0gW107XHJcblx0XHRmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHR2YXIgaXRlbSA9IHRoaXNbaV07XHJcblx0XHRcdGlmKGl0ZW1bMl0pIHtcclxuXHRcdFx0XHRyZXN1bHQucHVzaChcIkBtZWRpYSBcIiArIGl0ZW1bMl0gKyBcIntcIiArIGl0ZW1bMV0gKyBcIn1cIik7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0cmVzdWx0LnB1c2goaXRlbVsxXSk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdHJldHVybiByZXN1bHQuam9pbihcIlwiKTtcclxuXHR9O1xyXG5cclxuXHQvLyBpbXBvcnQgYSBsaXN0IG9mIG1vZHVsZXMgaW50byB0aGUgbGlzdFxyXG5cdGxpc3QuaSA9IGZ1bmN0aW9uKG1vZHVsZXMsIG1lZGlhUXVlcnkpIHtcclxuXHRcdGlmKHR5cGVvZiBtb2R1bGVzID09PSBcInN0cmluZ1wiKVxyXG5cdFx0XHRtb2R1bGVzID0gW1tudWxsLCBtb2R1bGVzLCBcIlwiXV07XHJcblx0XHR2YXIgYWxyZWFkeUltcG9ydGVkTW9kdWxlcyA9IHt9O1xyXG5cdFx0Zm9yKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0dmFyIGlkID0gdGhpc1tpXVswXTtcclxuXHRcdFx0aWYodHlwZW9mIGlkID09PSBcIm51bWJlclwiKVxyXG5cdFx0XHRcdGFscmVhZHlJbXBvcnRlZE1vZHVsZXNbaWRdID0gdHJ1ZTtcclxuXHRcdH1cclxuXHRcdGZvcihpID0gMDsgaSA8IG1vZHVsZXMubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0dmFyIGl0ZW0gPSBtb2R1bGVzW2ldO1xyXG5cdFx0XHQvLyBza2lwIGFscmVhZHkgaW1wb3J0ZWQgbW9kdWxlXHJcblx0XHRcdC8vIHRoaXMgaW1wbGVtZW50YXRpb24gaXMgbm90IDEwMCUgcGVyZmVjdCBmb3Igd2VpcmQgbWVkaWEgcXVlcnkgY29tYmluYXRpb25zXHJcblx0XHRcdC8vICB3aGVuIGEgbW9kdWxlIGlzIGltcG9ydGVkIG11bHRpcGxlIHRpbWVzIHdpdGggZGlmZmVyZW50IG1lZGlhIHF1ZXJpZXMuXHJcblx0XHRcdC8vICBJIGhvcGUgdGhpcyB3aWxsIG5ldmVyIG9jY3VyIChIZXkgdGhpcyB3YXkgd2UgaGF2ZSBzbWFsbGVyIGJ1bmRsZXMpXHJcblx0XHRcdGlmKHR5cGVvZiBpdGVtWzBdICE9PSBcIm51bWJlclwiIHx8ICFhbHJlYWR5SW1wb3J0ZWRNb2R1bGVzW2l0ZW1bMF1dKSB7XHJcblx0XHRcdFx0aWYobWVkaWFRdWVyeSAmJiAhaXRlbVsyXSkge1xyXG5cdFx0XHRcdFx0aXRlbVsyXSA9IG1lZGlhUXVlcnk7XHJcblx0XHRcdFx0fSBlbHNlIGlmKG1lZGlhUXVlcnkpIHtcclxuXHRcdFx0XHRcdGl0ZW1bMl0gPSBcIihcIiArIGl0ZW1bMl0gKyBcIikgYW5kIChcIiArIG1lZGlhUXVlcnkgKyBcIilcIjtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0bGlzdC5wdXNoKGl0ZW0pO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fTtcclxuXHRyZXR1cm4gbGlzdDtcclxufTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+Ly4wLjI1LjBAY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanNcbi8vIG1vZHVsZSBpZCA9IDZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiXSwic291cmNlUm9vdCI6IiJ9");

/***/ },
/* 7 */
/***/ function(module, exports, __webpack_require__) {

	eval("/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\nvar stylesInDom = {},\n\tmemoize = function(fn) {\n\t\tvar memo;\n\t\treturn function () {\n\t\t\tif (typeof memo === \"undefined\") memo = fn.apply(this, arguments);\n\t\t\treturn memo;\n\t\t};\n\t},\n\tisOldIE = memoize(function() {\n\t\treturn /msie [6-9]\\b/.test(window.navigator.userAgent.toLowerCase());\n\t}),\n\tgetHeadElement = memoize(function () {\n\t\treturn document.head || document.getElementsByTagName(\"head\")[0];\n\t}),\n\tsingletonElement = null,\n\tsingletonCounter = 0,\n\tstyleElementsInsertedAtTop = [];\n\nmodule.exports = function(list, options) {\n\tif(false) {\n\t\tif(typeof document !== \"object\") throw new Error(\"The style-loader cannot be used in a non-browser environment\");\n\t}\n\n\toptions = options || {};\n\t// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>\n\t// tags it will allow on a page\n\tif (typeof options.singleton === \"undefined\") options.singleton = isOldIE();\n\n\t// By default, add <style> tags to the bottom of <head>.\n\tif (typeof options.insertAt === \"undefined\") options.insertAt = \"bottom\";\n\n\tvar styles = listToStyles(list);\n\taddStylesToDom(styles, options);\n\n\treturn function update(newList) {\n\t\tvar mayRemove = [];\n\t\tfor(var i = 0; i < styles.length; i++) {\n\t\t\tvar item = styles[i];\n\t\t\tvar domStyle = stylesInDom[item.id];\n\t\t\tdomStyle.refs--;\n\t\t\tmayRemove.push(domStyle);\n\t\t}\n\t\tif(newList) {\n\t\t\tvar newStyles = listToStyles(newList);\n\t\t\taddStylesToDom(newStyles, options);\n\t\t}\n\t\tfor(var i = 0; i < mayRemove.length; i++) {\n\t\t\tvar domStyle = mayRemove[i];\n\t\t\tif(domStyle.refs === 0) {\n\t\t\t\tfor(var j = 0; j < domStyle.parts.length; j++)\n\t\t\t\t\tdomStyle.parts[j]();\n\t\t\t\tdelete stylesInDom[domStyle.id];\n\t\t\t}\n\t\t}\n\t};\n}\n\nfunction addStylesToDom(styles, options) {\n\tfor(var i = 0; i < styles.length; i++) {\n\t\tvar item = styles[i];\n\t\tvar domStyle = stylesInDom[item.id];\n\t\tif(domStyle) {\n\t\t\tdomStyle.refs++;\n\t\t\tfor(var j = 0; j < domStyle.parts.length; j++) {\n\t\t\t\tdomStyle.parts[j](item.parts[j]);\n\t\t\t}\n\t\t\tfor(; j < item.parts.length; j++) {\n\t\t\t\tdomStyle.parts.push(addStyle(item.parts[j], options));\n\t\t\t}\n\t\t} else {\n\t\t\tvar parts = [];\n\t\t\tfor(var j = 0; j < item.parts.length; j++) {\n\t\t\t\tparts.push(addStyle(item.parts[j], options));\n\t\t\t}\n\t\t\tstylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};\n\t\t}\n\t}\n}\n\nfunction listToStyles(list) {\n\tvar styles = [];\n\tvar newStyles = {};\n\tfor(var i = 0; i < list.length; i++) {\n\t\tvar item = list[i];\n\t\tvar id = item[0];\n\t\tvar css = item[1];\n\t\tvar media = item[2];\n\t\tvar sourceMap = item[3];\n\t\tvar part = {css: css, media: media, sourceMap: sourceMap};\n\t\tif(!newStyles[id])\n\t\t\tstyles.push(newStyles[id] = {id: id, parts: [part]});\n\t\telse\n\t\t\tnewStyles[id].parts.push(part);\n\t}\n\treturn styles;\n}\n\nfunction insertStyleElement(options, styleElement) {\n\tvar head = getHeadElement();\n\tvar lastStyleElementInsertedAtTop = styleElementsInsertedAtTop[styleElementsInsertedAtTop.length - 1];\n\tif (options.insertAt === \"top\") {\n\t\tif(!lastStyleElementInsertedAtTop) {\n\t\t\thead.insertBefore(styleElement, head.firstChild);\n\t\t} else if(lastStyleElementInsertedAtTop.nextSibling) {\n\t\t\thead.insertBefore(styleElement, lastStyleElementInsertedAtTop.nextSibling);\n\t\t} else {\n\t\t\thead.appendChild(styleElement);\n\t\t}\n\t\tstyleElementsInsertedAtTop.push(styleElement);\n\t} else if (options.insertAt === \"bottom\") {\n\t\thead.appendChild(styleElement);\n\t} else {\n\t\tthrow new Error(\"Invalid value for parameter 'insertAt'. Must be 'top' or 'bottom'.\");\n\t}\n}\n\nfunction removeStyleElement(styleElement) {\n\tstyleElement.parentNode.removeChild(styleElement);\n\tvar idx = styleElementsInsertedAtTop.indexOf(styleElement);\n\tif(idx >= 0) {\n\t\tstyleElementsInsertedAtTop.splice(idx, 1);\n\t}\n}\n\nfunction createStyleElement(options) {\n\tvar styleElement = document.createElement(\"style\");\n\tstyleElement.type = \"text/css\";\n\tinsertStyleElement(options, styleElement);\n\treturn styleElement;\n}\n\nfunction addStyle(obj, options) {\n\tvar styleElement, update, remove;\n\n\tif (options.singleton) {\n\t\tvar styleIndex = singletonCounter++;\n\t\tstyleElement = singletonElement || (singletonElement = createStyleElement(options));\n\t\tupdate = applyToSingletonTag.bind(null, styleElement, styleIndex, false);\n\t\tremove = applyToSingletonTag.bind(null, styleElement, styleIndex, true);\n\t} else {\n\t\tstyleElement = createStyleElement(options);\n\t\tupdate = applyToTag.bind(null, styleElement);\n\t\tremove = function() {\n\t\t\tremoveStyleElement(styleElement);\n\t\t};\n\t}\n\n\tupdate(obj);\n\n\treturn function updateStyle(newObj) {\n\t\tif(newObj) {\n\t\t\tif(newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap)\n\t\t\t\treturn;\n\t\t\tupdate(obj = newObj);\n\t\t} else {\n\t\t\tremove();\n\t\t}\n\t};\n}\n\nvar replaceText = (function () {\n\tvar textStore = [];\n\n\treturn function (index, replacement) {\n\t\ttextStore[index] = replacement;\n\t\treturn textStore.filter(Boolean).join('\\n');\n\t};\n})();\n\nfunction applyToSingletonTag(styleElement, index, remove, obj) {\n\tvar css = remove ? \"\" : obj.css;\n\n\tif (styleElement.styleSheet) {\n\t\tstyleElement.styleSheet.cssText = replaceText(index, css);\n\t} else {\n\t\tvar cssNode = document.createTextNode(css);\n\t\tvar childNodes = styleElement.childNodes;\n\t\tif (childNodes[index]) styleElement.removeChild(childNodes[index]);\n\t\tif (childNodes.length) {\n\t\t\tstyleElement.insertBefore(cssNode, childNodes[index]);\n\t\t} else {\n\t\t\tstyleElement.appendChild(cssNode);\n\t\t}\n\t}\n}\n\nfunction applyToTag(styleElement, obj) {\n\tvar css = obj.css;\n\tvar media = obj.media;\n\tvar sourceMap = obj.sourceMap;\n\n\tif (media) {\n\t\tstyleElement.setAttribute(\"media\", media);\n\t}\n\n\tif (sourceMap) {\n\t\t// https://developer.chrome.com/devtools/docs/javascript-debugging\n\t\t// this makes source maps inside style tags work properly in Chrome\n\t\tcss += '\\n/*# sourceURL=' + sourceMap.sources[0] + ' */';\n\t\t// http://stackoverflow.com/a/26603875\n\t\tcss += \"\\n/*# sourceMappingURL=data:application/json;base64,\" + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + \" */\";\n\t}\n\n\tif (styleElement.styleSheet) {\n\t\tstyleElement.styleSheet.cssText = css;\n\t} else {\n\t\twhile(styleElement.firstChild) {\n\t\t\tstyleElement.removeChild(styleElement.firstChild);\n\t\t}\n\t\tstyleElement.appendChild(document.createTextNode(css));\n\t}\n}\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+Ly4xLjAuMEB2dWUtc3R5bGUtbG9hZGVyL2FkZFN0eWxlcy5qcz9hZTFjIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0JBQWdCLG1CQUFtQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isc0JBQXNCO0FBQ3RDO0FBQ0E7QUFDQSxrQkFBa0IsMkJBQTJCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGVBQWUsbUJBQW1CO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLDJCQUEyQjtBQUM1QztBQUNBO0FBQ0EsUUFBUSx1QkFBdUI7QUFDL0I7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLGlCQUFpQix1QkFBdUI7QUFDeEM7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxpQkFBaUI7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBLGdDQUFnQyxzQkFBc0I7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVEO0FBQ3ZEOztBQUVBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6IjcuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuXHRNSVQgTGljZW5zZSBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxuXHRBdXRob3IgVG9iaWFzIEtvcHBlcnMgQHNva3JhXG4qL1xudmFyIHN0eWxlc0luRG9tID0ge30sXG5cdG1lbW9pemUgPSBmdW5jdGlvbihmbikge1xuXHRcdHZhciBtZW1vO1xuXHRcdHJldHVybiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRpZiAodHlwZW9mIG1lbW8gPT09IFwidW5kZWZpbmVkXCIpIG1lbW8gPSBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHRcdFx0cmV0dXJuIG1lbW87XG5cdFx0fTtcblx0fSxcblx0aXNPbGRJRSA9IG1lbW9pemUoZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIC9tc2llIFs2LTldXFxiLy50ZXN0KHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkpO1xuXHR9KSxcblx0Z2V0SGVhZEVsZW1lbnQgPSBtZW1vaXplKGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gZG9jdW1lbnQuaGVhZCB8fCBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZShcImhlYWRcIilbMF07XG5cdH0pLFxuXHRzaW5nbGV0b25FbGVtZW50ID0gbnVsbCxcblx0c2luZ2xldG9uQ291bnRlciA9IDAsXG5cdHN0eWxlRWxlbWVudHNJbnNlcnRlZEF0VG9wID0gW107XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24obGlzdCwgb3B0aW9ucykge1xuXHRpZih0eXBlb2YgREVCVUcgIT09IFwidW5kZWZpbmVkXCIgJiYgREVCVUcpIHtcblx0XHRpZih0eXBlb2YgZG9jdW1lbnQgIT09IFwib2JqZWN0XCIpIHRocm93IG5ldyBFcnJvcihcIlRoZSBzdHlsZS1sb2FkZXIgY2Fubm90IGJlIHVzZWQgaW4gYSBub24tYnJvd3NlciBlbnZpcm9ubWVudFwiKTtcblx0fVxuXG5cdG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXHQvLyBGb3JjZSBzaW5nbGUtdGFnIHNvbHV0aW9uIG9uIElFNi05LCB3aGljaCBoYXMgYSBoYXJkIGxpbWl0IG9uIHRoZSAjIG9mIDxzdHlsZT5cblx0Ly8gdGFncyBpdCB3aWxsIGFsbG93IG9uIGEgcGFnZVxuXHRpZiAodHlwZW9mIG9wdGlvbnMuc2luZ2xldG9uID09PSBcInVuZGVmaW5lZFwiKSBvcHRpb25zLnNpbmdsZXRvbiA9IGlzT2xkSUUoKTtcblxuXHQvLyBCeSBkZWZhdWx0LCBhZGQgPHN0eWxlPiB0YWdzIHRvIHRoZSBib3R0b20gb2YgPGhlYWQ+LlxuXHRpZiAodHlwZW9mIG9wdGlvbnMuaW5zZXJ0QXQgPT09IFwidW5kZWZpbmVkXCIpIG9wdGlvbnMuaW5zZXJ0QXQgPSBcImJvdHRvbVwiO1xuXG5cdHZhciBzdHlsZXMgPSBsaXN0VG9TdHlsZXMobGlzdCk7XG5cdGFkZFN0eWxlc1RvRG9tKHN0eWxlcywgb3B0aW9ucyk7XG5cblx0cmV0dXJuIGZ1bmN0aW9uIHVwZGF0ZShuZXdMaXN0KSB7XG5cdFx0dmFyIG1heVJlbW92ZSA9IFtdO1xuXHRcdGZvcih2YXIgaSA9IDA7IGkgPCBzdHlsZXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhciBpdGVtID0gc3R5bGVzW2ldO1xuXHRcdFx0dmFyIGRvbVN0eWxlID0gc3R5bGVzSW5Eb21baXRlbS5pZF07XG5cdFx0XHRkb21TdHlsZS5yZWZzLS07XG5cdFx0XHRtYXlSZW1vdmUucHVzaChkb21TdHlsZSk7XG5cdFx0fVxuXHRcdGlmKG5ld0xpc3QpIHtcblx0XHRcdHZhciBuZXdTdHlsZXMgPSBsaXN0VG9TdHlsZXMobmV3TGlzdCk7XG5cdFx0XHRhZGRTdHlsZXNUb0RvbShuZXdTdHlsZXMsIG9wdGlvbnMpO1xuXHRcdH1cblx0XHRmb3IodmFyIGkgPSAwOyBpIDwgbWF5UmVtb3ZlLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIgZG9tU3R5bGUgPSBtYXlSZW1vdmVbaV07XG5cdFx0XHRpZihkb21TdHlsZS5yZWZzID09PSAwKSB7XG5cdFx0XHRcdGZvcih2YXIgaiA9IDA7IGogPCBkb21TdHlsZS5wYXJ0cy5sZW5ndGg7IGorKylcblx0XHRcdFx0XHRkb21TdHlsZS5wYXJ0c1tqXSgpO1xuXHRcdFx0XHRkZWxldGUgc3R5bGVzSW5Eb21bZG9tU3R5bGUuaWRdO1xuXHRcdFx0fVxuXHRcdH1cblx0fTtcbn1cblxuZnVuY3Rpb24gYWRkU3R5bGVzVG9Eb20oc3R5bGVzLCBvcHRpb25zKSB7XG5cdGZvcih2YXIgaSA9IDA7IGkgPCBzdHlsZXMubGVuZ3RoOyBpKyspIHtcblx0XHR2YXIgaXRlbSA9IHN0eWxlc1tpXTtcblx0XHR2YXIgZG9tU3R5bGUgPSBzdHlsZXNJbkRvbVtpdGVtLmlkXTtcblx0XHRpZihkb21TdHlsZSkge1xuXHRcdFx0ZG9tU3R5bGUucmVmcysrO1xuXHRcdFx0Zm9yKHZhciBqID0gMDsgaiA8IGRvbVN0eWxlLnBhcnRzLmxlbmd0aDsgaisrKSB7XG5cdFx0XHRcdGRvbVN0eWxlLnBhcnRzW2pdKGl0ZW0ucGFydHNbal0pO1xuXHRcdFx0fVxuXHRcdFx0Zm9yKDsgaiA8IGl0ZW0ucGFydHMubGVuZ3RoOyBqKyspIHtcblx0XHRcdFx0ZG9tU3R5bGUucGFydHMucHVzaChhZGRTdHlsZShpdGVtLnBhcnRzW2pdLCBvcHRpb25zKSk7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdHZhciBwYXJ0cyA9IFtdO1xuXHRcdFx0Zm9yKHZhciBqID0gMDsgaiA8IGl0ZW0ucGFydHMubGVuZ3RoOyBqKyspIHtcblx0XHRcdFx0cGFydHMucHVzaChhZGRTdHlsZShpdGVtLnBhcnRzW2pdLCBvcHRpb25zKSk7XG5cdFx0XHR9XG5cdFx0XHRzdHlsZXNJbkRvbVtpdGVtLmlkXSA9IHtpZDogaXRlbS5pZCwgcmVmczogMSwgcGFydHM6IHBhcnRzfTtcblx0XHR9XG5cdH1cbn1cblxuZnVuY3Rpb24gbGlzdFRvU3R5bGVzKGxpc3QpIHtcblx0dmFyIHN0eWxlcyA9IFtdO1xuXHR2YXIgbmV3U3R5bGVzID0ge307XG5cdGZvcih2YXIgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG5cdFx0dmFyIGl0ZW0gPSBsaXN0W2ldO1xuXHRcdHZhciBpZCA9IGl0ZW1bMF07XG5cdFx0dmFyIGNzcyA9IGl0ZW1bMV07XG5cdFx0dmFyIG1lZGlhID0gaXRlbVsyXTtcblx0XHR2YXIgc291cmNlTWFwID0gaXRlbVszXTtcblx0XHR2YXIgcGFydCA9IHtjc3M6IGNzcywgbWVkaWE6IG1lZGlhLCBzb3VyY2VNYXA6IHNvdXJjZU1hcH07XG5cdFx0aWYoIW5ld1N0eWxlc1tpZF0pXG5cdFx0XHRzdHlsZXMucHVzaChuZXdTdHlsZXNbaWRdID0ge2lkOiBpZCwgcGFydHM6IFtwYXJ0XX0pO1xuXHRcdGVsc2Vcblx0XHRcdG5ld1N0eWxlc1tpZF0ucGFydHMucHVzaChwYXJ0KTtcblx0fVxuXHRyZXR1cm4gc3R5bGVzO1xufVxuXG5mdW5jdGlvbiBpbnNlcnRTdHlsZUVsZW1lbnQob3B0aW9ucywgc3R5bGVFbGVtZW50KSB7XG5cdHZhciBoZWFkID0gZ2V0SGVhZEVsZW1lbnQoKTtcblx0dmFyIGxhc3RTdHlsZUVsZW1lbnRJbnNlcnRlZEF0VG9wID0gc3R5bGVFbGVtZW50c0luc2VydGVkQXRUb3Bbc3R5bGVFbGVtZW50c0luc2VydGVkQXRUb3AubGVuZ3RoIC0gMV07XG5cdGlmIChvcHRpb25zLmluc2VydEF0ID09PSBcInRvcFwiKSB7XG5cdFx0aWYoIWxhc3RTdHlsZUVsZW1lbnRJbnNlcnRlZEF0VG9wKSB7XG5cdFx0XHRoZWFkLmluc2VydEJlZm9yZShzdHlsZUVsZW1lbnQsIGhlYWQuZmlyc3RDaGlsZCk7XG5cdFx0fSBlbHNlIGlmKGxhc3RTdHlsZUVsZW1lbnRJbnNlcnRlZEF0VG9wLm5leHRTaWJsaW5nKSB7XG5cdFx0XHRoZWFkLmluc2VydEJlZm9yZShzdHlsZUVsZW1lbnQsIGxhc3RTdHlsZUVsZW1lbnRJbnNlcnRlZEF0VG9wLm5leHRTaWJsaW5nKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0aGVhZC5hcHBlbmRDaGlsZChzdHlsZUVsZW1lbnQpO1xuXHRcdH1cblx0XHRzdHlsZUVsZW1lbnRzSW5zZXJ0ZWRBdFRvcC5wdXNoKHN0eWxlRWxlbWVudCk7XG5cdH0gZWxzZSBpZiAob3B0aW9ucy5pbnNlcnRBdCA9PT0gXCJib3R0b21cIikge1xuXHRcdGhlYWQuYXBwZW5kQ2hpbGQoc3R5bGVFbGVtZW50KTtcblx0fSBlbHNlIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHZhbHVlIGZvciBwYXJhbWV0ZXIgJ2luc2VydEF0Jy4gTXVzdCBiZSAndG9wJyBvciAnYm90dG9tJy5cIik7XG5cdH1cbn1cblxuZnVuY3Rpb24gcmVtb3ZlU3R5bGVFbGVtZW50KHN0eWxlRWxlbWVudCkge1xuXHRzdHlsZUVsZW1lbnQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChzdHlsZUVsZW1lbnQpO1xuXHR2YXIgaWR4ID0gc3R5bGVFbGVtZW50c0luc2VydGVkQXRUb3AuaW5kZXhPZihzdHlsZUVsZW1lbnQpO1xuXHRpZihpZHggPj0gMCkge1xuXHRcdHN0eWxlRWxlbWVudHNJbnNlcnRlZEF0VG9wLnNwbGljZShpZHgsIDEpO1xuXHR9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVN0eWxlRWxlbWVudChvcHRpb25zKSB7XG5cdHZhciBzdHlsZUVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3R5bGVcIik7XG5cdHN0eWxlRWxlbWVudC50eXBlID0gXCJ0ZXh0L2Nzc1wiO1xuXHRpbnNlcnRTdHlsZUVsZW1lbnQob3B0aW9ucywgc3R5bGVFbGVtZW50KTtcblx0cmV0dXJuIHN0eWxlRWxlbWVudDtcbn1cblxuZnVuY3Rpb24gYWRkU3R5bGUob2JqLCBvcHRpb25zKSB7XG5cdHZhciBzdHlsZUVsZW1lbnQsIHVwZGF0ZSwgcmVtb3ZlO1xuXG5cdGlmIChvcHRpb25zLnNpbmdsZXRvbikge1xuXHRcdHZhciBzdHlsZUluZGV4ID0gc2luZ2xldG9uQ291bnRlcisrO1xuXHRcdHN0eWxlRWxlbWVudCA9IHNpbmdsZXRvbkVsZW1lbnQgfHwgKHNpbmdsZXRvbkVsZW1lbnQgPSBjcmVhdGVTdHlsZUVsZW1lbnQob3B0aW9ucykpO1xuXHRcdHVwZGF0ZSA9IGFwcGx5VG9TaW5nbGV0b25UYWcuYmluZChudWxsLCBzdHlsZUVsZW1lbnQsIHN0eWxlSW5kZXgsIGZhbHNlKTtcblx0XHRyZW1vdmUgPSBhcHBseVRvU2luZ2xldG9uVGFnLmJpbmQobnVsbCwgc3R5bGVFbGVtZW50LCBzdHlsZUluZGV4LCB0cnVlKTtcblx0fSBlbHNlIHtcblx0XHRzdHlsZUVsZW1lbnQgPSBjcmVhdGVTdHlsZUVsZW1lbnQob3B0aW9ucyk7XG5cdFx0dXBkYXRlID0gYXBwbHlUb1RhZy5iaW5kKG51bGwsIHN0eWxlRWxlbWVudCk7XG5cdFx0cmVtb3ZlID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRyZW1vdmVTdHlsZUVsZW1lbnQoc3R5bGVFbGVtZW50KTtcblx0XHR9O1xuXHR9XG5cblx0dXBkYXRlKG9iaik7XG5cblx0cmV0dXJuIGZ1bmN0aW9uIHVwZGF0ZVN0eWxlKG5ld09iaikge1xuXHRcdGlmKG5ld09iaikge1xuXHRcdFx0aWYobmV3T2JqLmNzcyA9PT0gb2JqLmNzcyAmJiBuZXdPYmoubWVkaWEgPT09IG9iai5tZWRpYSAmJiBuZXdPYmouc291cmNlTWFwID09PSBvYmouc291cmNlTWFwKVxuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR1cGRhdGUob2JqID0gbmV3T2JqKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmVtb3ZlKCk7XG5cdFx0fVxuXHR9O1xufVxuXG52YXIgcmVwbGFjZVRleHQgPSAoZnVuY3Rpb24gKCkge1xuXHR2YXIgdGV4dFN0b3JlID0gW107XG5cblx0cmV0dXJuIGZ1bmN0aW9uIChpbmRleCwgcmVwbGFjZW1lbnQpIHtcblx0XHR0ZXh0U3RvcmVbaW5kZXhdID0gcmVwbGFjZW1lbnQ7XG5cdFx0cmV0dXJuIHRleHRTdG9yZS5maWx0ZXIoQm9vbGVhbikuam9pbignXFxuJyk7XG5cdH07XG59KSgpO1xuXG5mdW5jdGlvbiBhcHBseVRvU2luZ2xldG9uVGFnKHN0eWxlRWxlbWVudCwgaW5kZXgsIHJlbW92ZSwgb2JqKSB7XG5cdHZhciBjc3MgPSByZW1vdmUgPyBcIlwiIDogb2JqLmNzcztcblxuXHRpZiAoc3R5bGVFbGVtZW50LnN0eWxlU2hlZXQpIHtcblx0XHRzdHlsZUVsZW1lbnQuc3R5bGVTaGVldC5jc3NUZXh0ID0gcmVwbGFjZVRleHQoaW5kZXgsIGNzcyk7XG5cdH0gZWxzZSB7XG5cdFx0dmFyIGNzc05vZGUgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShjc3MpO1xuXHRcdHZhciBjaGlsZE5vZGVzID0gc3R5bGVFbGVtZW50LmNoaWxkTm9kZXM7XG5cdFx0aWYgKGNoaWxkTm9kZXNbaW5kZXhdKSBzdHlsZUVsZW1lbnQucmVtb3ZlQ2hpbGQoY2hpbGROb2Rlc1tpbmRleF0pO1xuXHRcdGlmIChjaGlsZE5vZGVzLmxlbmd0aCkge1xuXHRcdFx0c3R5bGVFbGVtZW50Lmluc2VydEJlZm9yZShjc3NOb2RlLCBjaGlsZE5vZGVzW2luZGV4XSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHN0eWxlRWxlbWVudC5hcHBlbmRDaGlsZChjc3NOb2RlKTtcblx0XHR9XG5cdH1cbn1cblxuZnVuY3Rpb24gYXBwbHlUb1RhZyhzdHlsZUVsZW1lbnQsIG9iaikge1xuXHR2YXIgY3NzID0gb2JqLmNzcztcblx0dmFyIG1lZGlhID0gb2JqLm1lZGlhO1xuXHR2YXIgc291cmNlTWFwID0gb2JqLnNvdXJjZU1hcDtcblxuXHRpZiAobWVkaWEpIHtcblx0XHRzdHlsZUVsZW1lbnQuc2V0QXR0cmlidXRlKFwibWVkaWFcIiwgbWVkaWEpO1xuXHR9XG5cblx0aWYgKHNvdXJjZU1hcCkge1xuXHRcdC8vIGh0dHBzOi8vZGV2ZWxvcGVyLmNocm9tZS5jb20vZGV2dG9vbHMvZG9jcy9qYXZhc2NyaXB0LWRlYnVnZ2luZ1xuXHRcdC8vIHRoaXMgbWFrZXMgc291cmNlIG1hcHMgaW5zaWRlIHN0eWxlIHRhZ3Mgd29yayBwcm9wZXJseSBpbiBDaHJvbWVcblx0XHRjc3MgKz0gJ1xcbi8qIyBzb3VyY2VVUkw9JyArIHNvdXJjZU1hcC5zb3VyY2VzWzBdICsgJyAqLyc7XG5cdFx0Ly8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMjY2MDM4NzVcblx0XHRjc3MgKz0gXCJcXG4vKiMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247YmFzZTY0LFwiICsgYnRvYSh1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoSlNPTi5zdHJpbmdpZnkoc291cmNlTWFwKSkpKSArIFwiICovXCI7XG5cdH1cblxuXHRpZiAoc3R5bGVFbGVtZW50LnN0eWxlU2hlZXQpIHtcblx0XHRzdHlsZUVsZW1lbnQuc3R5bGVTaGVldC5jc3NUZXh0ID0gY3NzO1xuXHR9IGVsc2Uge1xuXHRcdHdoaWxlKHN0eWxlRWxlbWVudC5maXJzdENoaWxkKSB7XG5cdFx0XHRzdHlsZUVsZW1lbnQucmVtb3ZlQ2hpbGQoc3R5bGVFbGVtZW50LmZpcnN0Q2hpbGQpO1xuXHRcdH1cblx0XHRzdHlsZUVsZW1lbnQuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY3NzKSk7XG5cdH1cbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi8uMS4wLjBAdnVlLXN0eWxlLWxvYWRlci9hZGRTdHlsZXMuanNcbi8vIG1vZHVsZSBpZCA9IDdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIDEiXSwic291cmNlUm9vdCI6IiJ9");

/***/ },
/* 8 */,
/* 9 */,
/* 10 */,
/* 11 */
/***/ function(module, exports, __webpack_require__) {

	eval("var __vue_exports__, __vue_options__\nvar __vue_styles__ = {}\n\n/* styles */\n__webpack_require__(12)\n\n/* script */\n__vue_exports__ = __webpack_require__(17)\n\n/* template */\nvar __vue_template__ = __webpack_require__(34)\n__vue_options__ = __vue_exports__ = __vue_exports__ || {}\nif (\n  typeof __vue_exports__.default === \"object\" ||\n  typeof __vue_exports__.default === \"function\"\n) {\nif (Object.keys(__vue_exports__).some(function (key) { return key !== \"default\" && key !== \"__esModule\" })) {console.error(\"named exports are not supported in *.vue files.\")}\n__vue_options__ = __vue_exports__ = __vue_exports__.default\n}\nif (typeof __vue_options__ === \"function\") {\n  __vue_options__ = __vue_options__.options\n}\n__vue_options__.__file = \"E:\\\\git_pro\\\\express-webpack-vue\\\\src\\\\pages\\\\mobile\\\\page-notfound\\\\index.vue\"\n__vue_options__.render = __vue_template__.render\n__vue_options__.staticRenderFns = __vue_template__.staticRenderFns\n__vue_options__._scopeId = \"data-v-6e751231\"\n\n/* hot reload */\nif (false) {(function () {\n  var hotAPI = require(\"vue-loader/node_modules/vue-hot-reload-api\")\n  hotAPI.install(require(\"vue\"), false)\n  if (!hotAPI.compatible) return\n  module.hot.accept()\n  if (!module.hot.data) {\n    hotAPI.createRecord(\"data-v-6e751231\", __vue_options__)\n  } else {\n    hotAPI.reload(\"data-v-6e751231\", __vue_options__)\n  }\n})()}\nif (__vue_options__.functional) {console.error(\"[vue-loader] index.vue: functional components are not supported and should be defined in plain js files using render functions.\")}\n\nmodule.exports = __vue_exports__\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvcGFnZXMvbW9iaWxlL3BhZ2Utbm90Zm91bmQvaW5kZXgudnVlPzdlM2UiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0QsbURBQW1ELElBQUk7QUFDN0c7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsWUFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsaUNBQWlDOztBQUVqQyIsImZpbGUiOiIxMS5qcyIsInNvdXJjZXNDb250ZW50IjpbInZhciBfX3Z1ZV9leHBvcnRzX18sIF9fdnVlX29wdGlvbnNfX1xudmFyIF9fdnVlX3N0eWxlc19fID0ge31cblxuLyogc3R5bGVzICovXG5yZXF1aXJlKFwiISF2dWUtbG9hZGVyL25vZGVfbW9kdWxlcy92dWUtc3R5bGUtbG9hZGVyIWNzcy1sb2FkZXI/c291cmNlTWFwIXZ1ZS1sb2FkZXIvbGliL3N0eWxlLXJld3JpdGVyP2lkPWRhdGEtdi02ZTc1MTIzMSZzY29wZWQ9dHJ1ZSFzYXNzLWxvYWRlciEuL2luZGV4LnNjc3NcIilcblxuLyogc2NyaXB0ICovXG5fX3Z1ZV9leHBvcnRzX18gPSByZXF1aXJlKFwiISFiYWJlbC1sb2FkZXIhdnVlLWxvYWRlci9saWIvc2VsZWN0b3I/dHlwZT1zY3JpcHQmaW5kZXg9MCEuL2luZGV4LnZ1ZVwiKVxuXG4vKiB0ZW1wbGF0ZSAqL1xudmFyIF9fdnVlX3RlbXBsYXRlX18gPSByZXF1aXJlKFwiISF2dWUtbG9hZGVyL2xpYi90ZW1wbGF0ZS1jb21waWxlcj9pZD1kYXRhLXYtNmU3NTEyMzEhdnVlLWxvYWRlci9saWIvdGVtcGxhdGUtbG9hZGVyP3JhdyZlbmdpbmU9amFkZSEuL2luZGV4LmphZGVcIilcbl9fdnVlX29wdGlvbnNfXyA9IF9fdnVlX2V4cG9ydHNfXyA9IF9fdnVlX2V4cG9ydHNfXyB8fCB7fVxuaWYgKFxuICB0eXBlb2YgX192dWVfZXhwb3J0c19fLmRlZmF1bHQgPT09IFwib2JqZWN0XCIgfHxcbiAgdHlwZW9mIF9fdnVlX2V4cG9ydHNfXy5kZWZhdWx0ID09PSBcImZ1bmN0aW9uXCJcbikge1xuaWYgKE9iamVjdC5rZXlzKF9fdnVlX2V4cG9ydHNfXykuc29tZShmdW5jdGlvbiAoa2V5KSB7IHJldHVybiBrZXkgIT09IFwiZGVmYXVsdFwiICYmIGtleSAhPT0gXCJfX2VzTW9kdWxlXCIgfSkpIHtjb25zb2xlLmVycm9yKFwibmFtZWQgZXhwb3J0cyBhcmUgbm90IHN1cHBvcnRlZCBpbiAqLnZ1ZSBmaWxlcy5cIil9XG5fX3Z1ZV9vcHRpb25zX18gPSBfX3Z1ZV9leHBvcnRzX18gPSBfX3Z1ZV9leHBvcnRzX18uZGVmYXVsdFxufVxuaWYgKHR5cGVvZiBfX3Z1ZV9vcHRpb25zX18gPT09IFwiZnVuY3Rpb25cIikge1xuICBfX3Z1ZV9vcHRpb25zX18gPSBfX3Z1ZV9vcHRpb25zX18ub3B0aW9uc1xufVxuX192dWVfb3B0aW9uc19fLl9fZmlsZSA9IFwiRTpcXFxcZ2l0X3Byb1xcXFxleHByZXNzLXdlYnBhY2stdnVlXFxcXHNyY1xcXFxwYWdlc1xcXFxtb2JpbGVcXFxccGFnZS1ub3Rmb3VuZFxcXFxpbmRleC52dWVcIlxuX192dWVfb3B0aW9uc19fLnJlbmRlciA9IF9fdnVlX3RlbXBsYXRlX18ucmVuZGVyXG5fX3Z1ZV9vcHRpb25zX18uc3RhdGljUmVuZGVyRm5zID0gX192dWVfdGVtcGxhdGVfXy5zdGF0aWNSZW5kZXJGbnNcbl9fdnVlX29wdGlvbnNfXy5fc2NvcGVJZCA9IFwiZGF0YS12LTZlNzUxMjMxXCJcblxuLyogaG90IHJlbG9hZCAqL1xuaWYgKG1vZHVsZS5ob3QpIHsoZnVuY3Rpb24gKCkge1xuICB2YXIgaG90QVBJID0gcmVxdWlyZShcInZ1ZS1sb2FkZXIvbm9kZV9tb2R1bGVzL3Z1ZS1ob3QtcmVsb2FkLWFwaVwiKVxuICBob3RBUEkuaW5zdGFsbChyZXF1aXJlKFwidnVlXCIpLCBmYWxzZSlcbiAgaWYgKCFob3RBUEkuY29tcGF0aWJsZSkgcmV0dXJuXG4gIG1vZHVsZS5ob3QuYWNjZXB0KClcbiAgaWYgKCFtb2R1bGUuaG90LmRhdGEpIHtcbiAgICBob3RBUEkuY3JlYXRlUmVjb3JkKFwiZGF0YS12LTZlNzUxMjMxXCIsIF9fdnVlX29wdGlvbnNfXylcbiAgfSBlbHNlIHtcbiAgICBob3RBUEkucmVsb2FkKFwiZGF0YS12LTZlNzUxMjMxXCIsIF9fdnVlX29wdGlvbnNfXylcbiAgfVxufSkoKX1cbmlmIChfX3Z1ZV9vcHRpb25zX18uZnVuY3Rpb25hbCkge2NvbnNvbGUuZXJyb3IoXCJbdnVlLWxvYWRlcl0gaW5kZXgudnVlOiBmdW5jdGlvbmFsIGNvbXBvbmVudHMgYXJlIG5vdCBzdXBwb3J0ZWQgYW5kIHNob3VsZCBiZSBkZWZpbmVkIGluIHBsYWluIGpzIGZpbGVzIHVzaW5nIHJlbmRlciBmdW5jdGlvbnMuXCIpfVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9fdnVlX2V4cG9ydHNfX1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvcGFnZXMvbW9iaWxlL3BhZ2Utbm90Zm91bmQvaW5kZXgudnVlXG4vLyBtb2R1bGUgaWQgPSAxMVxuLy8gbW9kdWxlIGNodW5rcyA9IDEiXSwic291cmNlUm9vdCI6IiJ9");

/***/ },
/* 12 */
/***/ function(module, exports, __webpack_require__) {

	eval("// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = __webpack_require__(13);\nif(typeof content === 'string') content = [[module.id, content, '']];\n// add the styles to the DOM\nvar update = __webpack_require__(7)(content, {});\nif(content.locals) module.exports = content.locals;\n// Hot Module Replacement\nif(false) {\n\t// When the styles change, update the <style> tags\n\tif(!content.locals) {\n\t\tmodule.hot.accept(\"!!./../../../../node_modules/.0.25.0@css-loader/index.js?sourceMap!./../../../../node_modules/.9.9.5@vue-loader/lib/style-rewriter.js?id=data-v-6e751231&scoped=true!./../../../../node_modules/.4.0.2@sass-loader/index.js!./index.scss\", function() {\n\t\t\tvar newContent = require(\"!!./../../../../node_modules/.0.25.0@css-loader/index.js?sourceMap!./../../../../node_modules/.9.9.5@vue-loader/lib/style-rewriter.js?id=data-v-6e751231&scoped=true!./../../../../node_modules/.4.0.2@sass-loader/index.js!./index.scss\");\n\t\t\tif(typeof newContent === 'string') newContent = [[module.id, newContent, '']];\n\t\t\tupdate(newContent);\n\t\t});\n\t}\n\t// When the module is disposed, remove the <style> tags\n\tmodule.hot.dispose(function() { update(); });\n}//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvcGFnZXMvbW9iaWxlL3BhZ2Utbm90Zm91bmQvaW5kZXguc2Nzcz83NDk5Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQW9HO0FBQ3BHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsZ0NBQWdDLFVBQVUsRUFBRTtBQUM1QyIsImZpbGUiOiIxMi5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIHN0eWxlLWxvYWRlcjogQWRkcyBzb21lIGNzcyB0byB0aGUgRE9NIGJ5IGFkZGluZyBhIDxzdHlsZT4gdGFnXG5cbi8vIGxvYWQgdGhlIHN0eWxlc1xudmFyIGNvbnRlbnQgPSByZXF1aXJlKFwiISEuLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy8uMC4yNS4wQGNzcy1sb2FkZXIvaW5kZXguanM/c291cmNlTWFwIS4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy45LjkuNUB2dWUtbG9hZGVyL2xpYi9zdHlsZS1yZXdyaXRlci5qcz9pZD1kYXRhLXYtNmU3NTEyMzEmc2NvcGVkPXRydWUhLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvLjQuMC4yQHNhc3MtbG9hZGVyL2luZGV4LmpzIS4vaW5kZXguc2Nzc1wiKTtcbmlmKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykgY29udGVudCA9IFtbbW9kdWxlLmlkLCBjb250ZW50LCAnJ11dO1xuLy8gYWRkIHRoZSBzdHlsZXMgdG8gdGhlIERPTVxudmFyIHVwZGF0ZSA9IHJlcXVpcmUoXCIhLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvLjEuMC4wQHZ1ZS1zdHlsZS1sb2FkZXIvYWRkU3R5bGVzLmpzXCIpKGNvbnRlbnQsIHt9KTtcbmlmKGNvbnRlbnQubG9jYWxzKSBtb2R1bGUuZXhwb3J0cyA9IGNvbnRlbnQubG9jYWxzO1xuLy8gSG90IE1vZHVsZSBSZXBsYWNlbWVudFxuaWYobW9kdWxlLmhvdCkge1xuXHQvLyBXaGVuIHRoZSBzdHlsZXMgY2hhbmdlLCB1cGRhdGUgdGhlIDxzdHlsZT4gdGFnc1xuXHRpZighY29udGVudC5sb2NhbHMpIHtcblx0XHRtb2R1bGUuaG90LmFjY2VwdChcIiEhLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvLjAuMjUuMEBjc3MtbG9hZGVyL2luZGV4LmpzP3NvdXJjZU1hcCEuLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy8uOS45LjVAdnVlLWxvYWRlci9saWIvc3R5bGUtcmV3cml0ZXIuanM/aWQ9ZGF0YS12LTZlNzUxMjMxJnNjb3BlZD10cnVlIS4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy40LjAuMkBzYXNzLWxvYWRlci9pbmRleC5qcyEuL2luZGV4LnNjc3NcIiwgZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgbmV3Q29udGVudCA9IHJlcXVpcmUoXCIhIS4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy4wLjI1LjBAY3NzLWxvYWRlci9pbmRleC5qcz9zb3VyY2VNYXAhLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvLjkuOS41QHZ1ZS1sb2FkZXIvbGliL3N0eWxlLXJld3JpdGVyLmpzP2lkPWRhdGEtdi02ZTc1MTIzMSZzY29wZWQ9dHJ1ZSEuLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy8uNC4wLjJAc2Fzcy1sb2FkZXIvaW5kZXguanMhLi9pbmRleC5zY3NzXCIpO1xuXHRcdFx0aWYodHlwZW9mIG5ld0NvbnRlbnQgPT09ICdzdHJpbmcnKSBuZXdDb250ZW50ID0gW1ttb2R1bGUuaWQsIG5ld0NvbnRlbnQsICcnXV07XG5cdFx0XHR1cGRhdGUobmV3Q29udGVudCk7XG5cdFx0fSk7XG5cdH1cblx0Ly8gV2hlbiB0aGUgbW9kdWxlIGlzIGRpc3Bvc2VkLCByZW1vdmUgdGhlIDxzdHlsZT4gdGFnc1xuXHRtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24oKSB7IHVwZGF0ZSgpOyB9KTtcbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vLjEuMC4wQHZ1ZS1zdHlsZS1sb2FkZXIhLi9+Ly4wLjI1LjBAY3NzLWxvYWRlcj9zb3VyY2VNYXAhLi9+Ly45LjkuNUB2dWUtbG9hZGVyL2xpYi9zdHlsZS1yZXdyaXRlci5qcz9pZD1kYXRhLXYtNmU3NTEyMzEmc2NvcGVkPXRydWUhLi9+Ly40LjAuMkBzYXNzLWxvYWRlciEuL3NyYy9wYWdlcy9tb2JpbGUvcGFnZS1ub3Rmb3VuZC9pbmRleC5zY3NzXG4vLyBtb2R1bGUgaWQgPSAxMlxuLy8gbW9kdWxlIGNodW5rcyA9IDEiXSwic291cmNlUm9vdCI6IiJ9");

/***/ },
/* 13 */
/***/ function(module, exports, __webpack_require__) {

	eval("exports = module.exports = __webpack_require__(6)();\n// imports\n\n\n// module\nexports.push([module.id, \"\\nhtml[data-v-6e751231], body[data-v-6e751231] {\\n  height: 100%;\\n}\\n.wrapper[data-v-6e751231] {\\n  height: 100%;\\n  padding-bottom: 1.4rem;\\n  background: #ffaf1a;\\n  position: relative;\\n  background: url(\" + __webpack_require__(14) + \") no-repeat;\\n  background-size: 100%;\\n  width: 7.20rem;\\n}\\n.wrapper .android-btn[data-v-6e751231], .wrapper .ios-btn[data-v-6e751231] {\\n    position: absolute;\\n    left: 3.44rem;\\n    top: 7.35rem;\\n    width: 2.83rem;\\n    height: .81rem;\\n}\\n.wrapper .android-btn[data-v-6e751231] {\\n    background: url(\" + __webpack_require__(15) + \") no-repeat;\\n    background-size: 100%;\\n}\\n.wrapper .ios-btn[data-v-6e751231] {\\n    top: 6.19rem !important;\\n    background: url(\" + __webpack_require__(16) + \") no-repeat;\\n    background-size: 100%;\\n}\\n\", \"\", {\"version\":3,\"sources\":[\"/./src/pages/mobile/page-notfound/index.scss\"],\"names\":[],\"mappings\":\";AAAA;EACE,aAAa;CAAE;AAEjB;EACE,aAAa;EACb,uBAAuB;EACvB,oBAAoB;EACpB,mBAAmB;EACnB,oDAA2C;EAC3C,sBAAsB;EACtB,eAAe;CAAE;AACjB;IACE,mBAAmB;IACnB,cAAc;IACd,aAAa;IACb,eAAe;IACf,eAAe;CAAE;AACnB;IACE,oDAAyD;IACzD,sBAAsB;CAAE;AAC1B;IACE,wBAAwB;IACxB,oDAAqD;IACrD,sBAAsB;CAAE\",\"file\":\"index.scss\",\"sourcesContent\":[\"html, body {\\n  height: 100%; }\\n\\n.wrapper {\\n  height: 100%;\\n  padding-bottom: 1.4rem;\\n  background: #ffaf1a;\\n  position: relative;\\n  background: url(./images/bg.png) no-repeat;\\n  background-size: 100%;\\n  width: 7.20rem; }\\n  .wrapper .android-btn, .wrapper .ios-btn {\\n    position: absolute;\\n    left: 3.44rem;\\n    top: 7.35rem;\\n    width: 2.83rem;\\n    height: .81rem; }\\n  .wrapper .android-btn {\\n    background: url(./images/android_download.png) no-repeat;\\n    background-size: 100%; }\\n  .wrapper .ios-btn {\\n    top: 6.19rem !important;\\n    background: url(./images/ios_download.png) no-repeat;\\n    background-size: 100%; }\\n\"],\"sourceRoot\":\"webpack://\"}]);\n\n// exports\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvcGFnZXMvbW9iaWxlL3BhZ2Utbm90Zm91bmQvaW5kZXguc2Nzcz8zMTIxIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7OztBQUdBO0FBQ0EsMEVBQTBFLGlCQUFpQixHQUFHLDZCQUE2QixpQkFBaUIsMkJBQTJCLHdCQUF3Qix1QkFBdUIsK0RBQWtFLDBCQUEwQixtQkFBbUIsR0FBRyw4RUFBOEUseUJBQXlCLG9CQUFvQixtQkFBbUIscUJBQXFCLHFCQUFxQixHQUFHLDBDQUEwQyxpRUFBa0YsNEJBQTRCLEdBQUcsc0NBQXNDLDhCQUE4QixpRUFBOEUsNEJBQTRCLEdBQUcsVUFBVSwrRkFBK0YsS0FBSyxVQUFVLEtBQUssTUFBTSxVQUFVLFlBQVksYUFBYSxhQUFhLGFBQWEsYUFBYSxXQUFXLEtBQUssTUFBTSxZQUFZLFdBQVcsVUFBVSxVQUFVLFVBQVUsS0FBSyxNQUFNLFlBQVksYUFBYSxLQUFLLE1BQU0sWUFBWSxhQUFhLGFBQWEseURBQXlELGlCQUFpQixFQUFFLGNBQWMsaUJBQWlCLDJCQUEyQix3QkFBd0IsdUJBQXVCLCtDQUErQywwQkFBMEIsbUJBQW1CLEVBQUUsOENBQThDLHlCQUF5QixvQkFBb0IsbUJBQW1CLHFCQUFxQixxQkFBcUIsRUFBRSwyQkFBMkIsK0RBQStELDRCQUE0QixFQUFFLHVCQUF1Qiw4QkFBOEIsMkRBQTJELDRCQUE0QixFQUFFLCtCQUErQjs7QUFFOTREIiwiZmlsZSI6IjEzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy4wLjI1LjBAY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanNcIikoKTtcbi8vIGltcG9ydHNcblxuXG4vLyBtb2R1bGVcbmV4cG9ydHMucHVzaChbbW9kdWxlLmlkLCBcIlxcbmh0bWxbZGF0YS12LTZlNzUxMjMxXSwgYm9keVtkYXRhLXYtNmU3NTEyMzFdIHtcXG4gIGhlaWdodDogMTAwJTtcXG59XFxuLndyYXBwZXJbZGF0YS12LTZlNzUxMjMxXSB7XFxuICBoZWlnaHQ6IDEwMCU7XFxuICBwYWRkaW5nLWJvdHRvbTogMS40cmVtO1xcbiAgYmFja2dyb3VuZDogI2ZmYWYxYTtcXG4gIHBvc2l0aW9uOiByZWxhdGl2ZTtcXG4gIGJhY2tncm91bmQ6IHVybChcIiArIHJlcXVpcmUoXCIuL2ltYWdlcy9iZy5wbmdcIikgKyBcIikgbm8tcmVwZWF0O1xcbiAgYmFja2dyb3VuZC1zaXplOiAxMDAlO1xcbiAgd2lkdGg6IDcuMjByZW07XFxufVxcbi53cmFwcGVyIC5hbmRyb2lkLWJ0bltkYXRhLXYtNmU3NTEyMzFdLCAud3JhcHBlciAuaW9zLWJ0bltkYXRhLXYtNmU3NTEyMzFdIHtcXG4gICAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgICBsZWZ0OiAzLjQ0cmVtO1xcbiAgICB0b3A6IDcuMzVyZW07XFxuICAgIHdpZHRoOiAyLjgzcmVtO1xcbiAgICBoZWlnaHQ6IC44MXJlbTtcXG59XFxuLndyYXBwZXIgLmFuZHJvaWQtYnRuW2RhdGEtdi02ZTc1MTIzMV0ge1xcbiAgICBiYWNrZ3JvdW5kOiB1cmwoXCIgKyByZXF1aXJlKFwiLi9pbWFnZXMvYW5kcm9pZF9kb3dubG9hZC5wbmdcIikgKyBcIikgbm8tcmVwZWF0O1xcbiAgICBiYWNrZ3JvdW5kLXNpemU6IDEwMCU7XFxufVxcbi53cmFwcGVyIC5pb3MtYnRuW2RhdGEtdi02ZTc1MTIzMV0ge1xcbiAgICB0b3A6IDYuMTlyZW0gIWltcG9ydGFudDtcXG4gICAgYmFja2dyb3VuZDogdXJsKFwiICsgcmVxdWlyZShcIi4vaW1hZ2VzL2lvc19kb3dubG9hZC5wbmdcIikgKyBcIikgbm8tcmVwZWF0O1xcbiAgICBiYWNrZ3JvdW5kLXNpemU6IDEwMCU7XFxufVxcblwiLCBcIlwiLCB7XCJ2ZXJzaW9uXCI6MyxcInNvdXJjZXNcIjpbXCIvLi9zcmMvcGFnZXMvbW9iaWxlL3BhZ2Utbm90Zm91bmQvaW5kZXguc2Nzc1wiXSxcIm5hbWVzXCI6W10sXCJtYXBwaW5nc1wiOlwiO0FBQUE7RUFDRSxhQUFhO0NBQUU7QUFFakI7RUFDRSxhQUFhO0VBQ2IsdUJBQXVCO0VBQ3ZCLG9CQUFvQjtFQUNwQixtQkFBbUI7RUFDbkIsb0RBQTJDO0VBQzNDLHNCQUFzQjtFQUN0QixlQUFlO0NBQUU7QUFDakI7SUFDRSxtQkFBbUI7SUFDbkIsY0FBYztJQUNkLGFBQWE7SUFDYixlQUFlO0lBQ2YsZUFBZTtDQUFFO0FBQ25CO0lBQ0Usb0RBQXlEO0lBQ3pELHNCQUFzQjtDQUFFO0FBQzFCO0lBQ0Usd0JBQXdCO0lBQ3hCLG9EQUFxRDtJQUNyRCxzQkFBc0I7Q0FBRVwiLFwiZmlsZVwiOlwiaW5kZXguc2Nzc1wiLFwic291cmNlc0NvbnRlbnRcIjpbXCJodG1sLCBib2R5IHtcXG4gIGhlaWdodDogMTAwJTsgfVxcblxcbi53cmFwcGVyIHtcXG4gIGhlaWdodDogMTAwJTtcXG4gIHBhZGRpbmctYm90dG9tOiAxLjRyZW07XFxuICBiYWNrZ3JvdW5kOiAjZmZhZjFhO1xcbiAgcG9zaXRpb246IHJlbGF0aXZlO1xcbiAgYmFja2dyb3VuZDogdXJsKC4vaW1hZ2VzL2JnLnBuZykgbm8tcmVwZWF0O1xcbiAgYmFja2dyb3VuZC1zaXplOiAxMDAlO1xcbiAgd2lkdGg6IDcuMjByZW07IH1cXG4gIC53cmFwcGVyIC5hbmRyb2lkLWJ0biwgLndyYXBwZXIgLmlvcy1idG4ge1xcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICAgIGxlZnQ6IDMuNDRyZW07XFxuICAgIHRvcDogNy4zNXJlbTtcXG4gICAgd2lkdGg6IDIuODNyZW07XFxuICAgIGhlaWdodDogLjgxcmVtOyB9XFxuICAud3JhcHBlciAuYW5kcm9pZC1idG4ge1xcbiAgICBiYWNrZ3JvdW5kOiB1cmwoLi9pbWFnZXMvYW5kcm9pZF9kb3dubG9hZC5wbmcpIG5vLXJlcGVhdDtcXG4gICAgYmFja2dyb3VuZC1zaXplOiAxMDAlOyB9XFxuICAud3JhcHBlciAuaW9zLWJ0biB7XFxuICAgIHRvcDogNi4xOXJlbSAhaW1wb3J0YW50O1xcbiAgICBiYWNrZ3JvdW5kOiB1cmwoLi9pbWFnZXMvaW9zX2Rvd25sb2FkLnBuZykgbm8tcmVwZWF0O1xcbiAgICBiYWNrZ3JvdW5kLXNpemU6IDEwMCU7IH1cXG5cIl0sXCJzb3VyY2VSb290XCI6XCJ3ZWJwYWNrOi8vXCJ9XSk7XG5cbi8vIGV4cG9ydHNcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi8uMC4yNS4wQGNzcy1sb2FkZXI/c291cmNlTWFwIS4vfi8uOS45LjVAdnVlLWxvYWRlci9saWIvc3R5bGUtcmV3cml0ZXIuanM/aWQ9ZGF0YS12LTZlNzUxMjMxJnNjb3BlZD10cnVlIS4vfi8uNC4wLjJAc2Fzcy1sb2FkZXIhLi9zcmMvcGFnZXMvbW9iaWxlL3BhZ2Utbm90Zm91bmQvaW5kZXguc2Nzc1xuLy8gbW9kdWxlIGlkID0gMTNcbi8vIG1vZHVsZSBjaHVua3MgPSAxIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ },
/* 14 */
/***/ function(module, exports, __webpack_require__) {

	eval("module.exports = __webpack_require__.p + \"/images/bg-0d386f7c9b39024aa43dfaa62eb2fa29.png\";//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvcGFnZXMvbW9iaWxlL3BhZ2Utbm90Zm91bmQvaW1hZ2VzL2JnLnBuZz84Mjg4Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBIiwiZmlsZSI6IjE0LmpzIiwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSBfX3dlYnBhY2tfcHVibGljX3BhdGhfXyArIFwiL2ltYWdlcy9iZy0wZDM4NmY3YzliMzkwMjRhYTQzZGZhYTYyZWIyZmEyOS5wbmdcIjtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9wYWdlcy9tb2JpbGUvcGFnZS1ub3Rmb3VuZC9pbWFnZXMvYmcucG5nXG4vLyBtb2R1bGUgaWQgPSAxNFxuLy8gbW9kdWxlIGNodW5rcyA9IDEiXSwic291cmNlUm9vdCI6IiJ9");

/***/ },
/* 15 */
/***/ function(module, exports, __webpack_require__) {

	eval("module.exports = __webpack_require__.p + \"/images/android_download-1a8453dc5e62f51a3b7052eb8e218145.png\";//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvcGFnZXMvbW9iaWxlL3BhZ2Utbm90Zm91bmQvaW1hZ2VzL2FuZHJvaWRfZG93bmxvYWQucG5nPzQ5NGUiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEiLCJmaWxlIjoiMTUuanMiLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IF9fd2VicGFja19wdWJsaWNfcGF0aF9fICsgXCIvaW1hZ2VzL2FuZHJvaWRfZG93bmxvYWQtMWE4NDUzZGM1ZTYyZjUxYTNiNzA1MmViOGUyMTgxNDUucG5nXCI7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvcGFnZXMvbW9iaWxlL3BhZ2Utbm90Zm91bmQvaW1hZ2VzL2FuZHJvaWRfZG93bmxvYWQucG5nXG4vLyBtb2R1bGUgaWQgPSAxNVxuLy8gbW9kdWxlIGNodW5rcyA9IDEiXSwic291cmNlUm9vdCI6IiJ9");

/***/ },
/* 16 */
/***/ function(module, exports, __webpack_require__) {

	eval("module.exports = __webpack_require__.p + \"/images/ios_download-8d7b638a7e3da15a63d61e8ffdc5b5e6.png\";//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvcGFnZXMvbW9iaWxlL3BhZ2Utbm90Zm91bmQvaW1hZ2VzL2lvc19kb3dubG9hZC5wbmc/ZTQ1OCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSIsImZpbGUiOiIxNi5qcyIsInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gX193ZWJwYWNrX3B1YmxpY19wYXRoX18gKyBcIi9pbWFnZXMvaW9zX2Rvd25sb2FkLThkN2I2MzhhN2UzZGExNWE2M2Q2MWU4ZmZkYzViNWU2LnBuZ1wiO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL3BhZ2VzL21vYmlsZS9wYWdlLW5vdGZvdW5kL2ltYWdlcy9pb3NfZG93bmxvYWQucG5nXG4vLyBtb2R1bGUgaWQgPSAxNlxuLy8gbW9kdWxlIGNodW5rcyA9IDEiXSwic291cmNlUm9vdCI6IiJ9");

/***/ },
/* 17 */
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _native = __webpack_require__(18);\n\nvar _native2 = _interopRequireDefault(_native);\n\nvar _DownloadBar = __webpack_require__(27);\n\nvar _DownloadBar2 = _interopRequireDefault(_DownloadBar);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n//\n//\n//\n\nexports.default = {\n  el: '#root',\n  components: {\n    'download-bar': _DownloadBar2.default\n  },\n  data: function data() {\n    return {\n      msg: 'Welcome to Your Vue.js App'\n    };\n  },\n\n  methods: {\n    downloadByAndroid: function downloadByAndroid() {\n      _native2.default.download('404页面', 'android');\n    },\n    downloadByIOS: function downloadByIOS() {\n      _native2.default.download('404页面', 'ios');\n    }\n  }\n};\n\n//  $('.android-btn').tap(function(){\n//    native.download('404页面', 'android');\n//  });\n//\n//  $('.ios-btn').tap(function() {\n//    native.download('404页面', 'ios');\n//  })//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vaW5kZXgudnVlP2YyYmYiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBS0E7Ozs7QUFFQTs7Ozs7Ozs7QUFIQTs7O01BS0E7O0FBR0E7QUFGQTt3QkFHQTs7V0FHQTtBQUZBO0FBR0E7OztvREFFQTt5Q0FDQTtBQUNBOzRDQUNBO3lDQUNBO0FBRUE7QUFQQTtBQVZBOztBQW1CQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBIiwiZmlsZSI6IjE3LmpzIiwic291cmNlc0NvbnRlbnQiOlsiPHRlbXBsYXRlIGxhbmc9XCJqYWRlXCIgc3JjPVwiLi9pbmRleC5qYWRlXCI+PC90ZW1wbGF0ZT5cbjxzdHlsZSBzY29wZWQgbGFuZz1cInNhc3NcIiBzcmM9XCIuL2luZGV4LnNjc3NcIj48L3N0eWxlPlxuXG48c2NyaXB0PlxuICBpbXBvcnQgbmF0aXZlIGZyb20gJy4uLy4uLy4uL3V0aWwvbmF0aXZlJ1xuICBpbXBvcnQgRG93bmxvYWRCYXIgZnJvbSAnLi4vLi4vLi4vY29tcG9uZW50cy9tb2JpbGUvRG93bmxvYWRCYXInXG5cbiAgZXhwb3J0IGRlZmF1bHQge1xuICAgIGVsOiAnI3Jvb3QnLFxuICAgIGNvbXBvbmVudHM6IHtcbiAgICAgICdkb3dubG9hZC1iYXInOiBEb3dubG9hZEJhclxuICAgIH0sXG4gICAgZGF0YSAoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAgIG1zZzogJ1dlbGNvbWUgdG8gWW91ciBWdWUuanMgQXBwJ1xuICAgICAgfVxuICAgIH0sXG4gICAgbWV0aG9kczoge1xuICAgICAgZG93bmxvYWRCeUFuZHJvaWQgKCkge1xuICAgICAgICBuYXRpdmUuZG93bmxvYWQoJzQwNOmhtemdoicsICdhbmRyb2lkJylcbiAgICAgIH0sXG4gICAgICBkb3dubG9hZEJ5SU9TICgpIHtcbiAgICAgICAgbmF0aXZlLmRvd25sb2FkKCc0MDTpobXpnaInLCAnaW9zJylcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuLy8gICQoJy5hbmRyb2lkLWJ0bicpLnRhcChmdW5jdGlvbigpe1xuLy8gICAgbmF0aXZlLmRvd25sb2FkKCc0MDTpobXpnaInLCAnYW5kcm9pZCcpO1xuLy8gIH0pO1xuLy9cbi8vICAkKCcuaW9zLWJ0bicpLnRhcChmdW5jdGlvbigpIHtcbi8vICAgIG5hdGl2ZS5kb3dubG9hZCgnNDA06aG16Z2iJywgJ2lvcycpO1xuLy8gIH0pXG48L3NjcmlwdD5cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyBpbmRleC52dWU/YmFkNzU1MGUiXSwic291cmNlUm9vdCI6IiJ9");

/***/ },
/* 18 */
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _base = __webpack_require__(19);\n\nvar _base2 = _interopRequireDefault(_base);\n\nvar _uadetector = __webpack_require__(20);\n\nvar _uadetector2 = _interopRequireDefault(_uadetector);\n\nvar _HttpHelper = __webpack_require__(21);\n\nvar _HttpHelper2 = _interopRequireDefault(_HttpHelper);\n\nvar _querystring = __webpack_require__(22);\n\nvar _querystring2 = _interopRequireDefault(_querystring);\n\nvar _md = __webpack_require__(23);\n\nvar _cookie = __webpack_require__(24);\n\nvar _cookie2 = _interopRequireDefault(_cookie);\n\nvar _Stat = __webpack_require__(25);\n\nvar _Stat2 = _interopRequireDefault(_Stat);\n\nvar _zepto = __webpack_require__(26);\n\nvar _zepto2 = _interopRequireDefault(_zepto);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar QUERY = _querystring2.default.parse();\n\nvar A_URL;\nif (!_uadetector2.default.is('BOLO')) {\n  _zepto2.default.ajax({\n    url: 'http://www.bobo.com/special/003500MG/boloandroidurl.js',\n    dataType: 'jsonp',\n    jsonpCallback: 'getUrlCallback',\n    success: function success(result) {\n      A_URL = result;\n    }\n  });\n}\n\n// @param source: String 必选项，页面来源\n// @param OSType: String 可选项，\"android\"表示安卓下载，\"ios\"表示ios设备下载\nfunction download(source, OSType) {\n  if (!A_URL) return false;\n  //分享计划下载量统计\n  if (QUERY.sharedby && QUERY.videoId) {\n    var data = {\n      actionType: 3,\n      cookieId: _cookie2.default.get('visiteuid'),\n      videoId: QUERY.videoId,\n      userId: QUERY.sharedby,\n      s: (0, _md.md5)('actionType3cookieId' + _cookie2.default.get('visiteuid') + 'uaHidNsVv8Q3x4llxKiKCxTrjYkDeBRi').toLowerCase()\n    };\n    new Image().src = _querystring2.default.append(_HttpHelper2.default.getOrigin() + '/bolo/api/share/record.htm', data);\n  }\n\n  // 如果有传OSType参数进来，直接下载对应的安装包\n  if (OSType === 'android') {\n    location.href = A_URL;\n    _Stat2.default.send('安卓下载按钮', {\n      label: '来源：' + (source || 'default')\n    });\n  } else if (OSType === 'ios') {\n    location.href = 'https://itunes.apple.com/us/app/wang-yi-bo-luo-you-nei-han/id1097491412?l=zh&ls=1&mt=8';\n\n    // 如果没有传OSType，则通过uadetector检测操作系统类型进行下载\n  } else if (_uadetector2.default.isOS('android')) {\n    if (_uadetector2.default.is('MicroMessenger')) {\n      console.log('ok');\n      location.href = 'http://a.app.qq.com/o/simple.jsp?pkgname=com.netease.bolo.android';\n    } else {\n      console.log('not ok');\n      location.href = A_URL;\n    }\n    _Stat2.default.send('安卓下载按钮', {\n      label: '来源：' + (source || 'default')\n    });\n  } else if (_uadetector2.default.isOS('ios')) {\n    if (_uadetector2.default.is('MicroMessenger')) {\n      location.href = 'http://a.app.qq.com/o/simple.jsp?pkgname=com.netease.bolo.android';\n    } else {\n      location.href = 'https://itunes.apple.com/us/app/wang-yi-bo-luo-you-nei-han/id1097491412?l=zh&ls=1&mt=8';\n    }\n    _Stat2.default.send('IOS下载按钮', {\n      label: '来源：' + (source || 'default')\n    });\n    //Stat.send('IOS下载按钮','tap','来源：' + (source || 'default'));\n  } else {\n    location.href = 'http://a.app.qq.com/o/simple.jsp?pkgname=com.netease.bolo.android';\n    _Stat2.default.send('其它系统下载按钮', {\n      label: '来源：' + (source || 'default')\n    });\n    //Stat.send('其它系统下载按钮','tap','来源：' + (source || 'default'));\n  }\n}\n\nfunction _call(cmd, params, callback) {\n  if (!_uadetector2.default.is('BOLO')) return;\n\n  if (_base2.default.isFunction(params)) {\n    callback = params;\n    params = '';\n  }\n\n  if (_uadetector2.default.isOS('android')) {\n\n    var result;\n    if (params) result = html5Util[cmd](JSON.stringify(params));else result = html5Util[cmd]();\n    if (callback && _base2.default.isFunction(callback)) callback(result && JSON.parse(result));\n  } else if (_uadetector2.default.isOS('ios')) {\n\n    var data = {\n      cmd: cmd\n    };\n    if (params) data.params = JSON.stringify(params);\n    if (callback && _base2.default.isFunction(callback)) {\n      var callbackName = _base2.default.randomStr('nativeCallback');\n      window[callbackName] = function (result) {\n        callback(result);\n        delete window[callbackName];\n      };\n      data.callback = callbackName;\n    }\n    location.href = _querystring2.default.append('bololive://js', data);\n  }\n}\nvar userInfo = {};\n_call(_uadetector2.default.isOS('android') ? 'getLogininfo' : 'getLoginInfo', function (result) {\n  _base2.default.extend(userInfo, result);\n});\nvar events = {};\n\nfunction hello() {\n  return _uadetector2.default.is('BOLO');\n}\n\nwindow.onnativemessage = function (type, data) {\n  _call(_uadetector2.default.isOS('android') ? 'getLogininfo' : 'getLoginInfo', function (result) {\n    _base2.default.extend(userInfo, result);\n    exports.emit(type, data);\n  });\n};\n\nexports.default = {\n  download: download,\n  call: function call(cmd, params, callback) {\n    switch (cmd) {\n      case 'openVideo':\n        if (_uadetector2.default.isOS('android')) html5Util[cmd](parseInt(params.videoId));else if (_uadetector2.default.isOS('ios')) location.href = 'bololive://js?cmd=' + cmd + '&params=' + JSON.stringify(params);\n        break;\n      case 'getLoginInfo':\n        //安卓用了小写\n        if (_uadetector2.default.isOS('android')) {\n          _call('getLogininfo', params, callback);\n          break;\n        }\n      default:\n        _call(cmd, params, callback);\n    }\n  },\n  hello: hello,\n  userInfo: userInfo,\n  isLogin: function isLogin() {\n    return !!userInfo.userId;\n  },\n  on: function on(name, callback) {\n    var list = events[name] || (events[name] = []);\n    list.push(callback);\n    return this;\n  },\n  off: function off(name, callback) {\n    // Remove *all* events\n    if (!(name || callback)) {\n      events = {};\n      return this;\n    }\n\n    var list = events[name];\n    if (list) {\n      if (callback) {\n        for (var i = list.length - 1; i >= 0; i--) {\n          if (list[i] === callback) {\n            list.splice(i, 1);\n          }\n        }\n      } else {\n        delete this.events[name];\n      }\n    }\n    return this;\n  },\n  emit: function emit(name, data) {\n    var list = events[name];\n\n    if (list) {\n      // Copy callback lists to prevent modification\n      list = list.slice();\n\n      // Execute event callbacks, use index because it's the faster.\n      for (var i = 0, len = list.length; i < len; i++) {\n        list[i](data);\n      }\n    }\n\n    return this;\n  },\n  version: function () {\n    var ua = navigator.userAgent,\n        version,\n        parsedVersion = '';\n    if (hello()) {\n      if (_uadetector2.default.isOS('android')) {\n        version = ua.match(/\\/\\d+\\.\\d+\\.\\d+/);\n        version = version ? version[0].replace('/', '') || 0 : 0;\n      } else {\n        version = ua.match(/iOS[ ](\\d+\\.\\d+\\.\\d+)/);\n        version = version ? version[1] || 0 : 0;\n      }\n\n      if (version) version = version.split('.');else return version;\n\n      version.forEach(function (d, i) {\n        parsedVersion += i > 0 && d < 10 ? '0' + d : d;\n      });\n      return parsedVersion;\n    } else {\n      return 'not in bolo';\n    }\n  }()\n};//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9FOi9naXRfcHJvL2V4cHJlc3Mtd2VicGFjay12dWUvc3JjL3V0aWwvbmF0aXZlLmpzPzBmZTkiXSwibmFtZXMiOlsiUVVFUlkiLCJwYXJzZSIsIkFfVVJMIiwiaXMiLCJhamF4IiwidXJsIiwiZGF0YVR5cGUiLCJqc29ucENhbGxiYWNrIiwic3VjY2VzcyIsInJlc3VsdCIsImRvd25sb2FkIiwic291cmNlIiwiT1NUeXBlIiwic2hhcmVkYnkiLCJ2aWRlb0lkIiwiZGF0YSIsImFjdGlvblR5cGUiLCJjb29raWVJZCIsImdldCIsInVzZXJJZCIsInMiLCJ0b0xvd2VyQ2FzZSIsIkltYWdlIiwic3JjIiwiYXBwZW5kIiwiZ2V0T3JpZ2luIiwibG9jYXRpb24iLCJocmVmIiwic2VuZCIsImxhYmVsIiwiaXNPUyIsImNvbnNvbGUiLCJsb2ciLCJjYWxsIiwiY21kIiwicGFyYW1zIiwiY2FsbGJhY2siLCJpc0Z1bmN0aW9uIiwiaHRtbDVVdGlsIiwiSlNPTiIsInN0cmluZ2lmeSIsImNhbGxiYWNrTmFtZSIsInJhbmRvbVN0ciIsIndpbmRvdyIsInVzZXJJbmZvIiwiZXh0ZW5kIiwiZXZlbnRzIiwiaGVsbG8iLCJvbm5hdGl2ZW1lc3NhZ2UiLCJ0eXBlIiwiZXhwb3J0cyIsImVtaXQiLCJwYXJzZUludCIsImlzTG9naW4iLCJvbiIsIm5hbWUiLCJsaXN0IiwicHVzaCIsIm9mZiIsImkiLCJsZW5ndGgiLCJzcGxpY2UiLCJzbGljZSIsImxlbiIsInZlcnNpb24iLCJ1YSIsIm5hdmlnYXRvciIsInVzZXJBZ2VudCIsInBhcnNlZFZlcnNpb24iLCJtYXRjaCIsInJlcGxhY2UiLCJzcGxpdCIsImZvckVhY2giLCJkIl0sIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQzs7OztBQUNDOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7Ozs7O0FBRUQsSUFBSUEsUUFBUSxzQkFBR0MsS0FBSCxFQUFaOztBQUVBLElBQUlDLEtBQUo7QUFDQSxJQUFHLENBQUMscUJBQVdDLEVBQVgsQ0FBYyxNQUFkLENBQUosRUFBMEI7QUFDekIsa0JBQUVDLElBQUYsQ0FBTztBQUNOQyxTQUFLLHdEQURDO0FBRU5DLGNBQVUsT0FGSjtBQUdOQyxtQkFBZSxnQkFIVDtBQUlOQyxhQUFTLGlCQUFTQyxNQUFULEVBQWdCO0FBQ3hCUCxjQUFRTyxNQUFSO0FBQ0E7QUFOSyxHQUFQO0FBUUE7O0FBRUQ7QUFDQTtBQUNBLFNBQVNDLFFBQVQsQ0FBa0JDLE1BQWxCLEVBQTBCQyxNQUExQixFQUFpQztBQUNoQyxNQUFHLENBQUNWLEtBQUosRUFBVyxPQUFPLEtBQVA7QUFDWDtBQUNBLE1BQUdGLE1BQU1hLFFBQU4sSUFBa0JiLE1BQU1jLE9BQTNCLEVBQW1DO0FBQ2xDLFFBQUlDLE9BQU87QUFDVkMsa0JBQVksQ0FERjtBQUVWQyxnQkFBVSxpQkFBT0MsR0FBUCxDQUFXLFdBQVgsQ0FGQTtBQUdWSixlQUFTZCxNQUFNYyxPQUhMO0FBSVZLLGNBQVFuQixNQUFNYSxRQUpKO0FBS1ZPLFNBQUcsYUFBSSx3QkFBd0IsaUJBQU9GLEdBQVAsQ0FBVyxXQUFYLENBQXhCLEdBQWtELGtDQUF0RCxFQUEwRkcsV0FBMUY7QUFMTyxLQUFYO0FBT0EsUUFBSUMsS0FBSixHQUFZQyxHQUFaLEdBQWtCLHNCQUFHQyxNQUFILENBQVUscUJBQVdDLFNBQVgsS0FBeUIsNEJBQW5DLEVBQWdFVixJQUFoRSxDQUFsQjtBQUNBOztBQUVEO0FBQ0EsTUFBR0gsV0FBVyxTQUFkLEVBQXlCO0FBQ3hCYyxhQUFTQyxJQUFULEdBQWdCekIsS0FBaEI7QUFDQSxtQkFBSzBCLElBQUwsQ0FBVSxRQUFWLEVBQW1CO0FBQ2xCQyxhQUFPLFNBQVNsQixVQUFVLFNBQW5CO0FBRFcsS0FBbkI7QUFHQSxHQUxELE1BS08sSUFBR0MsV0FBVyxLQUFkLEVBQXFCO0FBQzNCYyxhQUFTQyxJQUFULEdBQWdCLHdGQUFoQjs7QUFFRDtBQUNDLEdBSk0sTUFJRCxJQUFHLHFCQUFXRyxJQUFYLENBQWdCLFNBQWhCLENBQUgsRUFBOEI7QUFDbkMsUUFBRyxxQkFBVzNCLEVBQVgsQ0FBYyxnQkFBZCxDQUFILEVBQW1DO0FBQzlCNEIsY0FBUUMsR0FBUixDQUFZLElBQVo7QUFDSk4sZUFBU0MsSUFBVCxHQUFnQixtRUFBaEI7QUFDQSxLQUhELE1BR0s7QUFDQUksY0FBUUMsR0FBUixDQUFZLFFBQVo7QUFDSk4sZUFBU0MsSUFBVCxHQUFnQnpCLEtBQWhCO0FBQ0E7QUFDRCxtQkFBSzBCLElBQUwsQ0FBVSxRQUFWLEVBQW1CO0FBQ2xCQyxhQUFPLFNBQVNsQixVQUFVLFNBQW5CO0FBRFcsS0FBbkI7QUFHQSxHQVhLLE1BV0EsSUFBRyxxQkFBV21CLElBQVgsQ0FBZ0IsS0FBaEIsQ0FBSCxFQUEwQjtBQUMvQixRQUFHLHFCQUFXM0IsRUFBWCxDQUFjLGdCQUFkLENBQUgsRUFBbUM7QUFDbEN1QixlQUFTQyxJQUFULEdBQWdCLG1FQUFoQjtBQUNBLEtBRkQsTUFFSztBQUNKRCxlQUFTQyxJQUFULEdBQWdCLHdGQUFoQjtBQUNBO0FBQ0QsbUJBQUtDLElBQUwsQ0FBVSxTQUFWLEVBQW9CO0FBQ25CQyxhQUFPLFNBQVNsQixVQUFVLFNBQW5CO0FBRFksS0FBcEI7QUFHQTtBQUNBLEdBVkssTUFVRDtBQUNKZSxhQUFTQyxJQUFULEdBQWdCLG1FQUFoQjtBQUNBLG1CQUFLQyxJQUFMLENBQVUsVUFBVixFQUFxQjtBQUNwQkMsYUFBTyxTQUFTbEIsVUFBVSxTQUFuQjtBQURhLEtBQXJCO0FBR0E7QUFDQTtBQUNEOztBQUVELFNBQVNzQixLQUFULENBQWNDLEdBQWQsRUFBa0JDLE1BQWxCLEVBQXlCQyxRQUF6QixFQUFrQztBQUNqQyxNQUFHLENBQUMscUJBQVdqQyxFQUFYLENBQWMsTUFBZCxDQUFKLEVBQTJCOztBQUUzQixNQUFHLGVBQUtrQyxVQUFMLENBQWdCRixNQUFoQixDQUFILEVBQTJCO0FBQzFCQyxlQUFXRCxNQUFYO0FBQ0FBLGFBQVMsRUFBVDtBQUNBOztBQUVELE1BQUcscUJBQVdMLElBQVgsQ0FBZ0IsU0FBaEIsQ0FBSCxFQUE4Qjs7QUFFN0IsUUFBSXJCLE1BQUo7QUFDQSxRQUFHMEIsTUFBSCxFQUFXMUIsU0FBUzZCLFVBQVVKLEdBQVYsRUFBZUssS0FBS0MsU0FBTCxDQUFlTCxNQUFmLENBQWYsQ0FBVCxDQUFYLEtBQ0sxQixTQUFTNkIsVUFBVUosR0FBVixHQUFUO0FBQ0wsUUFBR0UsWUFBWSxlQUFLQyxVQUFMLENBQWdCRCxRQUFoQixDQUFmLEVBQTBDQSxTQUFTM0IsVUFBVThCLEtBQUt0QyxLQUFMLENBQVdRLE1BQVgsQ0FBbkI7QUFFMUMsR0FQRCxNQU9NLElBQUcscUJBQVdxQixJQUFYLENBQWdCLEtBQWhCLENBQUgsRUFBMEI7O0FBRS9CLFFBQUlmLE9BQU87QUFDVm1CLFdBQUtBO0FBREssS0FBWDtBQUdBLFFBQUdDLE1BQUgsRUFBV3BCLEtBQUtvQixNQUFMLEdBQWNJLEtBQUtDLFNBQUwsQ0FBZUwsTUFBZixDQUFkO0FBQ1gsUUFBR0MsWUFBWSxlQUFLQyxVQUFMLENBQWdCRCxRQUFoQixDQUFmLEVBQXlDO0FBQ3hDLFVBQUlLLGVBQWUsZUFBS0MsU0FBTCxDQUFlLGdCQUFmLENBQW5CO0FBQ0FDLGFBQU9GLFlBQVAsSUFBdUIsVUFBU2hDLE1BQVQsRUFBZ0I7QUFDdEMyQixpQkFBUzNCLE1BQVQ7QUFDQSxlQUFPa0MsT0FBT0YsWUFBUCxDQUFQO0FBQ0EsT0FIRDtBQUlBMUIsV0FBS3FCLFFBQUwsR0FBZ0JLLFlBQWhCO0FBQ0E7QUFDRGYsYUFBU0MsSUFBVCxHQUFnQixzQkFBR0gsTUFBSCxDQUFVLGVBQVYsRUFBMEJULElBQTFCLENBQWhCO0FBRUE7QUFDRDtBQUNFLElBQUk2QixXQUFXLEVBQWY7QUFDQVgsTUFBTSxxQkFBV0gsSUFBWCxDQUFnQixTQUFoQixJQUE2QixjQUE3QixHQUE4QyxjQUFwRCxFQUFvRSxVQUFTckIsTUFBVCxFQUFnQjtBQUNoRixpQkFBS29DLE1BQUwsQ0FBWUQsUUFBWixFQUFxQm5DLE1BQXJCO0FBQ0gsQ0FGRDtBQUdBLElBQUlxQyxTQUFTLEVBQWI7O0FBRUEsU0FBU0MsS0FBVCxHQUFnQjtBQUNaLFNBQU8scUJBQVc1QyxFQUFYLENBQWMsTUFBZCxDQUFQO0FBQ0g7O0FBRUR3QyxPQUFPSyxlQUFQLEdBQXlCLFVBQVNDLElBQVQsRUFBZWxDLElBQWYsRUFBcUI7QUFDMUNrQixRQUFNLHFCQUFXSCxJQUFYLENBQWdCLFNBQWhCLElBQTZCLGNBQTdCLEdBQThDLGNBQXBELEVBQW9FLFVBQVNyQixNQUFULEVBQWdCO0FBQ2hGLG1CQUFLb0MsTUFBTCxDQUFZRCxRQUFaLEVBQXFCbkMsTUFBckI7QUFDQXlDLFlBQVFDLElBQVIsQ0FBYUYsSUFBYixFQUFtQmxDLElBQW5CO0FBQ0gsR0FIRDtBQUlILENBTEQ7O2tCQVFZO0FBQ1pMLFlBQVVBLFFBREU7QUFFWnVCLFFBQU0sY0FBU0MsR0FBVCxFQUFhQyxNQUFiLEVBQW9CQyxRQUFwQixFQUE4QjtBQUNsQyxZQUFPRixHQUFQO0FBQ0UsV0FBSyxXQUFMO0FBQ0UsWUFBRyxxQkFBV0osSUFBWCxDQUFnQixTQUFoQixDQUFILEVBQStCUSxVQUFVSixHQUFWLEVBQWVrQixTQUFTakIsT0FBT3JCLE9BQWhCLENBQWYsRUFBL0IsS0FDSyxJQUFHLHFCQUFXZ0IsSUFBWCxDQUFnQixLQUFoQixDQUFILEVBQTJCSixTQUFTQyxJQUFULEdBQWdCLHVCQUF1Qk8sR0FBdkIsR0FBNkIsVUFBN0IsR0FBMENLLEtBQUtDLFNBQUwsQ0FBZUwsTUFBZixDQUExRDtBQUNoQztBQUNGLFdBQUssY0FBTDtBQUNFO0FBQ0EsWUFBRyxxQkFBV0wsSUFBWCxDQUFnQixTQUFoQixDQUFILEVBQThCO0FBQzVCRyxnQkFBSyxjQUFMLEVBQW9CRSxNQUFwQixFQUEyQkMsUUFBM0I7QUFDQTtBQUNEO0FBQ0g7QUFDRUgsY0FBS0MsR0FBTCxFQUFTQyxNQUFULEVBQWdCQyxRQUFoQjtBQVpKO0FBY0QsR0FqQlc7QUFrQlpXLFNBQU9BLEtBbEJLO0FBbUJaSCxZQUFVQSxRQW5CRTtBQW9CWlMsV0FBUyxtQkFBVTtBQUNqQixXQUFPLENBQUMsQ0FBQ1QsU0FBU3pCLE1BQWxCO0FBQ0QsR0F0Qlc7QUF1QlptQyxNQUFJLFlBQVNDLElBQVQsRUFBZW5CLFFBQWYsRUFBd0I7QUFDMUIsUUFBSW9CLE9BQU9WLE9BQU9TLElBQVAsTUFBaUJULE9BQU9TLElBQVAsSUFBZSxFQUFoQyxDQUFYO0FBQ0FDLFNBQUtDLElBQUwsQ0FBVXJCLFFBQVY7QUFDQSxXQUFPLElBQVA7QUFDRCxHQTNCVztBQTRCWnNCLE9BQUssYUFBU0gsSUFBVCxFQUFlbkIsUUFBZixFQUF5QjtBQUM1QjtBQUNBLFFBQUksRUFBRW1CLFFBQVFuQixRQUFWLENBQUosRUFBeUI7QUFDdkJVLGVBQVMsRUFBVDtBQUNBLGFBQU8sSUFBUDtBQUNEOztBQUVELFFBQUlVLE9BQU9WLE9BQU9TLElBQVAsQ0FBWDtBQUNBLFFBQUlDLElBQUosRUFBVTtBQUNSLFVBQUlwQixRQUFKLEVBQWM7QUFDWixhQUFLLElBQUl1QixJQUFJSCxLQUFLSSxNQUFMLEdBQWMsQ0FBM0IsRUFBOEJELEtBQUssQ0FBbkMsRUFBc0NBLEdBQXRDLEVBQTJDO0FBQ3pDLGNBQUlILEtBQUtHLENBQUwsTUFBWXZCLFFBQWhCLEVBQTBCO0FBQ3hCb0IsaUJBQUtLLE1BQUwsQ0FBWUYsQ0FBWixFQUFlLENBQWY7QUFDRDtBQUNGO0FBQ0YsT0FORCxNQU9LO0FBQ0gsZUFBTyxLQUFLYixNQUFMLENBQVlTLElBQVosQ0FBUDtBQUNEO0FBQ0Y7QUFDRCxXQUFPLElBQVA7QUFDRCxHQWpEVztBQWtEWkosUUFBTSxjQUFTSSxJQUFULEVBQWV4QyxJQUFmLEVBQXFCO0FBQ3pCLFFBQUl5QyxPQUFPVixPQUFPUyxJQUFQLENBQVg7O0FBRUEsUUFBSUMsSUFBSixFQUFVO0FBQ1I7QUFDQUEsYUFBT0EsS0FBS00sS0FBTCxFQUFQOztBQUVBO0FBQ0EsV0FBSSxJQUFJSCxJQUFJLENBQVIsRUFBV0ksTUFBTVAsS0FBS0ksTUFBMUIsRUFBa0NELElBQUlJLEdBQXRDLEVBQTJDSixHQUEzQyxFQUFnRDtBQUM5Q0gsYUFBS0csQ0FBTCxFQUFRNUMsSUFBUjtBQUNEO0FBQ0Y7O0FBRUQsV0FBTyxJQUFQO0FBQ0QsR0FoRVc7QUFpRVppRCxXQUFVLFlBQVU7QUFDbEIsUUFBSUMsS0FBS0MsVUFBVUMsU0FBbkI7QUFBQSxRQUNFSCxPQURGO0FBQUEsUUFFRUksZ0JBQWdCLEVBRmxCO0FBR0EsUUFBR3JCLE9BQUgsRUFBVztBQUNULFVBQUcscUJBQVdqQixJQUFYLENBQWdCLFNBQWhCLENBQUgsRUFBOEI7QUFDNUJrQyxrQkFBVUMsR0FBR0ksS0FBSCxDQUFTLGlCQUFULENBQVY7QUFDQUwsa0JBQVVBLFVBQVdBLFFBQVEsQ0FBUixFQUFXTSxPQUFYLENBQW1CLEdBQW5CLEVBQXVCLEVBQXZCLEtBQThCLENBQXpDLEdBQThDLENBQXhEO0FBQ0QsT0FIRCxNQUdLO0FBQ0hOLGtCQUFVQyxHQUFHSSxLQUFILENBQVMsdUJBQVQsQ0FBVjtBQUNBTCxrQkFBVUEsVUFBV0EsUUFBUSxDQUFSLEtBQWMsQ0FBekIsR0FBOEIsQ0FBeEM7QUFDRDs7QUFFRCxVQUFHQSxPQUFILEVBQVlBLFVBQVVBLFFBQVFPLEtBQVIsQ0FBYyxHQUFkLENBQVYsQ0FBWixLQUNLLE9BQU9QLE9BQVA7O0FBRUxBLGNBQVFRLE9BQVIsQ0FBZ0IsVUFBU0MsQ0FBVCxFQUFXZCxDQUFYLEVBQWE7QUFDM0JTLHlCQUFpQlQsSUFBSSxDQUFKLElBQVNjLElBQUksRUFBYixHQUFtQixNQUFNQSxDQUF6QixHQUE4QkEsQ0FBL0M7QUFDRCxPQUZEO0FBR0EsYUFBT0wsYUFBUDtBQUNELEtBaEJELE1BZ0JLO0FBQ0gsYUFBTyxhQUFQO0FBQ0Q7QUFDRixHQXZCUztBQWpFRSxDIiwiZmlsZSI6IjE4LmpzIiwic291cmNlc0NvbnRlbnQiOlsiXHRpbXBvcnQgYmFzZSBmcm9tICcuL2Jhc2UnO1xuICBpbXBvcnQgdWFkZXRlY3RvciBmcm9tICcuL3VhZGV0ZWN0b3InO1xuICBpbXBvcnQgSHR0cEhlbHBlciBmcm9tICcuL0h0dHBIZWxwZXInO1xuICBpbXBvcnQgcXMgZnJvbSAnLi9xdWVyeXN0cmluZyc7XG4gIGltcG9ydCB7bWQ1fSBmcm9tICcuL21kNSc7XG4gIGltcG9ydCBjb29raWUgZnJvbSAnLi9jb29raWUnO1xuICBpbXBvcnQgU3RhdCBmcm9tICcuL1N0YXQnO1xuICBpbXBvcnQgJCBmcm9tICcuL3plcHRvJztcblxuXHR2YXIgUVVFUlkgPSBxcy5wYXJzZSgpO1xuXG5cdHZhciBBX1VSTDtcblx0aWYoIXVhZGV0ZWN0b3IuaXMoJ0JPTE8nKSl7XG5cdFx0JC5hamF4KHtcblx0XHRcdHVybDogJ2h0dHA6Ly93d3cuYm9iby5jb20vc3BlY2lhbC8wMDM1MDBNRy9ib2xvYW5kcm9pZHVybC5qcycsXG5cdFx0XHRkYXRhVHlwZTogJ2pzb25wJyxcblx0XHRcdGpzb25wQ2FsbGJhY2s6ICdnZXRVcmxDYWxsYmFjaycsXG5cdFx0XHRzdWNjZXNzOiBmdW5jdGlvbihyZXN1bHQpe1xuXHRcdFx0XHRBX1VSTCA9IHJlc3VsdDtcblx0XHRcdH1cblx0XHR9KTtcblx0fVxuXG5cdC8vIEBwYXJhbSBzb3VyY2U6IFN0cmluZyDlv4XpgInpobnvvIzpobXpnaLmnaXmupBcblx0Ly8gQHBhcmFtIE9TVHlwZTogU3RyaW5nIOWPr+mAiemhue+8jFwiYW5kcm9pZFwi6KGo56S65a6J5Y2T5LiL6L2977yMXCJpb3NcIuihqOekumlvc+iuvuWkh+S4i+i9vVxuXHRmdW5jdGlvbiBkb3dubG9hZChzb3VyY2UsIE9TVHlwZSl7XG5cdFx0aWYoIUFfVVJMKSByZXR1cm4gZmFsc2U7XG5cdFx0Ly/liIbkuqvorqHliJLkuIvovb3ph4/nu5/orqFcblx0XHRpZihRVUVSWS5zaGFyZWRieSAmJiBRVUVSWS52aWRlb0lkKXtcblx0XHRcdHZhciBkYXRhID0ge1xuXHRcdFx0XHRhY3Rpb25UeXBlOiAzLFxuXHRcdFx0XHRjb29raWVJZDogY29va2llLmdldCgndmlzaXRldWlkJyksXG5cdFx0XHRcdHZpZGVvSWQ6IFFVRVJZLnZpZGVvSWQsXG5cdFx0XHRcdHVzZXJJZDogUVVFUlkuc2hhcmVkYnksXG5cdFx0XHRcdHM6IG1kNSgnYWN0aW9uVHlwZTNjb29raWVJZCcgKyBjb29raWUuZ2V0KCd2aXNpdGV1aWQnKSArICd1YUhpZE5zVnY4UTN4NGxseEtpS0N4VHJqWWtEZUJSaScpLnRvTG93ZXJDYXNlKClcblx0XHRcdH07XG5cdFx0XHRuZXcgSW1hZ2UoKS5zcmMgPSBxcy5hcHBlbmQoSHR0cEhlbHBlci5nZXRPcmlnaW4oKSArICcvYm9sby9hcGkvc2hhcmUvcmVjb3JkLmh0bScsZGF0YSk7XG5cdFx0fVxuXG5cdFx0Ly8g5aaC5p6c5pyJ5LygT1NUeXBl5Y+C5pWw6L+b5p2l77yM55u05o6l5LiL6L295a+55bqU55qE5a6J6KOF5YyFXG5cdFx0aWYoT1NUeXBlID09PSAnYW5kcm9pZCcpIHtcblx0XHRcdGxvY2F0aW9uLmhyZWYgPSBBX1VSTDtcblx0XHRcdFN0YXQuc2VuZCgn5a6J5Y2T5LiL6L295oyJ6ZKuJyx7XG5cdFx0XHRcdGxhYmVsOiAn5p2l5rqQ77yaJyArIChzb3VyY2UgfHwgJ2RlZmF1bHQnKVxuXHRcdFx0fSk7XG5cdFx0fSBlbHNlIGlmKE9TVHlwZSA9PT0gJ2lvcycpIHtcblx0XHRcdGxvY2F0aW9uLmhyZWYgPSAnaHR0cHM6Ly9pdHVuZXMuYXBwbGUuY29tL3VzL2FwcC93YW5nLXlpLWJvLWx1by15b3UtbmVpLWhhbi9pZDEwOTc0OTE0MTI/bD16aCZscz0xJm10PTgnO1xuXG5cdFx0Ly8g5aaC5p6c5rKh5pyJ5LygT1NUeXBl77yM5YiZ6YCa6L+HdWFkZXRlY3RvcuajgOa1i+aTjeS9nOezu+e7n+exu+Wei+i/m+ihjOS4i+i9vVxuXHRcdH1lbHNlIGlmKHVhZGV0ZWN0b3IuaXNPUygnYW5kcm9pZCcpKXtcblx0XHRcdGlmKHVhZGV0ZWN0b3IuaXMoJ01pY3JvTWVzc2VuZ2VyJykpe1xuICAgICAgICBjb25zb2xlLmxvZygnb2snKTtcblx0XHRcdFx0bG9jYXRpb24uaHJlZiA9ICdodHRwOi8vYS5hcHAucXEuY29tL28vc2ltcGxlLmpzcD9wa2duYW1lPWNvbS5uZXRlYXNlLmJvbG8uYW5kcm9pZCc7XG5cdFx0XHR9ZWxzZXtcbiAgICAgICAgY29uc29sZS5sb2coJ25vdCBvaycpO1xuXHRcdFx0XHRsb2NhdGlvbi5ocmVmID0gQV9VUkw7XG5cdFx0XHR9XG5cdFx0XHRTdGF0LnNlbmQoJ+WuieWNk+S4i+i9veaMiemSricse1xuXHRcdFx0XHRsYWJlbDogJ+adpea6kO+8micgKyAoc291cmNlIHx8ICdkZWZhdWx0Jylcblx0XHRcdH0pO1xuXHRcdH1lbHNlIGlmKHVhZGV0ZWN0b3IuaXNPUygnaW9zJykpe1xuXHRcdFx0aWYodWFkZXRlY3Rvci5pcygnTWljcm9NZXNzZW5nZXInKSl7XG5cdFx0XHRcdGxvY2F0aW9uLmhyZWYgPSAnaHR0cDovL2EuYXBwLnFxLmNvbS9vL3NpbXBsZS5qc3A/cGtnbmFtZT1jb20ubmV0ZWFzZS5ib2xvLmFuZHJvaWQnO1xuXHRcdFx0fWVsc2V7XG5cdFx0XHRcdGxvY2F0aW9uLmhyZWYgPSAnaHR0cHM6Ly9pdHVuZXMuYXBwbGUuY29tL3VzL2FwcC93YW5nLXlpLWJvLWx1by15b3UtbmVpLWhhbi9pZDEwOTc0OTE0MTI/bD16aCZscz0xJm10PTgnO1xuXHRcdFx0fVxuXHRcdFx0U3RhdC5zZW5kKCdJT1PkuIvovb3mjInpkq4nLHtcblx0XHRcdFx0bGFiZWw6ICfmnaXmupDvvJonICsgKHNvdXJjZSB8fCAnZGVmYXVsdCcpXG5cdFx0XHR9KTtcblx0XHRcdC8vU3RhdC5zZW5kKCdJT1PkuIvovb3mjInpkq4nLCd0YXAnLCfmnaXmupDvvJonICsgKHNvdXJjZSB8fCAnZGVmYXVsdCcpKTtcblx0XHR9ZWxzZXtcblx0XHRcdGxvY2F0aW9uLmhyZWYgPSAnaHR0cDovL2EuYXBwLnFxLmNvbS9vL3NpbXBsZS5qc3A/cGtnbmFtZT1jb20ubmV0ZWFzZS5ib2xvLmFuZHJvaWQnO1xuXHRcdFx0U3RhdC5zZW5kKCflhbblroPns7vnu5/kuIvovb3mjInpkq4nLHtcblx0XHRcdFx0bGFiZWw6ICfmnaXmupDvvJonICsgKHNvdXJjZSB8fCAnZGVmYXVsdCcpXG5cdFx0XHR9KTtcblx0XHRcdC8vU3RhdC5zZW5kKCflhbblroPns7vnu5/kuIvovb3mjInpkq4nLCd0YXAnLCfmnaXmupDvvJonICsgKHNvdXJjZSB8fCAnZGVmYXVsdCcpKTtcblx0XHR9XG5cdH1cblxuXHRmdW5jdGlvbiBjYWxsKGNtZCxwYXJhbXMsY2FsbGJhY2spe1xuXHRcdGlmKCF1YWRldGVjdG9yLmlzKCdCT0xPJykpIHJldHVybjtcblxuXHRcdGlmKGJhc2UuaXNGdW5jdGlvbihwYXJhbXMpKXtcblx0XHRcdGNhbGxiYWNrID0gcGFyYW1zO1xuXHRcdFx0cGFyYW1zID0gJyc7XG5cdFx0fVxuXG5cdFx0aWYodWFkZXRlY3Rvci5pc09TKCdhbmRyb2lkJykpe1xuXG5cdFx0XHR2YXIgcmVzdWx0O1xuXHRcdFx0aWYocGFyYW1zKSByZXN1bHQgPSBodG1sNVV0aWxbY21kXShKU09OLnN0cmluZ2lmeShwYXJhbXMpKTtcblx0XHRcdGVsc2UgcmVzdWx0ID0gaHRtbDVVdGlsW2NtZF0oKTtcblx0XHRcdGlmKGNhbGxiYWNrICYmIGJhc2UuaXNGdW5jdGlvbihjYWxsYmFjaykpIGNhbGxiYWNrKHJlc3VsdCAmJiBKU09OLnBhcnNlKHJlc3VsdCkpO1xuXG5cdFx0fWVsc2UgaWYodWFkZXRlY3Rvci5pc09TKCdpb3MnKSl7XG5cblx0XHRcdHZhciBkYXRhID0ge1xuXHRcdFx0XHRjbWQ6IGNtZFxuXHRcdFx0fTtcblx0XHRcdGlmKHBhcmFtcykgZGF0YS5wYXJhbXMgPSBKU09OLnN0cmluZ2lmeShwYXJhbXMpO1xuXHRcdFx0aWYoY2FsbGJhY2sgJiYgYmFzZS5pc0Z1bmN0aW9uKGNhbGxiYWNrKSl7XG5cdFx0XHRcdHZhciBjYWxsYmFja05hbWUgPSBiYXNlLnJhbmRvbVN0cignbmF0aXZlQ2FsbGJhY2snKTtcblx0XHRcdFx0d2luZG93W2NhbGxiYWNrTmFtZV0gPSBmdW5jdGlvbihyZXN1bHQpe1xuXHRcdFx0XHRcdGNhbGxiYWNrKHJlc3VsdCk7XG5cdFx0XHRcdFx0ZGVsZXRlIHdpbmRvd1tjYWxsYmFja05hbWVdO1xuXHRcdFx0XHR9O1xuXHRcdFx0XHRkYXRhLmNhbGxiYWNrID0gY2FsbGJhY2tOYW1lO1xuXHRcdFx0fVxuXHRcdFx0bG9jYXRpb24uaHJlZiA9IHFzLmFwcGVuZCgnYm9sb2xpdmU6Ly9qcycsZGF0YSk7XG5cblx0XHR9XG5cdH1cbiAgICB2YXIgdXNlckluZm8gPSB7fTtcbiAgICBjYWxsKCh1YWRldGVjdG9yLmlzT1MoJ2FuZHJvaWQnKSA/ICdnZXRMb2dpbmluZm8nIDogJ2dldExvZ2luSW5mbycpLGZ1bmN0aW9uKHJlc3VsdCl7XG4gICAgICAgIGJhc2UuZXh0ZW5kKHVzZXJJbmZvLHJlc3VsdCk7XG4gICAgfSk7XG4gICAgdmFyIGV2ZW50cyA9IHt9O1xuXG4gICAgZnVuY3Rpb24gaGVsbG8oKXtcbiAgICAgICAgcmV0dXJuIHVhZGV0ZWN0b3IuaXMoJ0JPTE8nKTtcbiAgICB9XG5cbiAgICB3aW5kb3cub25uYXRpdmVtZXNzYWdlID0gZnVuY3Rpb24odHlwZSwgZGF0YSkge1xuICAgICAgICBjYWxsKCh1YWRldGVjdG9yLmlzT1MoJ2FuZHJvaWQnKSA/ICdnZXRMb2dpbmluZm8nIDogJ2dldExvZ2luSW5mbycpLGZ1bmN0aW9uKHJlc3VsdCl7XG4gICAgICAgICAgICBiYXNlLmV4dGVuZCh1c2VySW5mbyxyZXN1bHQpO1xuICAgICAgICAgICAgZXhwb3J0cy5lbWl0KHR5cGUsIGRhdGEpO1xuICAgICAgICB9KTtcbiAgICB9O1xuXG5cblx0ZXhwb3J0IGRlZmF1bHQge1xuICAgIGRvd25sb2FkOiBkb3dubG9hZCxcbiAgICBjYWxsOiBmdW5jdGlvbihjbWQscGFyYW1zLGNhbGxiYWNrKSB7XG4gICAgICBzd2l0Y2goY21kKXtcbiAgICAgICAgY2FzZSAnb3BlblZpZGVvJzpcbiAgICAgICAgICBpZih1YWRldGVjdG9yLmlzT1MoJ2FuZHJvaWQnKSkgaHRtbDVVdGlsW2NtZF0ocGFyc2VJbnQocGFyYW1zLnZpZGVvSWQpKTtcbiAgICAgICAgICBlbHNlIGlmKHVhZGV0ZWN0b3IuaXNPUygnaW9zJykpIGxvY2F0aW9uLmhyZWYgPSAnYm9sb2xpdmU6Ly9qcz9jbWQ9JyArIGNtZCArICcmcGFyYW1zPScgKyBKU09OLnN0cmluZ2lmeShwYXJhbXMpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdnZXRMb2dpbkluZm8nOlxuICAgICAgICAgIC8v5a6J5Y2T55So5LqG5bCP5YaZXG4gICAgICAgICAgaWYodWFkZXRlY3Rvci5pc09TKCdhbmRyb2lkJykpe1xuICAgICAgICAgICAgY2FsbCgnZ2V0TG9naW5pbmZvJyxwYXJhbXMsY2FsbGJhY2spO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGNhbGwoY21kLHBhcmFtcyxjYWxsYmFjayk7XG4gICAgICB9XG4gICAgfSxcbiAgICBoZWxsbzogaGVsbG8sXG4gICAgdXNlckluZm86IHVzZXJJbmZvLFxuICAgIGlzTG9naW46IGZ1bmN0aW9uKCl7XG4gICAgICByZXR1cm4gISF1c2VySW5mby51c2VySWQ7XG4gICAgfSxcbiAgICBvbjogZnVuY3Rpb24obmFtZSwgY2FsbGJhY2spe1xuICAgICAgdmFyIGxpc3QgPSBldmVudHNbbmFtZV0gfHwgKGV2ZW50c1tuYW1lXSA9IFtdKTtcbiAgICAgIGxpc3QucHVzaChjYWxsYmFjayk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIG9mZjogZnVuY3Rpb24obmFtZSwgY2FsbGJhY2spIHtcbiAgICAgIC8vIFJlbW92ZSAqYWxsKiBldmVudHNcbiAgICAgIGlmICghKG5hbWUgfHwgY2FsbGJhY2spKSB7XG4gICAgICAgIGV2ZW50cyA9IHt9O1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cblxuICAgICAgdmFyIGxpc3QgPSBldmVudHNbbmFtZV07XG4gICAgICBpZiAobGlzdCkge1xuICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICBmb3IgKHZhciBpID0gbGlzdC5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgaWYgKGxpc3RbaV0gPT09IGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgIGxpc3Quc3BsaWNlKGksIDEpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGRlbGV0ZSB0aGlzLmV2ZW50c1tuYW1lXVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIGVtaXQ6IGZ1bmN0aW9uKG5hbWUsIGRhdGEpIHtcbiAgICAgIHZhciBsaXN0ID0gZXZlbnRzW25hbWVdO1xuXG4gICAgICBpZiAobGlzdCkge1xuICAgICAgICAvLyBDb3B5IGNhbGxiYWNrIGxpc3RzIHRvIHByZXZlbnQgbW9kaWZpY2F0aW9uXG4gICAgICAgIGxpc3QgPSBsaXN0LnNsaWNlKCk7XG5cbiAgICAgICAgLy8gRXhlY3V0ZSBldmVudCBjYWxsYmFja3MsIHVzZSBpbmRleCBiZWNhdXNlIGl0J3MgdGhlIGZhc3Rlci5cbiAgICAgICAgZm9yKHZhciBpID0gMCwgbGVuID0gbGlzdC5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgIGxpc3RbaV0oZGF0YSlcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIHZlcnNpb246IChmdW5jdGlvbigpe1xuICAgICAgdmFyIHVhID0gbmF2aWdhdG9yLnVzZXJBZ2VudCxcbiAgICAgICAgdmVyc2lvbixcbiAgICAgICAgcGFyc2VkVmVyc2lvbiA9ICcnO1xuICAgICAgaWYoaGVsbG8oKSl7XG4gICAgICAgIGlmKHVhZGV0ZWN0b3IuaXNPUygnYW5kcm9pZCcpKXtcbiAgICAgICAgICB2ZXJzaW9uID0gdWEubWF0Y2goL1xcL1xcZCtcXC5cXGQrXFwuXFxkKy8pO1xuICAgICAgICAgIHZlcnNpb24gPSB2ZXJzaW9uID8gKHZlcnNpb25bMF0ucmVwbGFjZSgnLycsJycpIHx8IDApIDogMDtcbiAgICAgICAgfWVsc2V7XG4gICAgICAgICAgdmVyc2lvbiA9IHVhLm1hdGNoKC9pT1NbIF0oXFxkK1xcLlxcZCtcXC5cXGQrKS8pO1xuICAgICAgICAgIHZlcnNpb24gPSB2ZXJzaW9uID8gKHZlcnNpb25bMV0gfHwgMCkgOiAwO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYodmVyc2lvbikgdmVyc2lvbiA9IHZlcnNpb24uc3BsaXQoJy4nKTtcbiAgICAgICAgZWxzZSByZXR1cm4gdmVyc2lvbjtcblxuICAgICAgICB2ZXJzaW9uLmZvckVhY2goZnVuY3Rpb24oZCxpKXtcbiAgICAgICAgICBwYXJzZWRWZXJzaW9uICs9IGkgPiAwICYmIGQgPCAxMCA/ICgnMCcgKyBkKSA6IGQ7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcGFyc2VkVmVyc2lvbjtcbiAgICAgIH1lbHNle1xuICAgICAgICByZXR1cm4gJ25vdCBpbiBib2xvJztcbiAgICAgIH1cbiAgICB9KCkpXG4gIH07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9FOi9naXRfcHJvL2V4cHJlc3Mtd2VicGFjay12dWUvc3JjL3V0aWwvbmF0aXZlLmpzIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ },
/* 19 */
/***/ function(module, exports) {

	eval("'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\n/**\n * 本模块提供最基础、最核心的接口\n * @module base/1.1.x/\n * @category Infrastructure\n */\n\n/**\n * 把源对象自身的属性（Own Property）扩展到目标对象\n * @method extend\n * @param {Any} target 目标对象\n * @param {Any*} [source] 源对象。若有同名属性，则后者覆盖前者\n * @return {Any} 目标对象\n */\nfunction extend(target) {\n  if (target == null) {\n    throw new Error('target cannot be null');\n  }\n\n  var i = 0,\n      len = arguments.length,\n      key,\n      src;\n  while (++i < len) {\n    src = arguments[i];\n    if (src != null) {\n      for (key in src) {\n        if (src.hasOwnProperty(key)) {\n          target[key] = src[key];\n        }\n      }\n    }\n  }\n\n  return target;\n}\n\n// 扩展过滤器\nvar extendFilters = {\n  // 是否覆盖属性\n  overwrite: function overwrite(ref) {\n    return function (key, src, target) {\n      return ref ? true : !(key in target);\n    };\n  },\n\n  // 是否忽略null和undefined\n  ignoreNull: function ignoreNull(ref) {\n    return function (key, src) {\n      return ref ? src[key] != null : true;\n    };\n  },\n\n  // 是否仅扩展对象自身的属性\n  onlyOwnProperty: function onlyOwnProperty(ref) {\n    return function (key, src) {\n      return ref ? src.hasOwnProperty(key) : true;\n    };\n  },\n\n  // 扩展白名单\n  whiteList: function whiteList(list) {\n    return function (key) {\n      return list.indexOf(key) !== -1;\n    };\n  },\n\n  // 扩展黑名单\n  blackList: function blackList(list) {\n    return function (key) {\n      return list.indexOf(key) === -1;\n    };\n  }\n};\n\n/**\n * 把源对象的属性扩展到目标对象。与extend相比，customExtend提供了更多选项，但不支持多个源对象\n * @method customExtend\n * @param {Any} target 目标对象\n * @param {Any} src 源对象\n * @param {Object*} [options] 选项\n *   @param {Boolean} [options.overwrite=true] 是否覆盖目标对象的同名属性\n *   @param {Array<String>} [options.whiteList] 扩展属性白名单\n *   @param {Array<String>} [options.blackList] 扩展属性黑名单\n *   @param {Boolean} [options.ignoreNull=false] 是否忽略源对象中值为null或undefined的属性\n *   @param {Boolean} [options.onlyOwnProperty=false] 是否仅扩展源对象自身的属性\n * @param {Function(key, src, target)*} [filter] 过滤函数。返回false时表示该属性不被扩展\n * @return {Any} 目标对象\n */\nfunction customExtend(target, src) {\n  if (target == null) {\n    throw new Error('target cannot be null');\n  }\n  if (src == null) {\n    return target;\n  }\n\n  var filters = [],\n      i,\n      key,\n      temp;\n  // 第1个参数之后为选项或过滤函数\n  for (i = 2; i < arguments.length; i++) {\n    temp = arguments[i];\n    switch (typeof temp === 'undefined' ? 'undefined' : _typeof(temp)) {\n      case 'object':\n        for (key in temp) {\n          if (extendFilters.hasOwnProperty(key)) {\n            filters.push(extendFilters[key](temp[key]));\n          }\n        }\n        break;\n\n      case 'function':\n        filters.push(temp);\n        break;\n    }\n  }\n\n  for (key in src) {\n    temp = true;\n    for (i = 0; i < filters.length; i++) {\n      // 返回false表示属性不被扩展\n      if (filters[i].call(window, key, src, target) === false) {\n        temp = false;\n        break;\n      }\n    }\n    if (temp) {\n      target[key] = src[key];\n    }\n  }\n\n  return target;\n}\n\nvar undefined;\n/**\n * 检查变量的值是否为undefined\n * @method isUndefined\n * @param {Any} value 待测变量\n * @return {Boolean} 待测变量是否为undefined\n */\nfunction isUndefined(value) {\n  return value === undefined;\n}\n\n// 用于基本类型判断\nvar toString = Object.prototype.toString;\n\n/**\n * 检查变量是否Function类型\n * @method isFunction\n * @param {Any} value 待测变量\n * @return {Boolean} 待测变量是否Function类型\n */\nfunction isFunction(value) {\n  return toString.call(value) === '[object Function]';\n}\n\n/**\n * 检查变量是否Date类型\n * @method isDate\n * @param {Any} value 待测变量\n * @return {Boolean} 待测变量是否Date类型\n */\nfunction isDate(value) {\n  return toString.call(value) === '[object Date]';\n}\n\n/**\n * 检查变量是否Object类型\n * @method isObject\n * @param {Any} value 待测变量\n * @return {Boolean} 待测变量是否Object类型\n */\nfunction isObject(value) {\n  return toString.call(value) === '[object Object]';\n}\n\n/**\n * 检查变量是否Array类型\n * @method isArray\n * @param {Any} value 待测变量\n * @return {Boolean} 待测变量是否Array类型\n */\nvar isArray = Array.isArray || function (value) {\n  return toString.call(value) === '[object Array]';\n};\n\n/**\n * 检查对象是否空Object\n * @method isEmptyObject\n * @param {Object} obj 待测对象\n * @return {Boolean} 待测对象是否空Object\n */\nfunction isEmptyObject(obj) {\n  if (obj != null) {\n    for (var key in obj) {\n      if (obj.hasOwnProperty(key)) {\n        return false;\n      }\n    }\n  }\n  return true;\n}\n\n/**\n * 对指定对象的每个元素执行指定函数\n * @method each\n * @param {Object|Array|ArrayLike} obj 目标对象\n * @param {Function(value,key,obj)} callback 操作函数，上下文为当前元素。\n *   当返回值为false时，遍历中断\n * @return {Object|Array|ArrayLike} 遍历对象\n */\nfunction each(obj, callback) {\n  if (obj != null) {\n    var i,\n        len = obj.length;\n    if (len === undefined || isFunction(obj)) {\n      for (i in obj) {\n        if (obj.hasOwnProperty(i) && false === callback.call(obj[i], obj[i], i, obj)) {\n          break;\n        }\n      }\n    } else {\n      i = -1;\n      while (++i < len) {\n        if (false === callback.call(obj[i], obj[i], i, obj)) {\n          break;\n        }\n      }\n    }\n  }\n\n  return obj;\n}\n\n/**\n * 把对象转换为数组\n * @method toArray\n * @param {Array|ArrayLike} obj 对象\n * @return {Array} 数组\n */\nfunction toArray(obj) {\n  var result;\n  try {\n    result = Array.prototype.slice.call(obj);\n  } catch (e) {\n    result = [];\n    var i = obj.length;\n    while (i) {\n      result[--i] = obj[i];\n    }\n  }\n\n  return result;\n}\n\n/**\n * 把数组二的元素合并到数组一\n * @method merge\n * @param {Array} first 数组一\n * @param {Array} second 数组二\n * @return {Array} 合并后的数组一\n */\nfunction merge(first, second) {\n  var len = second.length,\n      j = 0,\n      i = first.length;\n  while (j < len) {\n    first[i++] = second[j++];\n  }\n  first.length = i;\n\n  return first;\n}\n\n/**\n * 返回一个新函数，使目标函数只执行一次\n * @method once\n * @param {Function} fn 目标函数\n * @return {Function} 新函数\n */\nfunction once(fn) {\n  var returnValue;\n  return function () {\n    if (fn) {\n      returnValue = fn.apply(this, arguments);\n      fn = null;\n    }\n    return returnValue;\n  };\n}\n\n/**\n * 生成长度为16的随机字符串（不保证一定不重复，但基本上不会重复）\n * @method randomStr\n * @param {String} [prefix] 前缀\n * @return {String} 生成的字符串\n */\nfunction randomStr(prefix) {\n  var result = '';\n  do {\n    result += Math.random().toString(36).substr(2);\n  } while (result.length < 10);\n\n  result = result.substr(0, 10) + ('00000' + Math.abs(new Date())).slice(-6);\n\n  if (prefix) {\n    result = prefix + result;\n  }\n\n  return result;\n}\n\n/**\n * 移除全局变量\n * @method deleteGlobalVar\n * @param {String} name 变量名\n */\nfunction deleteGlobalVar(name) {\n  try {\n    delete window[name];\n  } catch (e) {\n    window[name] = null;\n  }\n}\n\n/**\n * 创建类\n * @method createClass\n * @param {Function} constructor 构造函数\n * @param {Object} [methods] 方法\n * @param {Function} [Parent] 父类\n * @param {Function(args)|Array} [parentArgs] 传递给父类的参数，默认与子类构造函数参数一致\n * @return {Function} 类\n */\nfunction createClass(constructor, methods, Parent, parentArgs) {\n  var $Class = Parent ? function () {\n    Parent.apply(this, parentArgs ? typeof parentArgs === 'function' ? parentArgs.apply(this, arguments) : parentArgs : arguments);\n    constructor.apply(this, arguments);\n  } : function () {\n    constructor.apply(this, arguments);\n  };\n\n  if (Parent) {\n    var $Parent = function $Parent() {};\n    $Parent.prototype = Parent.prototype;\n    $Class.prototype = new $Parent();\n    $Class.prototype.constructor = $Class;\n  }\n\n  if (methods) {\n    for (var m in methods) {\n      if (methods.hasOwnProperty(m)) {\n        $Class.prototype[m] = methods[m];\n      }\n    }\n  }\n\n  return $Class;\n}\n\nexports.default = {\n  extend: extend,\n  customExtend: customExtend,\n  isUndefined: isUndefined,\n  isFunction: isFunction,\n  isDate: isDate,\n  isObject: isObject,\n  isArray: isArray,\n  isEmptyObject: isEmptyObject,\n  each: each,\n  toArray: toArray,\n  merge: merge,\n  once: once,\n  randomStr: randomStr,\n  deleteGlobalVar: deleteGlobalVar,\n  createClass: createClass\n};//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9FOi9naXRfcHJvL2V4cHJlc3Mtd2VicGFjay12dWUvc3JjL3V0aWwvYmFzZS5qcz85ZWYzIl0sIm5hbWVzIjpbImV4dGVuZCIsInRhcmdldCIsIkVycm9yIiwiaSIsImxlbiIsImFyZ3VtZW50cyIsImxlbmd0aCIsImtleSIsInNyYyIsImhhc093blByb3BlcnR5IiwiZXh0ZW5kRmlsdGVycyIsIm92ZXJ3cml0ZSIsInJlZiIsImlnbm9yZU51bGwiLCJvbmx5T3duUHJvcGVydHkiLCJ3aGl0ZUxpc3QiLCJsaXN0IiwiaW5kZXhPZiIsImJsYWNrTGlzdCIsImN1c3RvbUV4dGVuZCIsImZpbHRlcnMiLCJ0ZW1wIiwicHVzaCIsImNhbGwiLCJ3aW5kb3ciLCJ1bmRlZmluZWQiLCJpc1VuZGVmaW5lZCIsInZhbHVlIiwidG9TdHJpbmciLCJPYmplY3QiLCJwcm90b3R5cGUiLCJpc0Z1bmN0aW9uIiwiaXNEYXRlIiwiaXNPYmplY3QiLCJpc0FycmF5IiwiQXJyYXkiLCJpc0VtcHR5T2JqZWN0Iiwib2JqIiwiZWFjaCIsImNhbGxiYWNrIiwidG9BcnJheSIsInJlc3VsdCIsInNsaWNlIiwiZSIsIm1lcmdlIiwiZmlyc3QiLCJzZWNvbmQiLCJqIiwib25jZSIsImZuIiwicmV0dXJuVmFsdWUiLCJhcHBseSIsInJhbmRvbVN0ciIsInByZWZpeCIsIk1hdGgiLCJyYW5kb20iLCJzdWJzdHIiLCJhYnMiLCJEYXRlIiwiZGVsZXRlR2xvYmFsVmFyIiwibmFtZSIsImNyZWF0ZUNsYXNzIiwiY29uc3RydWN0b3IiLCJtZXRob2RzIiwiUGFyZW50IiwicGFyZW50QXJncyIsIiRDbGFzcyIsIiRQYXJlbnQiLCJtIl0sIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBOzs7Ozs7QUFPQTs7Ozs7OztBQU9BLFNBQVNBLE1BQVQsQ0FBZ0JDLE1BQWhCLEVBQXdCO0FBQ3RCLE1BQUlBLFVBQVUsSUFBZCxFQUFvQjtBQUFFLFVBQU0sSUFBSUMsS0FBSixDQUFVLHVC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QW5CO0FBQ0FELFdBQU9wQyxTQUFQLENBQWlCZ0MsV0FBakIsR0FBK0JJLE1BQS9CO0FBQ0Q7O0FBRUQsTUFBSUgsT0FBSixFQUFhO0FBQ1gsU0FBSyxJQUFJSyxDQUFULElBQWNMLE9BQWQsRUFBdUI7QUFDckIsVUFBS0EsUUFBUXRELGNBQVIsQ0FBdUIyRCxDQUF2QixDQUFMLEVBQWlDO0FBQy9CRixlQUFPcEMsU0FBUCxDQUFpQnNDLENBQWpCLElBQXNCTCxRQUFRSyxDQUFSLENBQXRCO0FBQ0Q7QUFDRjtBQUNGOztBQUVELFNBQU9GLE1BQVA7QUFDRDs7a0JBR2M7QUFDYmxFLFVBQVFBLE1BREs7QUFFYm1CLGdCQUFjQSxZQUZEO0FBR2JPLGVBQWFBLFdBSEE7QUFJYkssY0FBWUEsVUFKQztBQUtiQyxVQUFRQSxNQUxLO0FBTWJDLFlBQVVBLFFBTkc7QUFPYkMsV0FBU0EsT0FQSTtBQVFiRSxpQkFBZUEsYUFSRjtBQVNiRSxRQUFNQSxJQVRPO0FBVWJFLFdBQVNBLE9BVkk7QUFXYkksU0FBT0EsS0FYTTtBQVliSSxRQUFNQSxJQVpPO0FBYWJJLGFBQVdBLFNBYkU7QUFjYk8sbUJBQWlCQSxlQWRKO0FBZWJFLGVBQWFBO0FBZkEsQyIsImZpbGUiOiIxOS5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICog5pys5qih5Z2X5o+Q5L6b5pyA5Z+656GA44CB5pyA5qC45b+D55qE5o6l5Y+jXG4gKiBAbW9kdWxlIGJhc2UvMS4xLngvXG4gKiBAY2F0ZWdvcnkgSW5mcmFzdHJ1Y3R1cmVcbiAqL1xuXG5cbi8qKlxuICog5oqK5rqQ5a+56LGh6Ieq6Lqr55qE5bGe5oCn77yIT3duIFByb3BlcnR577yJ5omp5bGV5Yiw55uu5qCH5a+56LGhXG4gKiBAbWV0aG9kIGV4dGVuZFxuICogQHBhcmFtIHtBbnl9IHRhcmdldCDnm67moIflr7nosaFcbiAqIEBwYXJhbSB7QW55Kn0gW3NvdXJjZV0g5rqQ5a+56LGh44CC6Iul5pyJ5ZCM5ZCN5bGe5oCn77yM5YiZ5ZCO6ICF6KaG55uW5YmN6ICFXG4gKiBAcmV0dXJuIHtBbnl9IOebruagh+WvueixoVxuICovXG5mdW5jdGlvbiBleHRlbmQodGFyZ2V0KSB7XG4gIGlmICh0YXJnZXQgPT0gbnVsbCkgeyB0aHJvdyBuZXcgRXJyb3IoJ3RhcmdldCBjYW5ub3QgYmUgbnVsbCcpOyB9XG5cbiAgdmFyIGkgPSAwLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBrZXksIHNyYztcbiAgd2hpbGUgKCsraSA8IGxlbikge1xuICAgIHNyYyA9IGFyZ3VtZW50c1tpXTtcbiAgICBpZiAoc3JjICE9IG51bGwpIHtcbiAgICAgIGZvciAoa2V5IGluIHNyYykge1xuICAgICAgICBpZiAoIHNyYy5oYXNPd25Qcm9wZXJ0eShrZXkpICkgeyB0YXJnZXRba2V5XSA9IHNyY1trZXldOyB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRhcmdldDtcbn1cblxuXG4vLyDmianlsZXov4fmu6TlmahcbnZhciBleHRlbmRGaWx0ZXJzID0ge1xuICAvLyDmmK/lkKbopobnm5blsZ7mgKdcbiAgb3ZlcndyaXRlOiBmdW5jdGlvbihyZWYpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oa2V5LCBzcmMsIHRhcmdldCkge1xuICAgICAgcmV0dXJuIHJlZiA/IHRydWUgOiAhKGtleSBpbiB0YXJnZXQpO1xuICAgIH07XG4gIH0sXG5cbiAgLy8g5piv5ZCm5b+955WlbnVsbOWSjHVuZGVmaW5lZFxuICBpZ25vcmVOdWxsOiBmdW5jdGlvbihyZWYpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oa2V5LCBzcmMpIHtcbiAgICAgIHJldHVybiByZWYgPyBzcmNba2V5XSAhPSBudWxsIDogdHJ1ZVxuICAgIH07XG4gIH0sXG5cbiAgLy8g5piv5ZCm5LuF5omp5bGV5a+56LGh6Ieq6Lqr55qE5bGe5oCnXG4gIG9ubHlPd25Qcm9wZXJ0eTogZnVuY3Rpb24ocmVmKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKGtleSwgc3JjKSB7XG4gICAgICByZXR1cm4gcmVmID8gc3JjLmhhc093blByb3BlcnR5KGtleSkgOiB0cnVlXG4gICAgfTtcbiAgfSxcblxuICAvLyDmianlsZXnmb3lkI3ljZVcbiAgd2hpdGVMaXN0OiBmdW5jdGlvbihsaXN0KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKGtleSkge1xuICAgICAgcmV0dXJuIGxpc3QuaW5kZXhPZihrZXkpICE9PSAtMTtcbiAgICB9O1xuICB9LFxuXG4gIC8vIOaJqeWxlem7keWQjeWNlVxuICBibGFja0xpc3Q6IGZ1bmN0aW9uKGxpc3QpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oa2V5KSB7XG4gICAgICByZXR1cm4gbGlzdC5pbmRleE9mKGtleSkgPT09IC0xO1xuICAgIH07XG4gIH1cbn07XG5cbi8qKlxuICog5oqK5rqQ5a+56LGh55qE5bGe5oCn5omp5bGV5Yiw55uu5qCH5a+56LGh44CC5LiOZXh0ZW5k55u45q+U77yMY3VzdG9tRXh0ZW5k5o+Q5L6b5LqG5pu05aSa6YCJ6aG577yM5L2G5LiN5pSv5oyB5aSa5Liq5rqQ5a+56LGhXG4gKiBAbWV0aG9kIGN1c3RvbUV4dGVuZFxuICogQHBhcmFtIHtBbnl9IHRhcmdldCDnm67moIflr7nosaFcbiAqIEBwYXJhbSB7QW55fSBzcmMg5rqQ5a+56LGhXG4gKiBAcGFyYW0ge09iamVjdCp9IFtvcHRpb25zXSDpgInpoblcbiAqICAgQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5vdmVyd3JpdGU9dHJ1ZV0g5piv5ZCm6KaG55uW55uu5qCH5a+56LGh55qE5ZCM5ZCN5bGe5oCnXG4gKiAgIEBwYXJhbSB7QXJyYXk8U3RyaW5nPn0gW29wdGlvbnMud2hpdGVMaXN0XSDmianlsZXlsZ7mgKfnmb3lkI3ljZVcbiAqICAgQHBhcmFtIHtBcnJheTxTdHJpbmc+fSBbb3B0aW9ucy5ibGFja0xpc3RdIOaJqeWxleWxnuaAp+m7keWQjeWNlVxuICogICBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmlnbm9yZU51bGw9ZmFsc2VdIOaYr+WQpuW/veeVpea6kOWvueixoeS4reWAvOS4um51bGzmiJZ1bmRlZmluZWTnmoTlsZ7mgKdcbiAqICAgQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5vbmx5T3duUHJvcGVydHk9ZmFsc2VdIOaYr+WQpuS7heaJqeWxlea6kOWvueixoeiHqui6q+eahOWxnuaAp1xuICogQHBhcmFtIHtGdW5jdGlvbihrZXksIHNyYywgdGFyZ2V0KSp9IFtmaWx0ZXJdIOi/h+a7pOWHveaVsOOAgui/lOWbnmZhbHNl5pe26KGo56S66K+l5bGe5oCn5LiN6KKr5omp5bGVXG4gKiBAcmV0dXJuIHtBbnl9IOebruagh+WvueixoVxuICovXG5mdW5jdGlvbiBjdXN0b21FeHRlbmQodGFyZ2V0LCBzcmMpIHtcbiAgaWYgKHRhcmdldCA9PSBudWxsKSB7IHRocm93IG5ldyBFcnJvcigndGFyZ2V0IGNhbm5vdCBiZSBudWxsJyk7IH1cbiAgaWYgKHNyYyA9PSBudWxsKSB7IHJldHVybiB0YXJnZXQ7IH1cblxuICB2YXIgZmlsdGVycyA9IFsgXSwgaSwga2V5LCB0ZW1wO1xuICAvLyDnrKwx5Liq5Y+C5pWw5LmL5ZCO5Li66YCJ6aG55oiW6L+H5ruk5Ye95pWwXG4gIGZvciAoaSA9IDI7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICB0ZW1wID0gYXJndW1lbnRzW2ldO1xuICAgIHN3aXRjaCAodHlwZW9mIHRlbXApIHtcbiAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgIGZvciAoa2V5IGluIHRlbXApIHtcbiAgICAgICAgICBpZiAoIGV4dGVuZEZpbHRlcnMuaGFzT3duUHJvcGVydHkoa2V5KSApIHtcbiAgICAgICAgICAgIGZpbHRlcnMucHVzaCggZXh0ZW5kRmlsdGVyc1trZXldKHRlbXBba2V5XSkgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ2Z1bmN0aW9uJzpcbiAgICAgICAgZmlsdGVycy5wdXNoKHRlbXApO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICBmb3IgKGtleSBpbiBzcmMpIHtcbiAgICB0ZW1wID0gdHJ1ZTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgZmlsdGVycy5sZW5ndGg7IGkrKykge1xuICAgICAgLy8g6L+U5ZueZmFsc2XooajnpLrlsZ7mgKfkuI3ooqvmianlsZVcbiAgICAgIGlmIChmaWx0ZXJzW2ldLmNhbGwod2luZG93LCBrZXksIHNyYywgdGFyZ2V0KSA9PT0gZmFsc2UpIHtcbiAgICAgICAgdGVtcCA9IGZhbHNlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHRlbXApIHsgdGFyZ2V0W2tleV0gPSBzcmNba2V5XTsgfVxuICB9XG5cbiAgcmV0dXJuIHRhcmdldDtcbn1cblxuXG52YXIgdW5kZWZpbmVkO1xuLyoqXG4gKiDmo4Dmn6Xlj5jph4/nmoTlgLzmmK/lkKbkuLp1bmRlZmluZWRcbiAqIEBtZXRob2QgaXNVbmRlZmluZWRcbiAqIEBwYXJhbSB7QW55fSB2YWx1ZSDlvoXmtYvlj5jph49cbiAqIEByZXR1cm4ge0Jvb2xlYW59IOW+hea1i+WPmOmHj+aYr+WQpuS4unVuZGVmaW5lZFxuICovXG5mdW5jdGlvbiBpc1VuZGVmaW5lZCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgPT09IHVuZGVmaW5lZDsgfVxuXG4vLyDnlKjkuo7ln7rmnKznsbvlnovliKTmlq1cbnZhciB0b1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG5cbi8qKlxuICog5qOA5p+l5Y+Y6YeP5piv5ZCmRnVuY3Rpb27nsbvlnotcbiAqIEBtZXRob2QgaXNGdW5jdGlvblxuICogQHBhcmFtIHtBbnl9IHZhbHVlIOW+hea1i+WPmOmHj1xuICogQHJldHVybiB7Qm9vbGVhbn0g5b6F5rWL5Y+Y6YeP5piv5ZCmRnVuY3Rpb27nsbvlnotcbiAqL1xuZnVuY3Rpb24gaXNGdW5jdGlvbih2YWx1ZSkgeyByZXR1cm4gdG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT09ICdbb2JqZWN0IEZ1bmN0aW9uXSc7IH1cblxuLyoqXG4gKiDmo4Dmn6Xlj5jph4/mmK/lkKZEYXRl57G75Z6LXG4gKiBAbWV0aG9kIGlzRGF0ZVxuICogQHBhcmFtIHtBbnl9IHZhbHVlIOW+hea1i+WPmOmHj1xuICogQHJldHVybiB7Qm9vbGVhbn0g5b6F5rWL5Y+Y6YeP5piv5ZCmRGF0Zeexu+Wei1xuICovXG5mdW5jdGlvbiBpc0RhdGUodmFsdWUpIHsgcmV0dXJuIHRvU3RyaW5nLmNhbGwodmFsdWUpID09PSAnW29iamVjdCBEYXRlXSc7IH1cblxuLyoqXG4gKiDmo4Dmn6Xlj5jph4/mmK/lkKZPYmplY3TnsbvlnotcbiAqIEBtZXRob2QgaXNPYmplY3RcbiAqIEBwYXJhbSB7QW55fSB2YWx1ZSDlvoXmtYvlj5jph49cbiAqIEByZXR1cm4ge0Jvb2xlYW59IOW+hea1i+WPmOmHj+aYr+WQpk9iamVjdOexu+Wei1xuICovXG5mdW5jdGlvbiBpc09iamVjdCh2YWx1ZSkgeyByZXR1cm4gdG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT09ICdbb2JqZWN0IE9iamVjdF0nOyB9XG5cbi8qKlxuICog5qOA5p+l5Y+Y6YeP5piv5ZCmQXJyYXnnsbvlnotcbiAqIEBtZXRob2QgaXNBcnJheVxuICogQHBhcmFtIHtBbnl9IHZhbHVlIOW+hea1i+WPmOmHj1xuICogQHJldHVybiB7Qm9vbGVhbn0g5b6F5rWL5Y+Y6YeP5piv5ZCmQXJyYXnnsbvlnotcbiAqL1xudmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5IHx8XG4gIGZ1bmN0aW9uKHZhbHVlKSB7IHJldHVybiB0b1N0cmluZy5jYWxsKHZhbHVlKSA9PT0gJ1tvYmplY3QgQXJyYXldJzsgfTtcblxuLyoqXG4gKiDmo4Dmn6Xlr7nosaHmmK/lkKbnqbpPYmplY3RcbiAqIEBtZXRob2QgaXNFbXB0eU9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IG9iaiDlvoXmtYvlr7nosaFcbiAqIEByZXR1cm4ge0Jvb2xlYW59IOW+hea1i+WvueixoeaYr+WQpuepuk9iamVjdFxuICovXG5mdW5jdGlvbiBpc0VtcHR5T2JqZWN0KG9iaikge1xuICBpZiAob2JqICE9IG51bGwpIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgICBpZiAoIG9iai5oYXNPd25Qcm9wZXJ0eShrZXkpICkgeyByZXR1cm4gZmFsc2U7IH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5cblxuLyoqXG4gKiDlr7nmjIflrprlr7nosaHnmoTmr4/kuKrlhYPntKDmiafooYzmjIflrprlh73mlbBcbiAqIEBtZXRob2QgZWFjaFxuICogQHBhcmFtIHtPYmplY3R8QXJyYXl8QXJyYXlMaWtlfSBvYmog55uu5qCH5a+56LGhXG4gKiBAcGFyYW0ge0Z1bmN0aW9uKHZhbHVlLGtleSxvYmopfSBjYWxsYmFjayDmk43kvZzlh73mlbDvvIzkuIrkuIvmlofkuLrlvZPliY3lhYPntKDjgIJcbiAqICAg5b2T6L+U5Zue5YC85Li6ZmFsc2Xml7bvvIzpgY3ljobkuK3mlq1cbiAqIEByZXR1cm4ge09iamVjdHxBcnJheXxBcnJheUxpa2V9IOmBjeWOhuWvueixoVxuICovXG5mdW5jdGlvbiBlYWNoKG9iaiwgY2FsbGJhY2spIHtcbiAgaWYgKG9iaiAhPSBudWxsKSB7XG4gICAgdmFyIGksIGxlbiA9IG9iai5sZW5ndGg7XG4gICAgaWYgKCBsZW4gPT09IHVuZGVmaW5lZCB8fCBpc0Z1bmN0aW9uKG9iaikgKSB7XG4gICAgICBmb3IgKGkgaW4gb2JqKSB7XG4gICAgICAgIGlmICggb2JqLmhhc093blByb3BlcnR5KGkpICYmIGZhbHNlID09PSBjYWxsYmFjay5jYWxsKG9ialtpXSwgb2JqW2ldLCBpLCBvYmopICkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGkgPSAtMTtcbiAgICAgIHdoaWxlICgrK2kgPCBsZW4pIHtcbiAgICAgICAgaWYgKCBmYWxzZSA9PT0gY2FsbGJhY2suY2FsbChvYmpbaV0sIG9ialtpXSwgaSwgb2JqKSApIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBvYmo7XG59XG5cblxuLyoqXG4gKiDmiorlr7nosaHovazmjaLkuLrmlbDnu4RcbiAqIEBtZXRob2QgdG9BcnJheVxuICogQHBhcmFtIHtBcnJheXxBcnJheUxpa2V9IG9iaiDlr7nosaFcbiAqIEByZXR1cm4ge0FycmF5fSDmlbDnu4RcbiAqL1xuZnVuY3Rpb24gdG9BcnJheShvYmopIHtcbiAgdmFyIHJlc3VsdDtcbiAgdHJ5IHtcbiAgICByZXN1bHQgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChvYmopO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmVzdWx0ID0gWyBdO1xuICAgIHZhciBpID0gb2JqLmxlbmd0aDtcbiAgICB3aGlsZSAoaSkge1xuICAgICAgcmVzdWx0Wy0taV0gPSBvYmpbaV07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiDmiormlbDnu4TkuoznmoTlhYPntKDlkIjlubbliLDmlbDnu4TkuIBcbiAqIEBtZXRob2QgbWVyZ2VcbiAqIEBwYXJhbSB7QXJyYXl9IGZpcnN0IOaVsOe7hOS4gFxuICogQHBhcmFtIHtBcnJheX0gc2Vjb25kIOaVsOe7hOS6jFxuICogQHJldHVybiB7QXJyYXl9IOWQiOW5tuWQjueahOaVsOe7hOS4gFxuICovXG5mdW5jdGlvbiBtZXJnZShmaXJzdCwgc2Vjb25kKSB7XG4gIHZhciBsZW4gPSBzZWNvbmQubGVuZ3RoLCBqID0gMCwgaSA9IGZpcnN0Lmxlbmd0aDtcbiAgd2hpbGUgKGogPCBsZW4pIHtcbiAgICBmaXJzdFtpKytdID0gc2Vjb25kW2orK107XG4gIH1cbiAgZmlyc3QubGVuZ3RoID0gaTtcblxuICByZXR1cm4gZmlyc3Q7XG59XG5cblxuLyoqXG4gKiDov5Tlm57kuIDkuKrmlrDlh73mlbDvvIzkvb/nm67moIflh73mlbDlj6rmiafooYzkuIDmrKFcbiAqIEBtZXRob2Qgb25jZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4g55uu5qCH5Ye95pWwXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn0g5paw5Ye95pWwXG4gKi9cbmZ1bmN0aW9uIG9uY2UoZm4pIHtcbiAgdmFyIHJldHVyblZhbHVlO1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgaWYgKGZuKSB7XG4gICAgICByZXR1cm5WYWx1ZSA9IGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICBmbiA9IG51bGw7XG4gICAgfVxuICAgIHJldHVybiByZXR1cm5WYWx1ZTtcbiAgfTtcbn1cblxuXG4vKipcbiAqIOeUn+aIkOmVv+W6puS4ujE255qE6ZqP5py65a2X56ym5Liy77yI5LiN5L+d6K+B5LiA5a6a5LiN6YeN5aSN77yM5L2G5Z+65pys5LiK5LiN5Lya6YeN5aSN77yJXG4gKiBAbWV0aG9kIHJhbmRvbVN0clxuICogQHBhcmFtIHtTdHJpbmd9IFtwcmVmaXhdIOWJjee8gFxuICogQHJldHVybiB7U3RyaW5nfSDnlJ/miJDnmoTlrZfnrKbkuLJcbiAqL1xuZnVuY3Rpb24gcmFuZG9tU3RyKHByZWZpeCkge1xuICB2YXIgcmVzdWx0ID0gJyc7XG4gIGRvIHtcbiAgICByZXN1bHQgKz0gTWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc3Vic3RyKDIpO1xuICB9IHdoaWxlIChyZXN1bHQubGVuZ3RoIDwgMTApO1xuXG4gIHJlc3VsdCA9IHJlc3VsdC5zdWJzdHIoMCwgMTApICsgKCAnMDAwMDAnICsgTWF0aC5hYnMobmV3IERhdGUpICkuc2xpY2UoLTYpO1xuXG4gIGlmIChwcmVmaXgpIHsgcmVzdWx0ID0gcHJlZml4ICsgcmVzdWx0OyB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuXG4vKipcbiAqIOenu+mZpOWFqOWxgOWPmOmHj1xuICogQG1ldGhvZCBkZWxldGVHbG9iYWxWYXJcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIOWPmOmHj+WQjVxuICovXG5mdW5jdGlvbiBkZWxldGVHbG9iYWxWYXIobmFtZSkge1xuICB0cnkge1xuICAgIGRlbGV0ZSB3aW5kb3dbbmFtZV07XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICB3aW5kb3dbbmFtZV0gPSBudWxsO1xuICB9XG59XG5cblxuLyoqXG4gKiDliJvlu7rnsbtcbiAqIEBtZXRob2QgY3JlYXRlQ2xhc3NcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNvbnN0cnVjdG9yIOaehOmAoOWHveaVsFxuICogQHBhcmFtIHtPYmplY3R9IFttZXRob2RzXSDmlrnms5VcbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtQYXJlbnRdIOeItuexu1xuICogQHBhcmFtIHtGdW5jdGlvbihhcmdzKXxBcnJheX0gW3BhcmVudEFyZ3NdIOS8oOmAkue7meeItuexu+eahOWPguaVsO+8jOm7mOiupOS4juWtkOexu+aehOmAoOWHveaVsOWPguaVsOS4gOiHtFxuICogQHJldHVybiB7RnVuY3Rpb259IOexu1xuICovXG5mdW5jdGlvbiBjcmVhdGVDbGFzcyhjb25zdHJ1Y3RvciwgbWV0aG9kcywgUGFyZW50LCBwYXJlbnRBcmdzKSB7XG4gIHZhciAkQ2xhc3MgPSBQYXJlbnQgPyBmdW5jdGlvbigpIHtcbiAgICBQYXJlbnQuYXBwbHkoXG4gICAgICB0aGlzLFxuICAgICAgcGFyZW50QXJncyA/XG4gICAgICAgICh0eXBlb2YgcGFyZW50QXJncyA9PT0gJ2Z1bmN0aW9uJyA/IHBhcmVudEFyZ3MuYXBwbHkodGhpcywgYXJndW1lbnRzKSA6IHBhcmVudEFyZ3MpIDpcbiAgICAgICAgYXJndW1lbnRzXG4gICAgKTtcbiAgICBjb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9IDogZnVuY3Rpb24oKSB7IGNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH07XG5cbiAgaWYgKFBhcmVudCkge1xuICAgIHZhciAkUGFyZW50ID0gZnVuY3Rpb24oKSB7IH07XG4gICAgJFBhcmVudC5wcm90b3R5cGUgPSBQYXJlbnQucHJvdG90eXBlO1xuICAgICRDbGFzcy5wcm90b3R5cGUgPSBuZXcgJFBhcmVudCgpO1xuICAgICRDbGFzcy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSAkQ2xhc3M7XG4gIH1cblxuICBpZiAobWV0aG9kcykge1xuICAgIGZvciAodmFyIG0gaW4gbWV0aG9kcykge1xuICAgICAgaWYgKCBtZXRob2RzLmhhc093blByb3BlcnR5KG0pICkge1xuICAgICAgICAkQ2xhc3MucHJvdG90eXBlW21dID0gbWV0aG9kc1ttXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gJENsYXNzO1xufVxuXG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgZXh0ZW5kOiBleHRlbmQsXG4gIGN1c3RvbUV4dGVuZDogY3VzdG9tRXh0ZW5kLFxuICBpc1VuZGVmaW5lZDogaXNVbmRlZmluZWQsXG4gIGlzRnVuY3Rpb246IGlzRnVuY3Rpb24sXG4gIGlzRGF0ZTogaXNEYXRlLFxuICBpc09iamVjdDogaXNPYmplY3QsXG4gIGlzQXJyYXk6IGlzQXJyYXksXG4gIGlzRW1wdHlPYmplY3Q6IGlzRW1wdHlPYmplY3QsXG4gIGVhY2g6IGVhY2gsXG4gIHRvQXJyYXk6IHRvQXJyYXksXG4gIG1lcmdlOiBtZXJnZSxcbiAgb25jZTogb25jZSxcbiAgcmFuZG9tU3RyOiByYW5kb21TdHIsXG4gIGRlbGV0ZUdsb2JhbFZhcjogZGVsZXRlR2xvYmFsVmFyLFxuICBjcmVhdGVDbGFzczogY3JlYXRlQ2xhc3Ncbn07XG5cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL0U6L2dpdF9wcm8vZXhwcmVzcy13ZWJwYWNrLXZ1ZS9zcmMvdXRpbC9iYXNlLmpzIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ },
/* 20 */
/***/ function(module, exports) {

	eval("'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\n * 本模块根据UserAgent检测当前设备、系统、浏览器、排版引擎\n * @module uadetector/1.0.x/\n * @category Utility\n */\n\nvar ua = window.navigator.userAgent;\n\n// 检测结果\nvar result = {\n  device: {},\n  os: {},\n  layoutEngine: {},\n  browser: {},\n  feature: {\n    touch: 'ontouchstart' in document || !!(window.PointerEvent || window.MSPointerEvent)\n  }\n};\n\n// 执行规则匹配\nfunction execRules(rules, type, breakWhenMatch) {\n  var i, match;\n  for (i = 0; i < rules.length; i++) {\n    match = ua.match(rules[i][1]);\n    if (match) {\n      result[type][rules[i][0]] = true;\n      result[type].version = match[1] || '';\n      if (breakWhenMatch) {\n        break;\n      }\n    }\n  }\n\n  return match != null;\n}\n\n// 设备识别\nexecRules([['ipad', /iPad(?:.*OS\\s([\\d_]+))?/], ['ipod', /iPod(?:.*OS\\s([\\d_]+))?/], ['iphone', /iPhone(?:\\sOS\\s([\\d_]+))?/], ['mac', /Macintosh/], ['kindle', /Kindle/], ['playbook', /PlayBook/], ['blackberry', /BlackBerry/], ['bb10', /BB10/], ['nokia', /nokia/i]], 'device', true);\n\n// 系统识别\nexecRules([['windowsphone', /Windows\\sPhone\\s([\\d.]+)/], ['windowsmobile', /Windows\\sMobile/], ['windowsce', /Windows\\sCE/], ['windows', /Windows\\sNT\\s([\\d.]+)/], ['macosx', /Mac\\sOS\\sX\\s([\\d_.]+)/], ['android', /Android;?[\\s\\/]+([\\d.]+)?/], ['symbian', /Symbian(?:OS)?\\/([\\d.]+)/], ['linux', /Linux/]], 'os', true);\n\n// 浏览器排版引擎识别\nexecRules([['trident', /Trident\\/([\\d.]+)/], ['webkit', /Web[kK]it[\\/]?([\\d.]+)/], ['gecko', /Gecko\\/([\\d.]+)/], ['presto', /Presto\\/([\\d.]+)/]], 'layoutEngine', true);\n\n// 浏览器识别\nexecRules([['ie', /MSIE\\s([\\d.]+)/], ['ie', /Trident\\/.*;\\srv:([\\d.]+)/], ['firefox', /Firefox\\/([\\d.]+)/], ['operamini', /Opera\\sMini\\/([\\d.]+)/], ['opera', /Opera\\/.*Version\\/([\\d.]+)/], ['opera', /Opera\\/([\\d.]+)/], ['opera', /OPR\\/([\\d.]+)/], ['chrome', /Chrome\\/([\\d.]+)/], ['chrome', /CriOS\\/([\\d.]+)/], ['safari', /Version\\/([\\d.]+).*Safari/]], 'browser', true);\n\nvar device = result.device,\n    os = result.os,\n    browser = result.browser;\n\n// 某些版本号的数字用“-”分隔，替换成“.”\nif (device.iphone || device.ipod || device.ipad) {\n  os.ios = true;\n  os.version = device.version.replace(/_/g, '.');\n}\nif (os.macosx && os.version) {\n  os.version = os.version.replace(/_/g, '.');\n}\ndelete device.version;\n\ndevice.tablet = !os.windows && !!(device.ipad || device.playbook || os.android && !ua.match(/Mobile/) || browser.firefox && /Tablet/.test(ua) || browser.ie && !/Phone/.test(ua) && /Touch/.test(ua));\ndevice.phone = !os.windows && !!(!device.tablet && (os.android || device.iphone || device.ipod || device.blackberry || device.bb10 || os.windowsce || os.windowsmobile || os.windowsphone || browser.chrome && /Android/.test(ua) || browser.chrome && /CriOS\\/[\\d.]+/.test(ua) || browser.firefox && /Mobile/.test(ua) || browser.ie && /Touch/.test(ua)));\n\n// 修正对诺基亚或塞班设备的判断\nif (!device.tablet && !device.phone) {\n  if (device.nokia || os.symbian || ua.indexOf('MIDP') !== -1) {\n    device.phone = true;\n  }\n}\n\ndevice.mobile = !os.windows && (device.tablet || device.phone || /mobile/i.test(ua) || /tablet/i.test(ua) || /phone/i.test(ua));\n\ndevice.pc = !device.mobile;\n\nexports.default = {\n  /**\n   * 检查Useragent是否符合特定条件\n   * @method is\n   * @param {Function|String|RegExp} tester 为函数时，以函数返回值作为结果；\n   *   为字符串时，返回Useragent中是否包含该字符串；\n   *   为正则表达式时，返回正则匹配结果\n   * @return {Boolean} Useragent是否符合特定条件\n   */\n  is: function is(tester) {\n    if (typeof tester === 'function') {\n      return !!tester(ua);\n    } else if (typeof tester === 'string') {\n      return ua.indexOf(tester) !== -1;\n    } else if (tester instanceof RegExp) {\n      return tester.test(ua);\n    }\n  },\n\n  /**\n   * 检测是否特定设备\n   * @method isDevice\n   * @param {String} name 设备名，有效值包括：\n   *   pc（个人电脑）；\n   *   tablet（平板电脑）；\n   *   phone（手机）；\n   *   mobile（移动设备，手机或平板）；\n   *   mac（苹果电脑）；\n   *   iphone；\n   *   ipod；\n   *   ipad；\n   *   kindle（Kindle Fire）；\n   *   blackberry（黑莓）；\n   *   bb10（黑莓BB10）；\n   *   playbook（黑莓PlayBook）。\n   * @return {Boolean} 是否该设备\n   */\n  isDevice: function isDevice(name) {\n    return !!result.device[name];\n  },\n\n  /**\n   * 检测是否特定操作系统\n   * @method isOS\n   * @param {String} name 系统名，有效值包括：\n   *   ios；\n   *   android；\n   *   windows（PC）；\n   *   windowsce；\n   *   windowsmobile；\n   *   windowsphone；\n   *   macosx；\n   *   linux；\n   *   symbian。\n   * @return {Boolean} 是否该系统\n   */\n  isOS: function isOS(name) {\n    return !!result.os[name];\n  },\n\n  /**\n   * 检测是否特定浏览器\n   * @method isBrowser\n   * @param {String} name 浏览器名，有效值包括：\n   *   ie；\n   *   chrome；\n   *   firefox；\n   *   safari；\n   *   opera；\n   *   operamini。\n   * @return {Boolean} 是否该浏览器\n   */\n  isBrowser: function isBrowser(name) {\n    return !!result.browser[name];\n  },\n\n  /**\n   * 检测是否特定浏览器排版引擎\n   * @method isLayoutEngine\n   * @param {String} name 排版引擎名，有效值包括：\n   *   webkit；\n   *   trident；\n   *   gecko；\n   *   presto。\n   * @return {Boolean} 是否该浏览器\n   */\n  isLayoutEngine: function isLayoutEngine(name) {\n    return !!result.layoutEngine[name];\n  },\n\n  /**\n   * 获取操作系统（核心）版本号\n   * @method osVer\n   * @return {String} 版本号\n   */\n  osVer: function osVer() {\n    return result.os.version;\n  },\n\n  /**\n   * 获取浏览器版本号\n   * @method browserVer\n   * @return {String} 版本号\n   */\n  browserVer: function browserVer() {\n    return result.browser.version;\n  },\n\n  /**\n   * 获取浏览器排版引擎版本号\n   * @method layoutEngineVer\n   * @return {String} 浏览器排版引擎版本号\n   */\n  layoutEngineVer: function layoutEngineVer() {\n    return result.layoutEngine.version;\n  },\n\n  /**\n   * 检测是否支持特定特征\n   * @method hasFeature\n   * @param {String} name 特征名，有效值包括：\n   *   touch（是否支持触屏事件）。\n   * @return {Boolean} 是否支持该特征\n   */\n  hasFeature: function hasFeature(name) {\n    return !!result.feature[name];\n  },\n\n  /**\n   * 输出所有检测到的数据为HTML\n   * @method print\n   * @param {Element|NodeList} wrapper 目标容器\n   * @return {String} HTML字符串\n   */\n  print: function print(wrapper) {\n    var html = ua,\n        i;\n\n    for (var type in result) {\n      html += '<h1>' + type + '</h1>';\n      for (var i in result[type]) {\n        html += '<p>' + i + ': ' + result[type][i] + '</p>';\n      }\n    }\n\n    if (wrapper) {\n      if ('innerHTML' in wrapper) {\n        wrapper.innerHTML = html;\n      } else if (typeof wrapper.html === 'function') {\n        wrapper.html(html);\n      }\n    }\n\n    return html;\n  },\n\n  /**\n   * 在控制台输出所有检测到的数据\n   * @method info\n   */\n  info: function info() {\n    if (window.console) {\n      console.dir(result);\n    }\n  }\n};//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9FOi9naXRfcHJvL2V4cHJlc3Mtd2VicGFjay12dWUvc3JjL3V0aWwvdWFkZXRlY3Rvci5qcz9jMDJjIl0sIm5hbWVzIjpbInVhIiwid2luZG93IiwibmF2aWdhdG9yIiwidXNlckFnZW50IiwicmVzdWx0IiwiZGV2aWNlIiwib3MiLCJsYXlvdXRFbmdpbmUiLCJicm93c2VyIiwiZmVhdHVyZSIsInRvdWNoIiwiZG9jdW1lbnQiLCJQb2ludGVyRXZlbnQiLCJNU1BvaW50ZXJFdmVudCIsImV4ZWNSdWxlcyIsInJ1bGVzIiwidHlwZSIsImJyZWFrV2hlbk1hdGNoIiwiaSIsIm1hdGNoIiwibGVuZ3RoIiwidmVyc2lvbiIsImlwaG9uZSIsImlwb2QiLCJpcGFkIiwiaW9zIiwicmVwbGFjZSIsIm1hY29zeCIsInRhYmxldCIsIndpbmRvd3MiLCJwbGF5Ym9vayIsImFuZHJvaWQiLCJmaXJlZm94IiwidGVzdCIsImllIiwicGhvbmUiLCJibGFja2JlcnJ5IiwiYmIxMCIsIndpbmRvd3NjZSIsIndpbmRvd3Ntb2JpbGUiLCJ3aW5kb3dzcGhvbmUiLCJjaHJvbWUiLCJub2tpYSIsInN5bWJpYW4iLCJpbmRleE9mIiwibW9iaWxlIiwicGMiLCJpcyIsInRlc3RlciIsIlJlZ0V4cCIsImlzRGV2aWNlIiwibmFtZSIsImlzT1MiLCJpc0Jyb3dzZXIiLCJpc0xheW91dEVuZ2luZSIsIm9zVmVyIiwiYnJvd3NlclZlciIsImxheW91dEVuZ2luZVZlciIsImhhc0ZlYXR1cmUiLCJwcmludCIsIndyYXBwZXIiLCJodG1sIiwiaW5uZXJIVE1MIiwiaW5mbyIsImNvbnNvbGUiLCJkaXIiXSwibWFwcGluZ3MiOiI7Ozs7O0FBQUE7Ozs7OztBQU1BLElBQUlBLEtBQUtDLE9BQU9DLFNBQVAsQ0FBaUJDLFNBQTFCOztBQUdBO0FBQ0EsSUFBSUMsU0FBUztBQUNYQyxVQUFRLEVBREc7QUFFWEMsTUFBSSxFQUZPO0FBR1hDLGdCQUFjLEVBSEg7QUFJWEMsV0FB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ZWtCLENBQWY7O0FBRUEsU0FBSyxJQUFJRixJQUFULElBQWlCWixNQUFqQixFQUF5QjtBQUN2QnlELGNBQVEsU0FBUzdDLElBQVQsR0FBZ0IsT0FBeEI7QUFDQSxXQUFLLElBQUlFLENBQVQsSUFBY2QsT0FBT1ksSUFBUCxDQUFkLEVBQTRCO0FBQzFCNkMsZ0JBQVEsUUFBUTNDLENBQVIsR0FBWSxJQUFaLEdBQW1CZCxPQUFPWSxJQUFQLEVBQWFFLENBQWIsQ0FBbkIsR0FBcUMsTUFBN0M7QUFDRDtBQUNGOztBQUVELFFBQUkwQyxPQUFKLEVBQWE7QUFDWCxVQUFJLGVBQWVBLE9BQW5CLEVBQTRCO0FBQzFCQSxnQkFBUUUsU0FBUixHQUFvQkQsSUFBcEI7QUFDRCxPQUZELE1BRU8sSUFBSSxPQUFPRCxRQUFRQyxJQUFmLEtBQXdCLFVBQTVCLEVBQXdDO0FBQzdDRCxnQkFBUUMsSUFBUixDQUFhQSxJQUFiO0FBQ0Q7QUFDRjs7QUFFRCxXQUFPQSxJQUFQO0FBQ0QsR0F6SVk7O0FBMkliOzs7O0FBSUFFLFFBQU0sZ0JBQVc7QUFDZixRQUFJOUQsT0FBTytELE9BQVgsRUFBb0I7QUFBRUEsY0FBUUMsR0FBUixDQUFZN0QsTUFBWjtBQUFzQjtBQUM3QztBQWpKWSxDIiwiZmlsZSI6IjIwLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiDmnKzmqKHlnZfmoLnmja5Vc2VyQWdlbnTmo4DmtYvlvZPliY3orr7lpIfjgIHns7vnu5/jgIHmtY/op4jlmajjgIHmjpLniYjlvJXmk45cbiAqIEBtb2R1bGUgdWFkZXRlY3Rvci8xLjAueC9cbiAqIEBjYXRlZ29yeSBVdGlsaXR5XG4gKi9cblxudmFyIHVhID0gd2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnQ7XG5cblxuLy8g5qOA5rWL57uT5p6cXG52YXIgcmVzdWx0ID0ge1xuICBkZXZpY2U6IHsgfSxcbiAgb3M6IHsgfSxcbiAgbGF5b3V0RW5naW5lOiB7IH0sXG4gIGJyb3dzZXI6IHsgfSxcbiAgZmVhdHVyZToge1xuICAgIHRvdWNoOiAoJ29udG91Y2hzdGFydCcgaW4gZG9jdW1lbnQpIHx8ICEhKHdpbmRvdy5Qb2ludGVyRXZlbnQgfHwgd2luZG93Lk1TUG9pbnRlckV2ZW50KVxuICB9XG59O1xuXG4vLyDmiafooYzop4TliJnljLnphY1cbmZ1bmN0aW9uIGV4ZWNSdWxlcyhydWxlcywgdHlwZSwgYnJlYWtXaGVuTWF0Y2gpIHtcbiAgdmFyIGksIG1hdGNoO1xuICBmb3IgKGkgPSAwOyBpIDwgcnVsZXMubGVuZ3RoOyBpKyspIHtcbiAgICBtYXRjaCA9IHVhLm1hdGNoKHJ1bGVzW2ldWzFdKTtcbiAgICBpZiAobWF0Y2gpIHtcbiAgICAgIHJlc3VsdFt0eXBlXVtydWxlc1tpXVswXV0gPSB0cnVlO1xuICAgICAgcmVzdWx0W3R5cGVdLnZlcnNpb24gPSBtYXRjaFsxXSB8fCAnJztcbiAgICAgIGlmIChicmVha1doZW5NYXRjaCkgeyBicmVhazsgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBtYXRjaCAhPSBudWxsO1xufVxuXG5cbi8vIOiuvuWkh+ivhuWIq1xuZXhlY1J1bGVzKFtcbiAgWydpcGFkJywgL2lQYWQoPzouKk9TXFxzKFtcXGRfXSspKT8vXSxcbiAgWydpcG9kJywgL2lQb2QoPzouKk9TXFxzKFtcXGRfXSspKT8vXSxcbiAgWydpcGhvbmUnLCAvaVBob25lKD86XFxzT1NcXHMoW1xcZF9dKykpPy9dLFxuICBbJ21hYycsIC9NYWNpbnRvc2gvXSxcbiAgWydraW5kbGUnLCAvS2luZGxlL10sXG4gIFsncGxheWJvb2snLCAvUGxheUJvb2svXSxcbiAgWydibGFja2JlcnJ5JywgL0JsYWNrQmVycnkvXSxcbiAgWydiYjEwJywgL0JCMTAvXSxcbiAgWydub2tpYScsIC9ub2tpYS9pXVxuXSwgJ2RldmljZScsIHRydWUpO1xuXG4vLyDns7vnu5/or4bliKtcbmV4ZWNSdWxlcyhbXG4gIFsnd2luZG93c3Bob25lJywgL1dpbmRvd3NcXHNQaG9uZVxccyhbXFxkLl0rKS9dLFxuICBbJ3dpbmRvd3Ntb2JpbGUnLCAvV2luZG93c1xcc01vYmlsZS9dLFxuICBbJ3dpbmRvd3NjZScsIC9XaW5kb3dzXFxzQ0UvXSxcbiAgWyd3aW5kb3dzJywgL1dpbmRvd3NcXHNOVFxccyhbXFxkLl0rKS9dLFxuICBbJ21hY29zeCcsIC9NYWNcXHNPU1xcc1hcXHMoW1xcZF8uXSspL10sXG4gIFsnYW5kcm9pZCcsIC9BbmRyb2lkOz9bXFxzXFwvXSsoW1xcZC5dKyk/L10sXG4gIFsnc3ltYmlhbicsIC9TeW1iaWFuKD86T1MpP1xcLyhbXFxkLl0rKS9dLFxuICBbJ2xpbnV4JywgL0xpbnV4L11cbl0sICdvcycsIHRydWUpO1xuXG4vLyDmtY/op4jlmajmjpLniYjlvJXmk47or4bliKtcbmV4ZWNSdWxlcyhbXG4gIFsndHJpZGVudCcsIC9UcmlkZW50XFwvKFtcXGQuXSspL10sXG4gIFsnd2Via2l0JywgL1dlYltrS11pdFtcXC9dPyhbXFxkLl0rKS9dLFxuICBbJ2dlY2tvJywgL0dlY2tvXFwvKFtcXGQuXSspL10sXG4gIFsncHJlc3RvJywgL1ByZXN0b1xcLyhbXFxkLl0rKS9dXG5dLCAnbGF5b3V0RW5naW5lJywgdHJ1ZSk7XG5cbi8vIOa1j+iniOWZqOivhuWIq1xuZXhlY1J1bGVzKFtcbiAgWydpZScsIC9NU0lFXFxzKFtcXGQuXSspL10sXG4gIFsnaWUnLCAvVHJpZGVudFxcLy4qO1xcc3J2OihbXFxkLl0rKS9dLFxuICBbJ2ZpcmVmb3gnLCAvRmlyZWZveFxcLyhbXFxkLl0rKS9dLFxuICBbJ29wZXJhbWluaScsIC9PcGVyYVxcc01pbmlcXC8oW1xcZC5dKykvXSxcbiAgWydvcGVyYScsIC9PcGVyYVxcLy4qVmVyc2lvblxcLyhbXFxkLl0rKS9dLFxuICBbJ29wZXJhJywgL09wZXJhXFwvKFtcXGQuXSspL10sXG4gIFsnb3BlcmEnLCAvT1BSXFwvKFtcXGQuXSspL10sXG4gIFsnY2hyb21lJywgL0Nocm9tZVxcLyhbXFxkLl0rKS9dLFxuICBbJ2Nocm9tZScsIC9DcmlPU1xcLyhbXFxkLl0rKS9dLFxuICBbJ3NhZmFyaScsIC9WZXJzaW9uXFwvKFtcXGQuXSspLipTYWZhcmkvXVxuXSwgJ2Jyb3dzZXInLCB0cnVlKTtcblxuXG52YXIgZGV2aWNlID0gcmVzdWx0LmRldmljZSwgb3MgPSByZXN1bHQub3MsIGJyb3dzZXIgPSByZXN1bHQuYnJvd3NlcjtcblxuLy8g5p+Q5Lqb54mI5pys5Y+355qE5pWw5a2X55So4oCcLeKAneWIhumalO+8jOabv+aNouaIkOKAnC7igJ1cbmlmIChkZXZpY2UuaXBob25lIHx8IGRldmljZS5pcG9kIHx8IGRldmljZS5pcGFkKSB7XG4gIG9zLmlvcyA9IHRydWU7XG4gIG9zLnZlcnNpb24gPSBkZXZpY2UudmVyc2lvbi5yZXBsYWNlKC9fL2csICcuJyk7XG59XG5pZiAob3MubWFjb3N4ICYmIG9zLnZlcnNpb24pIHsgb3MudmVyc2lvbiA9IG9zLnZlcnNpb24ucmVwbGFjZSgvXy9nLCAnLicpOyB9XG5kZWxldGUgZGV2aWNlLnZlcnNpb247XG5cblxuZGV2aWNlLnRhYmxldCA9ICFvcy53aW5kb3dzICYmICEhKFxuZGV2aWNlLmlwYWQgfHwgZGV2aWNlLnBsYXlib29rIHx8ICggb3MuYW5kcm9pZCAmJiAhdWEubWF0Y2goL01vYmlsZS8pICkgfHxcbiggYnJvd3Nlci5maXJlZm94ICYmIC9UYWJsZXQvLnRlc3QodWEpICkgfHxcbiggYnJvd3Nlci5pZSAmJiAhL1Bob25lLy50ZXN0KHVhKSAmJiAvVG91Y2gvLnRlc3QodWEpIClcbik7XG5kZXZpY2UucGhvbmUgPSAhb3Mud2luZG93cyAmJiAhIShcbiFkZXZpY2UudGFibGV0ICYmIChcbm9zLmFuZHJvaWQgfHwgZGV2aWNlLmlwaG9uZSB8fCBkZXZpY2UuaXBvZCB8fFxuZGV2aWNlLmJsYWNrYmVycnkgfHwgZGV2aWNlLmJiMTAgfHxcbm9zLndpbmRvd3NjZSB8fCBvcy53aW5kb3dzbW9iaWxlIHx8IG9zLndpbmRvd3NwaG9uZSB8fFxuKCBicm93c2VyLmNocm9tZSAmJiAvQW5kcm9pZC8udGVzdCh1YSkgKSB8fCAoIGJyb3dzZXIuY2hyb21lICYmIC9DcmlPU1xcL1tcXGQuXSsvLnRlc3QodWEpICkgfHxcbiggYnJvd3Nlci5maXJlZm94ICYmIC9Nb2JpbGUvLnRlc3QodWEpICkgfHwgKCBicm93c2VyLmllICYmIC9Ub3VjaC8udGVzdCh1YSkgKVxuKVxuKTtcblxuLy8g5L+u5q2j5a+56K+65Z+65Lqa5oiW5aGe54+t6K6+5aSH55qE5Yik5patXG5pZiAoIWRldmljZS50YWJsZXQgJiYgIWRldmljZS5waG9uZSkge1xuICBpZiAoZGV2aWNlLm5va2lhIHx8IG9zLnN5bWJpYW4gfHwgdWEuaW5kZXhPZignTUlEUCcpICE9PSAtMSkgeyBkZXZpY2UucGhvbmUgPSB0cnVlOyB9XG59XG5cbmRldmljZS5tb2JpbGUgPSAhb3Mud2luZG93cyAmJiAoIGRldmljZS50YWJsZXQgfHwgZGV2aWNlLnBob25lIHx8XG4vbW9iaWxlL2kudGVzdCh1YSkgfHwgL3RhYmxldC9pLnRlc3QodWEpIHx8IC9waG9uZS9pLnRlc3QodWEpICk7XG5cbmRldmljZS5wYyA9ICFkZXZpY2UubW9iaWxlO1xuXG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgLyoqXG4gICAqIOajgOafpVVzZXJhZ2VudOaYr+WQpuespuWQiOeJueWumuadoeS7tlxuICAgKiBAbWV0aG9kIGlzXG4gICAqIEBwYXJhbSB7RnVuY3Rpb258U3RyaW5nfFJlZ0V4cH0gdGVzdGVyIOS4uuWHveaVsOaXtu+8jOS7peWHveaVsOi/lOWbnuWAvOS9nOS4uue7k+aenO+8m1xuICAgKiAgIOS4uuWtl+espuS4suaXtu+8jOi/lOWbnlVzZXJhZ2VudOS4reaYr+WQpuWMheWQq+ivpeWtl+espuS4su+8m1xuICAgKiAgIOS4uuato+WImeihqOi+vuW8j+aXtu+8jOi/lOWbnuato+WImeWMuemFjee7k+aenFxuICAgKiBAcmV0dXJuIHtCb29sZWFufSBVc2VyYWdlbnTmmK/lkKbnrKblkIjnibnlrprmnaHku7ZcbiAgICovXG4gIGlzOiBmdW5jdGlvbih0ZXN0ZXIpIHtcbiAgICBpZiAodHlwZW9mIHRlc3RlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuICEhdGVzdGVyKHVhKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiB0ZXN0ZXIgPT09ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm4gdWEuaW5kZXhPZih0ZXN0ZXIpICE9PSAtMTtcbiAgICB9IGVsc2UgaWYgKHRlc3RlciBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgICAgcmV0dXJuIHRlc3Rlci50ZXN0KHVhKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIOajgOa1i+aYr+WQpueJueWumuiuvuWkh1xuICAgKiBAbWV0aG9kIGlzRGV2aWNlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIOiuvuWkh+WQje+8jOacieaViOWAvOWMheaLrO+8mlxuICAgKiAgIHBj77yI5Liq5Lq655S16ISR77yJ77ybXG4gICAqICAgdGFibGV077yI5bmz5p2/55S16ISR77yJ77ybXG4gICAqICAgcGhvbmXvvIjmiYvmnLrvvInvvJtcbiAgICogICBtb2JpbGXvvIjnp7vliqjorr7lpIfvvIzmiYvmnLrmiJblubPmnb/vvInvvJtcbiAgICogICBtYWPvvIjoi7nmnpznlLXohJHvvInvvJtcbiAgICogICBpcGhvbmXvvJtcbiAgICogICBpcG9k77ybXG4gICAqICAgaXBhZO+8m1xuICAgKiAgIGtpbmRsZe+8iEtpbmRsZSBGaXJl77yJ77ybXG4gICAqICAgYmxhY2tiZXJyee+8iOm7keiOk++8ie+8m1xuICAgKiAgIGJiMTDvvIjpu5HojpNCQjEw77yJ77ybXG4gICAqICAgcGxheWJvb2vvvIjpu5HojpNQbGF5Qm9va++8ieOAglxuICAgKiBAcmV0dXJuIHtCb29sZWFufSDmmK/lkKbor6Xorr7lpIdcbiAgICovXG4gIGlzRGV2aWNlOiBmdW5jdGlvbihuYW1lKSB7IHJldHVybiAhIXJlc3VsdC5kZXZpY2VbbmFtZV07IH0sXG5cbiAgLyoqXG4gICAqIOajgOa1i+aYr+WQpueJueWumuaTjeS9nOezu+e7n1xuICAgKiBAbWV0aG9kIGlzT1NcbiAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWUg57O757uf5ZCN77yM5pyJ5pWI5YC85YyF5ous77yaXG4gICAqICAgaW9z77ybXG4gICAqICAgYW5kcm9pZO+8m1xuICAgKiAgIHdpbmRvd3PvvIhQQ++8ie+8m1xuICAgKiAgIHdpbmRvd3NjZe+8m1xuICAgKiAgIHdpbmRvd3Ntb2JpbGXvvJtcbiAgICogICB3aW5kb3dzcGhvbmXvvJtcbiAgICogICBtYWNvc3jvvJtcbiAgICogICBsaW51eO+8m1xuICAgKiAgIHN5bWJpYW7jgIJcbiAgICogQHJldHVybiB7Qm9vbGVhbn0g5piv5ZCm6K+l57O757ufXG4gICAqL1xuICBpc09TOiBmdW5jdGlvbihuYW1lKSB7IHJldHVybiAhIXJlc3VsdC5vc1tuYW1lXTsgfSxcblxuICAvKipcbiAgICog5qOA5rWL5piv5ZCm54m55a6a5rWP6KeI5ZmoXG4gICAqIEBtZXRob2QgaXNCcm93c2VyXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIOa1j+iniOWZqOWQje+8jOacieaViOWAvOWMheaLrO+8mlxuICAgKiAgIGll77ybXG4gICAqICAgY2hyb21l77ybXG4gICAqICAgZmlyZWZveO+8m1xuICAgKiAgIHNhZmFyae+8m1xuICAgKiAgIG9wZXJh77ybXG4gICAqICAgb3BlcmFtaW5p44CCXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59IOaYr+WQpuivpea1j+iniOWZqFxuICAgKi9cbiAgaXNCcm93c2VyOiBmdW5jdGlvbihuYW1lKSB7IHJldHVybiAhIXJlc3VsdC5icm93c2VyW25hbWVdOyB9LFxuXG4gIC8qKlxuICAgKiDmo4DmtYvmmK/lkKbnibnlrprmtY/op4jlmajmjpLniYjlvJXmk45cbiAgICogQG1ldGhvZCBpc0xheW91dEVuZ2luZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSDmjpLniYjlvJXmk47lkI3vvIzmnInmlYjlgLzljIXmi6zvvJpcbiAgICogICB3ZWJraXTvvJtcbiAgICogICB0cmlkZW5077ybXG4gICAqICAgZ2Vja2/vvJtcbiAgICogICBwcmVzdG/jgIJcbiAgICogQHJldHVybiB7Qm9vbGVhbn0g5piv5ZCm6K+l5rWP6KeI5ZmoXG4gICAqL1xuICBpc0xheW91dEVuZ2luZTogZnVuY3Rpb24obmFtZSkgeyByZXR1cm4gISFyZXN1bHQubGF5b3V0RW5naW5lW25hbWVdOyB9LFxuXG4gIC8qKlxuICAgKiDojrflj5bmk43kvZzns7vnu5/vvIjmoLjlv4PvvInniYjmnKzlj7dcbiAgICogQG1ldGhvZCBvc1ZlclxuICAgKiBAcmV0dXJuIHtTdHJpbmd9IOeJiOacrOWPt1xuICAgKi9cbiAgb3NWZXI6IGZ1bmN0aW9uKCkgeyByZXR1cm4gcmVzdWx0Lm9zLnZlcnNpb247IH0sXG5cbiAgLyoqXG4gICAqIOiOt+WPlua1j+iniOWZqOeJiOacrOWPt1xuICAgKiBAbWV0aG9kIGJyb3dzZXJWZXJcbiAgICogQHJldHVybiB7U3RyaW5nfSDniYjmnKzlj7dcbiAgICovXG4gIGJyb3dzZXJWZXI6IGZ1bmN0aW9uKCkgeyByZXR1cm4gcmVzdWx0LmJyb3dzZXIudmVyc2lvbjsgfSxcblxuICAvKipcbiAgICog6I635Y+W5rWP6KeI5Zmo5o6S54mI5byV5pOO54mI5pys5Y+3XG4gICAqIEBtZXRob2QgbGF5b3V0RW5naW5lVmVyXG4gICAqIEByZXR1cm4ge1N0cmluZ30g5rWP6KeI5Zmo5o6S54mI5byV5pOO54mI5pys5Y+3XG4gICAqL1xuICBsYXlvdXRFbmdpbmVWZXI6IGZ1bmN0aW9uKCkgeyByZXR1cm4gcmVzdWx0LmxheW91dEVuZ2luZS52ZXJzaW9uOyB9LFxuXG4gIC8qKlxuICAgKiDmo4DmtYvmmK/lkKbmlK/mjIHnibnlrprnibnlvoFcbiAgICogQG1ldGhvZCBoYXNGZWF0dXJlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIOeJueW+geWQje+8jOacieaViOWAvOWMheaLrO+8mlxuICAgKiAgIHRvdWNo77yI5piv5ZCm5pSv5oyB6Kem5bGP5LqL5Lu277yJ44CCXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59IOaYr+WQpuaUr+aMgeivpeeJueW+gVxuICAgKi9cbiAgaGFzRmVhdHVyZTogZnVuY3Rpb24obmFtZSkgeyByZXR1cm4gISFyZXN1bHQuZmVhdHVyZVtuYW1lXTsgfSxcblxuICAvKipcbiAgICog6L6T5Ye65omA5pyJ5qOA5rWL5Yiw55qE5pWw5o2u5Li6SFRNTFxuICAgKiBAbWV0aG9kIHByaW50XG4gICAqIEBwYXJhbSB7RWxlbWVudHxOb2RlTGlzdH0gd3JhcHBlciDnm67moIflrrnlmahcbiAgICogQHJldHVybiB7U3RyaW5nfSBIVE1M5a2X56ym5LiyXG4gICAqL1xuICBwcmludDogZnVuY3Rpb24od3JhcHBlcikge1xuICAgIHZhciBodG1sID0gdWEsIGk7XG5cbiAgICBmb3IgKHZhciB0eXBlIGluIHJlc3VsdCkge1xuICAgICAgaHRtbCArPSAnPGgxPicgKyB0eXBlICsgJzwvaDE+JztcbiAgICAgIGZvciAodmFyIGkgaW4gcmVzdWx0W3R5cGVdKSB7XG4gICAgICAgIGh0bWwgKz0gJzxwPicgKyBpICsgJzogJyArIHJlc3VsdFt0eXBlXVtpXSArICc8L3A+JztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAod3JhcHBlcikge1xuICAgICAgaWYgKCdpbm5lckhUTUwnIGluIHdyYXBwZXIpIHtcbiAgICAgICAgd3JhcHBlci5pbm5lckhUTUwgPSBodG1sO1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2Ygd3JhcHBlci5odG1sID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHdyYXBwZXIuaHRtbChodG1sKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gaHRtbDtcbiAgfSxcblxuICAvKipcbiAgICog5Zyo5o6n5Yi25Y+w6L6T5Ye65omA5pyJ5qOA5rWL5Yiw55qE5pWw5o2uXG4gICAqIEBtZXRob2QgaW5mb1xuICAgKi9cbiAgaW5mbzogZnVuY3Rpb24oKSB7XG4gICAgaWYgKHdpbmRvdy5jb25zb2xlKSB7IGNvbnNvbGUuZGlyKHJlc3VsdCk7IH1cbiAgfVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vRTovZ2l0X3Byby9leHByZXNzLXdlYnBhY2stdnVlL3NyYy91dGlsL3VhZGV0ZWN0b3IuanMiXSwic291cmNlUm9vdCI6IiJ9");

/***/ },
/* 21 */
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _querystring = __webpack_require__(22);\n\nvar _querystring2 = _interopRequireDefault(_querystring);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar QUERY = _querystring2.default.parse();\n\n//var defaultTestHost = 'test.bolo.bobo.com',\nvar defaultTestHost = location.host.match(/test\\.bolo\\.bobo\\.com/) ? 'test.bolo.bobo.com' : 'preview.bobo.com:85',\n    defaultOfficialHost = 'bolo.bobo.com',\n    newOfficialHost = 'bolo.163.com';\n\nfunction isTest() {\n  if (QUERY.host == 'official') return false;else if (location.host.match(/test|local|dev|preview/) || _querystring2.default.parse().host == 'test') return true;else return false;\n}\n\nfunction isNew() {\n  return (/bolo\\.163\\.com/.test(location.host)\n  );\n}\n\nvar host = _querystring2.default.parse().test ? 'http://test.bolo.bobo.com' : 'http://m.live.netease.com';\n\nvar getHost = function getHost(testHost, officialHost) {\n\n  testHost = testHost || defaultTestHost;\n  officialHost = officialHost || (isNew() ? newOfficialHost : defaultOfficialHost);\n\n  if (isTest()) return testHost;else return officialHost;\n};\n\nvar getOrigin = function getOrigin(testHost, officialHost) {\n\n  testHost = testHost || defaultTestHost;\n  officialHost = officialHost || (isNew() ? newOfficialHost : defaultOfficialHost);\n\n  if (isTest()) return 'http://' + testHost;else return 'http://' + officialHost;\n};\n\nvar getImage = function getImage(path, size) {\n  size = size || [50, 50];\n\n  if (!path || !path.match('http')) return path;\n\n  var suffix = path.match('png');\n  suffix = suffix ? 'png' : 'jpg';\n\n  return 'http://imgsize.ph.126.net/?imgurl=' + path + '_' + size[0] + 'x' + size[1] + 'x0x80.' + suffix;\n};\n\nexports.default = {\n  host: host,\n  getHost: getHost,\n  getOrigin: getOrigin,\n  getImage: getImage\n};//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9FOi9naXRfcHJvL2V4cHJlc3Mtd2VicGFjay12dWUvc3JjL3V0aWwvSHR0cEhlbHBlci5qcz8zMTJhIl0sIm5hbWVzIjpbIlFVRVJZIiwicGFyc2UiLCJkZWZhdWx0VGVzdEhvc3QiLCJsb2NhdGlvbiIsImhvc3QiLCJtYXRjaCIsImRlZmF1bHRPZmZpY2lhbEhvc3QiLCJuZXdPZmZpY2lhbEhvc3QiLCJpc1Rlc3QiLCJpc05ldyIsInRlc3QiLCJnZXRIb3N0IiwidGVzdEhvc3QiLCJvZmZpY2lhbEhvc3QiLCJnZXRPcmlnaW4iLCJnZXRJbWFnZSIsInBhdGgiLCJzaXplIiwic3VmZml4Il0sIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQTs7Ozs7O0FBQ0EsSUFBSUEsUUFBUSxzQkFBR0MsS0FBSCxFQUFaOztBQUVBO0FBQ0EsSUFBSUMsa0JBQWtCQyxTQUFTQyxJQUFULENBQWNDLEtBQWQsQ0FBb0IsdUJBQXBCLElBQStDLG9CQUEvQyxHQUFzRSxxQkFBNUY7QUFBQSxJQUNFQyxzQkFBc0IsZUFEeEI7QUFBQSxJQUVFQyxrQkFBa0IsY0FGcEI7O0FBSUEsU0FBU0MsTUFBVCxHQUFpQjtBQUNmLE1BQUdSLE1BQU1JLElBQU4sSUFBYyxVQUFqQixFQUE2QixPQUFPLEtBQVAsQ0FBN0IsS0FDSyxJQUFHRCxTQUFTQyxJQUFULENBQWNDLEtBQWQsQ0FBb0Isd0JBQXBCLEtBQWlELHNCQUFHSixLQUFILEdBQVdHLElBQVgsSUFBbUIsTUFBdkUsRUFBK0UsT0FBTyxJQUFQLENBQS9FLEtBQ0EsT0FBTyxLQUFQO0FBQ047O0FBRUQsU0FBU0ssS0FBVCxHQUFnQjtBQUNkLFNBQU8sa0JBQWlCQyxJQUFqQixDQUFzQlAsU0FBU0MsSUFBL0I7QUFBUDtBQUNEOztBQUVELElBQUlBLE9BQU8sc0JBQUdILEtBQUgsR0FBV1MsSUFBWCxHQUFrQiwyQkFBbEIsR0FBZ0QsMkJBQTNEOztBQUVBLElBQUlDLFVBQVUsU0FBVkEsT0FBVSxDQUFTQyxRQUFULEVBQWtCQyxZQUFsQixFQUErQjs7QUFFM0NELGFBQVdBLFlBQVlWLGVBQXZCO0FBQ0FXLGlCQUFlQSxpQkFBaUJKLFVBQVVGLGVBQVYsR0FBNEJELG1CQUE3QyxDQUFmOztBQUVBLE1BQUdFLFFBQUgsRUFBYSxPQUFPSSxRQUFQLENBQWIsS0FDSyxPQUFPQyxZQUFQO0FBQ04sQ0FQRDs7QUFTQSxJQUFJQyxZQUFZLFNBQVpBLFNBQVksQ0FBU0YsUUFBVCxFQUFrQkMsWUFBbEIsRUFBK0I7O0FBRTdDRCxhQUFXQSxZQUFZVixlQUF2QjtBQUNBVyxpQkFBZUEsaUJBQWlCSixVQUFVRixlQUFWLEdBQTRCRCxtQkFBN0MsQ0FBZjs7QUFFQSxNQUFHRSxRQUFILEVBQWEsT0FBTyxZQUFZSSxRQUFuQixDQUFiLEtBQ0ssT0FBTyxZQUFZQyxZQUFuQjtBQUNOLENBUEQ7O0FBU0EsSUFBSUUsV0FBVyxTQUFYQSxRQUFXLENBQVNDLElBQVQsRUFBY0MsSUFBZCxFQUFtQjtBQUNoQ0EsU0FBT0EsUUFBUSxDQUFDLEVBQUQsRUFBSSxFQUFKLENBQWY7O0FBRUEsTUFBRyxDQUFDRCxJQUFELElBQVMsQ0FBQ0EsS0FBS1gsS0FBTCxDQUFXLE1BQVgsQ0FBYixFQUFpQyxPQUFPVyxJQUFQOztBQUVqQyxNQUFJRSxTQUFTRixLQUFLWCxLQUFMLENBQVcsS0FBWCxDQUFiO0FBQ0FhLFdBQVNBLFNBQVMsS0FBVCxHQUFpQixLQUExQjs7QUFFQSxTQUFPLHVDQUF1Q0YsSUFBdkMsR0FBOEMsR0FBOUMsR0FBb0RDLEtBQUssQ0FBTCxDQUFwRCxHQUE4RCxHQUE5RCxHQUFvRUEsS0FBSyxDQUFMLENBQXBFLEdBQThFLFFBQTlFLEdBQXlGQyxNQUFoRztBQUNELENBVEQ7O2tCQVdlO0FBQ2JkLFFBQU1BLElBRE87QUFFYk8sV0FBU0EsT0FGSTtBQUdiRyxhQUFXQSxTQUhFO0FBSWJDLFlBQVVBO0FBSkcsQyIsImZpbGUiOiIyMS5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBxcyBmcm9tICcuL3F1ZXJ5c3RyaW5nJztcbnZhciBRVUVSWSA9IHFzLnBhcnNlKCk7XG5cbi8vdmFyIGRlZmF1bHRUZXN0SG9zdCA9ICd0ZXN0LmJvbG8uYm9iby5jb20nLFxudmFyIGRlZmF1bHRUZXN0SG9zdCA9IGxvY2F0aW9uLmhvc3QubWF0Y2goL3Rlc3RcXC5ib2xvXFwuYm9ib1xcLmNvbS8pID8gJ3Rlc3QuYm9sby5ib2JvLmNvbScgOiAncHJldmlldy5ib2JvLmNvbTo4NScsXG4gIGRlZmF1bHRPZmZpY2lhbEhvc3QgPSAnYm9sby5ib2JvLmNvbScsXG4gIG5ld09mZmljaWFsSG9zdCA9ICdib2xvLjE2My5jb20nO1xuXG5mdW5jdGlvbiBpc1Rlc3QoKXtcbiAgaWYoUVVFUlkuaG9zdCA9PSAnb2ZmaWNpYWwnKSByZXR1cm4gZmFsc2U7XG4gIGVsc2UgaWYobG9jYXRpb24uaG9zdC5tYXRjaCgvdGVzdHxsb2NhbHxkZXZ8cHJldmlldy8pIHx8IHFzLnBhcnNlKCkuaG9zdCA9PSAndGVzdCcpIHJldHVybiB0cnVlO1xuICBlbHNlIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNOZXcoKXtcbiAgcmV0dXJuIC9ib2xvXFwuMTYzXFwuY29tLy50ZXN0KGxvY2F0aW9uLmhvc3QpO1xufVxuXG52YXIgaG9zdCA9IHFzLnBhcnNlKCkudGVzdCA/ICdodHRwOi8vdGVzdC5ib2xvLmJvYm8uY29tJyA6ICdodHRwOi8vbS5saXZlLm5ldGVhc2UuY29tJztcblxudmFyIGdldEhvc3QgPSBmdW5jdGlvbih0ZXN0SG9zdCxvZmZpY2lhbEhvc3Qpe1xuXG4gIHRlc3RIb3N0ID0gdGVzdEhvc3QgfHwgZGVmYXVsdFRlc3RIb3N0O1xuICBvZmZpY2lhbEhvc3QgPSBvZmZpY2lhbEhvc3QgfHwgKGlzTmV3KCkgPyBuZXdPZmZpY2lhbEhvc3QgOiBkZWZhdWx0T2ZmaWNpYWxIb3N0KTtcblxuICBpZihpc1Rlc3QoKSkgcmV0dXJuIHRlc3RIb3N0O1xuICBlbHNlIHJldHVybiBvZmZpY2lhbEhvc3Rcbn07XG5cbnZhciBnZXRPcmlnaW4gPSBmdW5jdGlvbih0ZXN0SG9zdCxvZmZpY2lhbEhvc3Qpe1xuXG4gIHRlc3RIb3N0ID0gdGVzdEhvc3QgfHwgZGVmYXVsdFRlc3RIb3N0O1xuICBvZmZpY2lhbEhvc3QgPSBvZmZpY2lhbEhvc3QgfHwgKGlzTmV3KCkgPyBuZXdPZmZpY2lhbEhvc3QgOiBkZWZhdWx0T2ZmaWNpYWxIb3N0KTtcblxuICBpZihpc1Rlc3QoKSkgcmV0dXJuICdodHRwOi8vJyArIHRlc3RIb3N0O1xuICBlbHNlIHJldHVybiAnaHR0cDovLycgKyBvZmZpY2lhbEhvc3Rcbn07XG5cbnZhciBnZXRJbWFnZSA9IGZ1bmN0aW9uKHBhdGgsc2l6ZSl7XG4gIHNpemUgPSBzaXplIHx8IFs1MCw1MF07XG5cbiAgaWYoIXBhdGggfHwgIXBhdGgubWF0Y2goJ2h0dHAnKSkgcmV0dXJuIHBhdGg7XG5cbiAgdmFyIHN1ZmZpeCA9IHBhdGgubWF0Y2goJ3BuZycpO1xuICBzdWZmaXggPSBzdWZmaXggPyAncG5nJyA6ICdqcGcnO1xuXG4gIHJldHVybiAnaHR0cDovL2ltZ3NpemUucGguMTI2Lm5ldC8/aW1ndXJsPScgKyBwYXRoICsgJ18nICsgc2l6ZVswXSArICd4JyArIHNpemVbMV0gKyAneDB4ODAuJyArIHN1ZmZpeDtcbn1cblxuZXhwb3J0IGRlZmF1bHQge1xuICBob3N0OiBob3N0LFxuICBnZXRIb3N0OiBnZXRIb3N0LFxuICBnZXRPcmlnaW46IGdldE9yaWdpbixcbiAgZ2V0SW1hZ2U6IGdldEltYWdlXG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vRTovZ2l0X3Byby9leHByZXNzLXdlYnBhY2stdnVlL3NyYy91dGlsL0h0dHBIZWxwZXIuanMiXSwic291cmNlUm9vdCI6IiJ9");

/***/ },
/* 22 */
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _base = __webpack_require__(19);\n\nvar _base2 = _interopRequireDefault(_base);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction encode(name, value, encoder) {\n\treturn encoder(name) + (value == null ? '' : '=' + encoder(value));\n} /**\n   * 本模块提供URL参数序列化与反序列化接口\n   * @module querystring/1.0.x/\n   * @category Utility\n   */\nexports.default = {\n\t/**\n  * 把数据序列化为URL参数\n  * @method stringify\n  * @param {Object|Array<Object<name,value>>} data 数据\n  * @param {Object} [o] 参数\n  *   @param {Function} [o.encode=encodeURIComponent] 编码函数\n  * @return {String} URL参数串\n  */\n\tstringify: function stringify(data, o) {\n\t\tif (typeof data === 'string') {\n\t\t\treturn data;\n\t\t}\n\n\t\to = _base2.default.extend({\n\t\t\tencode: encodeURIComponent\n\t\t}, o);\n\n\t\tvar result = [];\n\t\tif (_base2.default.isArray(data)) {\n\t\t\tdata.forEach(function (d) {\n\t\t\t\tresult.push(encode(d.name, d.value, o.encode));\n\t\t\t});\n\t\t} else {\n\t\t\tfor (var name in data) {\n\t\t\t\tresult.push(encode(name, data[name], o.encode));\n\t\t\t}\n\t\t}\n\n\t\treturn result.join('&');\n\t},\n\n\t/**\n  * 把URL参数反序列化为数据\n  * @method parse\n  * @param {String} [qs] URL参数，默认为当前窗口的location.search\n  * @param {Object} [o] 参数\n  *   @param {Function} [o.decode=decodeURIComponent] 解码函数\n  *   @param {String} [o.dataType] 返回数组类型，默认为Object，参数值为'array'时返回数组\n  * @return {Object|Array<Object<name,value>>} 数据\n  */\n\tparse: function parse(qs, o) {\n\t\to = _base2.default.extend({\n\t\t\tdecode: decodeURIComponent\n\t\t}, o);\n\n\t\tvar returnArray = o.dataType === 'array',\n\t\t    data = returnArray ? [] : {};\n\n\t\tqs = (qs || window.location.search).replace(/^\\?+/, '').split('&').forEach(function (pair) {\n\t\t\tif (!pair) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tpair = pair.split('=');\n\t\t\t// 只有参数名，没有等号和值的情况\n\t\t\tif (pair.length < 2) {\n\t\t\t\tpair.push(null);\n\t\t\t}\n\n\t\t\tif (returnArray) {\n\t\t\t\tdata.push({\n\t\t\t\t\tname: o.decode(pair[0]),\n\t\t\t\t\tvalue: o.decode(pair[1])\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tdata[o.decode(pair[0])] = o.decode(pair[1]);\n\t\t\t}\n\t\t});\n\n\t\treturn data;\n\t},\n\n\t/**\n  * 把数据序列化为URL参数后添加到指定URL\n  * @method append\n  * @param {String} url URL\n  * @param {Object|String} data 数据\n  * @param {Object} [o] 参数\n  *   @param {Function(value)} [o.encode=encodeURIComponent] 编码函数\n  * @return {String} 处理后的URL\n  */\n\tappend: function append(url, data, o) {\n\t\tif (!data || _base2.default.isArray(data) && !data.length || _base2.default.isEmptyObject(data)) {\n\t\t\treturn url;\n\t\t}\n\n\t\tdata = typeof data !== 'string' ? this.stringify(data, o) : data.replace(/^[?&]+/, '');\n\n\t\tvar temp = url.indexOf('#'),\n\t\t    hash = '';\n\t\tif (temp !== -1) {\n\t\t\thash = url.substring(temp, url.length);\n\t\t\turl = url.substring(0, temp);\n\t\t}\n\t\turl = url.replace(/[?&]+$/, '');\n\n\t\treturn url + (url.indexOf('?') === -1 ? '?' : '&') + data + hash;\n\t}\n};//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9FOi9naXRfcHJvL2V4cHJlc3Mtd2VicGFjay12dWUvc3JjL3V0aWwvcXVlcnlzdHJpbmcuanM/YjhlOSJdLCJuYW1lcyI6WyJlbmNvZGUiLCJuYW1lIiwidmFsdWUiLCJlbmNvZGVyIiwic3RyaW5naWZ5IiwiZGF0YSIsIm8iLCJleHRlbmQiLCJlbmNvZGVVUklDb21wb25lbnQiLCJyZXN1bHQiLCJpc0FycmF5IiwiZm9yRWFjaCIsImQiLCJwdXNoIiwiam9pbiIsInBhcnNlIiwicXMiLCJkZWNvZGUiLCJkZWNvZGVVUklDb21wb25lbnQiLCJyZXR1cm5BcnJheSIsImRhdGFUeXBlIiwid2luZG93IiwibG9jYXRpb24iLCJzZWFyY2giLCJyZXBsYWNlIiwic3BsaXQiLCJwYWlyIiwibGVuZ3RoIiwiYXBwZW5kIiwidXJsIiwiaXNFbXB0eU9iamVjdCIsInRlbXAiLCJpbmRleE9mIiwiaGFzaCIsInN1YnN0cmluZyJdLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBS0E7Ozs7OztBQUVBLFNBQVNBLE1BQVQsQ0FBZ0JDLElBQWhCLEVBQXNCQyxLQUF0QixFQUE2QkMsT0FBN0IsRUFBc0M7QUFDckMsUUFBT0EsUUFBUUYsSUFBUixLQUFrQkMsU0FBUyxJQUFULEdBQWdCLEVBQWhCLEdBQXVCLE1BQU1DLFFBQVFELEtBQVIsQ0FBL0MsQ0FBUDtBQUNBLEMsQ0FURDs7Ozs7a0JBV2U7QUFDZDs7Ozs7Ozs7QUFRQUUsWUFBVyxtQkFBU0MsSUFBVCxFQUFlQyxDQUFmLEVBQWtCO0FBQzVCLE1BQUksT0FBT0QsSUFBUCxLQUFnQixRQUFwQixFQUE4QjtBQUFFLFVBQU9BLElBQVA7QUFBYzs7QUFFOUNDLE1BQUksZUFBS0MsTUFBTCxDQUFZO0FBQ2ZQLFdBQVFRO0FBRE8sR0FBWixFQUVERixDQUZDLENBQUo7O0FBSUEsTUFBSUcsU0FBUyxFQUFiO0FBQ0EsTUFBSyxlQUFLQyxPQUFMLENBQWFMLElBQWIsQ0FBTCxFQUEwQjtBQUN6QkEsUUFBS00sT0FB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LElBQThDM0IsSUFBOUMsR0FBcUQ0QixJQUE1RDtBQUNBO0FBM0ZhLEMiLCJmaWxlIjoiMjIuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIOacrOaooeWdl+aPkOS+m1VSTOWPguaVsOW6j+WIl+WMluS4juWPjeW6j+WIl+WMluaOpeWPo1xuICogQG1vZHVsZSBxdWVyeXN0cmluZy8xLjAueC9cbiAqIEBjYXRlZ29yeSBVdGlsaXR5XG4gKi9cbmltcG9ydCBiYXNlIGZyb20gJy4vYmFzZSc7XG5cbmZ1bmN0aW9uIGVuY29kZShuYW1lLCB2YWx1ZSwgZW5jb2Rlcikge1xuXHRyZXR1cm4gZW5jb2RlcihuYW1lKSArICggdmFsdWUgPT0gbnVsbCA/ICcnIDogKCAnPScgKyBlbmNvZGVyKHZhbHVlKSApICk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHtcblx0LyoqXG5cdCAqIOaKiuaVsOaNruW6j+WIl+WMluS4ulVSTOWPguaVsFxuXHQgKiBAbWV0aG9kIHN0cmluZ2lmeVxuXHQgKiBAcGFyYW0ge09iamVjdHxBcnJheTxPYmplY3Q8bmFtZSx2YWx1ZT4+fSBkYXRhIOaVsOaNrlxuXHQgKiBAcGFyYW0ge09iamVjdH0gW29dIOWPguaVsFxuXHQgKiAgIEBwYXJhbSB7RnVuY3Rpb259IFtvLmVuY29kZT1lbmNvZGVVUklDb21wb25lbnRdIOe8lueggeWHveaVsFxuXHQgKiBAcmV0dXJuIHtTdHJpbmd9IFVSTOWPguaVsOS4slxuXHQgKi9cblx0c3RyaW5naWZ5OiBmdW5jdGlvbihkYXRhLCBvKSB7XG5cdFx0aWYgKHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJykgeyByZXR1cm4gZGF0YTsgfVxuXG5cdFx0byA9IGJhc2UuZXh0ZW5kKHtcblx0XHRcdGVuY29kZTogZW5jb2RlVVJJQ29tcG9uZW50XG5cdFx0fSwgbyk7XG5cblx0XHR2YXIgcmVzdWx0ID0gWyBdO1xuXHRcdGlmICggYmFzZS5pc0FycmF5KGRhdGEpICkge1xuXHRcdFx0ZGF0YS5mb3JFYWNoKGZ1bmN0aW9uKGQpIHtcblx0XHRcdFx0cmVzdWx0LnB1c2goIGVuY29kZShkLm5hbWUsIGQudmFsdWUsIG8uZW5jb2RlKSApO1xuXHRcdFx0fSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGZvciAodmFyIG5hbWUgaW4gZGF0YSkge1xuXHRcdFx0XHRyZXN1bHQucHVzaCggZW5jb2RlKG5hbWUsIGRhdGFbbmFtZV0sIG8uZW5jb2RlKSApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiByZXN1bHQuam9pbignJicpO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiDmiopVUkzlj4LmlbDlj43luo/liJfljJbkuLrmlbDmja5cblx0ICogQG1ldGhvZCBwYXJzZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gW3FzXSBVUkzlj4LmlbDvvIzpu5jorqTkuLrlvZPliY3nqpflj6PnmoRsb2NhdGlvbi5zZWFyY2hcblx0ICogQHBhcmFtIHtPYmplY3R9IFtvXSDlj4LmlbBcblx0ICogICBAcGFyYW0ge0Z1bmN0aW9ufSBbby5kZWNvZGU9ZGVjb2RlVVJJQ29tcG9uZW50XSDop6PnoIHlh73mlbBcblx0ICogICBAcGFyYW0ge1N0cmluZ30gW28uZGF0YVR5cGVdIOi/lOWbnuaVsOe7hOexu+Wei++8jOm7mOiupOS4uk9iamVjdO+8jOWPguaVsOWAvOS4uidhcnJheSfml7bov5Tlm57mlbDnu4Rcblx0ICogQHJldHVybiB7T2JqZWN0fEFycmF5PE9iamVjdDxuYW1lLHZhbHVlPj59IOaVsOaNrlxuXHQgKi9cblx0cGFyc2U6IGZ1bmN0aW9uIChxcywgbykge1xuXHRcdG8gPSBiYXNlLmV4dGVuZCh7XG5cdFx0XHRkZWNvZGU6IGRlY29kZVVSSUNvbXBvbmVudFxuXHRcdH0sIG8pO1xuXG5cdFx0dmFyIHJldHVybkFycmF5ID0gby5kYXRhVHlwZSA9PT0gJ2FycmF5JywgZGF0YSA9IHJldHVybkFycmF5ID8gWyBdIDogeyB9O1xuXG5cdFx0cXMgPSAoIHFzIHx8IHdpbmRvdy5sb2NhdGlvbi5zZWFyY2ggKVxuXHRcdFx0LnJlcGxhY2UoL15cXD8rLywgJycpLnNwbGl0KCcmJykuZm9yRWFjaChmdW5jdGlvbihwYWlyKSB7XG5cdFx0XHRcdGlmICghcGFpcikgeyByZXR1cm47IH1cblxuXHRcdFx0XHRwYWlyID0gcGFpci5zcGxpdCgnPScpO1xuXHRcdFx0XHQvLyDlj6rmnInlj4LmlbDlkI3vvIzmsqHmnInnrYnlj7flkozlgLznmoTmg4XlhrVcblx0XHRcdFx0aWYgKHBhaXIubGVuZ3RoIDwgMikgeyBwYWlyLnB1c2gobnVsbCk7IH1cblxuXHRcdFx0XHRpZiAocmV0dXJuQXJyYXkpIHtcblx0XHRcdFx0XHRkYXRhLnB1c2goe1xuXHRcdFx0XHRcdFx0bmFtZTogby5kZWNvZGUocGFpclswXSksXG5cdFx0XHRcdFx0XHR2YWx1ZTogby5kZWNvZGUocGFpclsxXSlcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRkYXRhW28uZGVjb2RlKHBhaXJbMF0pXSA9IG8uZGVjb2RlKHBhaXJbMV0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblxuXHRcdHJldHVybiBkYXRhO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiDmiormlbDmja7luo/liJfljJbkuLpVUkzlj4LmlbDlkI7mt7vliqDliLDmjIflrppVUkxcblx0ICogQG1ldGhvZCBhcHBlbmRcblx0ICogQHBhcmFtIHtTdHJpbmd9IHVybCBVUkxcblx0ICogQHBhcmFtIHtPYmplY3R8U3RyaW5nfSBkYXRhIOaVsOaNrlxuXHQgKiBAcGFyYW0ge09iamVjdH0gW29dIOWPguaVsFxuXHQgKiAgIEBwYXJhbSB7RnVuY3Rpb24odmFsdWUpfSBbby5lbmNvZGU9ZW5jb2RlVVJJQ29tcG9uZW50XSDnvJbnoIHlh73mlbBcblx0ICogQHJldHVybiB7U3RyaW5nfSDlpITnkIblkI7nmoRVUkxcblx0ICovXG5cdGFwcGVuZDogZnVuY3Rpb24odXJsLCBkYXRhLCBvKSB7XG5cdFx0aWYgKCAhZGF0YSB8fCAoYmFzZS5pc0FycmF5KGRhdGEpICYmICFkYXRhLmxlbmd0aCkgfHwgYmFzZS5pc0VtcHR5T2JqZWN0KGRhdGEpICkge1xuXHRcdFx0cmV0dXJuIHVybDtcblx0XHR9XG5cblx0XHRkYXRhID0gdHlwZW9mIGRhdGEgIT09ICdzdHJpbmcnID8gdGhpcy5zdHJpbmdpZnkoZGF0YSwgbykgOiBkYXRhLnJlcGxhY2UoL15bPyZdKy8sICcnKTtcblxuXHRcdHZhciB0ZW1wID0gdXJsLmluZGV4T2YoJyMnKSwgaGFzaCA9ICcnO1xuXHRcdGlmICh0ZW1wICE9PSAtMSkge1xuXHRcdFx0aGFzaCA9IHVybC5zdWJzdHJpbmcodGVtcCwgdXJsLmxlbmd0aCk7XG5cdFx0XHR1cmwgPSB1cmwuc3Vic3RyaW5nKDAsIHRlbXApO1xuXHRcdH1cblx0XHR1cmwgPSB1cmwucmVwbGFjZSgvWz8mXSskLywgJycpO1xuXG5cdFx0cmV0dXJuIHVybCArICh1cmwuaW5kZXhPZignPycpID09PSAtMSA/ICc/JyA6ICcmJykgKyBkYXRhICsgaGFzaDtcblx0fVxufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL0U6L2dpdF9wcm8vZXhwcmVzcy13ZWJwYWNrLXZ1ZS9zcmMvdXRpbC9xdWVyeXN0cmluZy5qcyJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ },
/* 23 */
/***/ function(module, exports) {

	eval("'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n/*\n * MD5编码\n */\nfunction safe_add(x, y) {\n\tvar lsw = (x & 0xFFFF) + (y & 0xFFFF),\n\t    msw = (x >> 16) + (y >> 16) + (lsw >> 16);\n\treturn msw << 16 | lsw & 0xFFFF;\n}\n/*\n * Bitwise rotate a 32-bit number to the left.\n */\nfunction bit_rol(num, cnt) {\n\treturn num << cnt | num >>> 32 - cnt;\n}\n/*\n * These functions implement the four basic operations the algorithm uses.\n */\nfunction md5_cmn(q, a, b, x, s, t) {\n\treturn safe_add(bit_rol(safe_add(safe_add(a, q), safe_add(x, t)), s), b);\n}\nfunction md5_ff(a, b, c, d, x, s, t) {\n\treturn md5_cmn(b & c | ~b & d, a, b, x, s, t);\n}\nfunction md5_gg(a, b, c, d, x, s, t) {\n\treturn md5_cmn(b & d | c & ~d, a, b, x, s, t);\n}\nfunction md5_hh(a, b, c, d, x, s, t) {\n\treturn md5_cmn(b ^ c ^ d, a, b, x, s, t);\n}\nfunction md5_ii(a, b, c, d, x, s, t) {\n\treturn md5_cmn(c ^ (b | ~d), a, b, x, s, t);\n}\n/*\n * Calculate the MD5 of an array of little-endian words, and a bit length.\n */\nfunction binl_md5(x, len) {\n\t/* append padding */\n\tx[len >> 5] |= 0x80 << len % 32;\n\tx[(len + 64 >>> 9 << 4) + 14] = len;\n\tvar i,\n\t    olda,\n\t    oldb,\n\t    oldc,\n\t    oldd,\n\t    a = 1732584193,\n\t    b = -271733879,\n\t    c = -1732584194,\n\t    d = 271733878;\n\tfor (i = 0; i < x.length; i += 16) {\n\t\tolda = a;\n\t\toldb = b;\n\t\toldc = c;\n\t\toldd = d;\n\t\ta = md5_ff(a, b, c, d, x[i], 7, -680876936);\n\t\td = md5_ff(d, a, b, c, x[i + 1], 12, -389564586);\n\t\tc = md5_ff(c, d, a, b, x[i + 2], 17, 606105819);\n\t\tb = md5_ff(b, c, d, a, x[i + 3], 22, -1044525330);\n\t\ta = md5_ff(a, b, c, d, x[i + 4], 7, -176418897);\n\t\td = md5_ff(d, a, b, c, x[i + 5], 12, 1200080426);\n\t\tc = md5_ff(c, d, a, b, x[i + 6], 17, -1473231341);\n\t\tb = md5_ff(b, c, d, a, x[i + 7], 22, -45705983);\n\t\ta = md5_ff(a, b, c, d, x[i + 8], 7, 1770035416);\n\t\td = md5_ff(d, a, b, c, x[i + 9], 12, -1958414417);\n\t\tc = md5_ff(c, d, a, b, x[i + 10], 17, -42063);\n\t\tb = md5_ff(b, c, d, a, x[i + 11], 22, -1990404162);\n\t\ta = md5_ff(a, b, c, d, x[i + 12], 7, 1804603682);\n\t\td = md5_ff(d, a, b, c, x[i + 13], 12, -40341101);\n\t\tc = md5_ff(c, d, a, b, x[i + 14], 17, -1502002290);\n\t\tb = md5_ff(b, c, d, a, x[i + 15], 22, 1236535329);\n\t\ta = md5_gg(a, b, c, d, x[i + 1], 5, -165796510);\n\t\td = md5_gg(d, a, b, c, x[i + 6], 9, -1069501632);\n\t\tc = md5_gg(c, d, a, b, x[i + 11], 14, 643717713);\n\t\tb = md5_gg(b, c, d, a, x[i], 20, -373897302);\n\t\ta = md5_gg(a, b, c, d, x[i + 5], 5, -701558691);\n\t\td = md5_gg(d, a, b, c, x[i + 10], 9, 38016083);\n\t\tc = md5_gg(c, d, a, b, x[i + 15], 14, -660478335);\n\t\tb = md5_gg(b, c, d, a, x[i + 4], 20, -405537848);\n\t\ta = md5_gg(a, b, c, d, x[i + 9], 5, 568446438);\n\t\td = md5_gg(d, a, b, c, x[i + 14], 9, -1019803690);\n\t\tc = md5_gg(c, d, a, b, x[i + 3], 14, -187363961);\n\t\tb = md5_gg(b, c, d, a, x[i + 8], 20, 1163531501);\n\t\ta = md5_gg(a, b, c, d, x[i + 13], 5, -1444681467);\n\t\td = md5_gg(d, a, b, c, x[i + 2], 9, -51403784);\n\t\tc = md5_gg(c, d, a, b, x[i + 7], 14, 1735328473);\n\t\tb = md5_gg(b, c, d, a, x[i + 12], 20, -1926607734);\n\t\ta = md5_hh(a, b, c, d, x[i + 5], 4, -378558);\n\t\td = md5_hh(d, a, b, c, x[i + 8], 11, -2022574463);\n\t\tc = md5_hh(c, d, a, b, x[i + 11], 16, 1839030562);\n\t\tb = md5_hh(b, c, d, a, x[i + 14], 23, -35309556);\n\t\ta = md5_hh(a, b, c, d, x[i + 1], 4, -1530992060);\n\t\td = md5_hh(d, a, b, c, x[i + 4], 11, 1272893353);\n\t\tc = md5_hh(c, d, a, b, x[i + 7], 16, -155497632);\n\t\tb = md5_hh(b, c, d, a, x[i + 10], 23, -1094730640);\n\t\ta = md5_hh(a, b, c, d, x[i + 13], 4, 681279174);\n\t\td = md5_hh(d, a, b, c, x[i], 11, -358537222);\n\t\tc = md5_hh(c, d, a, b, x[i + 3], 16, -722521979);\n\t\tb = md5_hh(b, c, d, a, x[i + 6], 23, 76029189);\n\t\ta = md5_hh(a, b, c, d, x[i + 9], 4, -640364487);\n\t\td = md5_hh(d, a, b, c, x[i + 12], 11, -421815835);\n\t\tc = md5_hh(c, d, a, b, x[i + 15], 16, 530742520);\n\t\tb = md5_hh(b, c, d, a, x[i + 2], 23, -995338651);\n\t\ta = md5_ii(a, b, c, d, x[i], 6, -198630844);\n\t\td = md5_ii(d, a, b, c, x[i + 7], 10, 1126891415);\n\t\tc = md5_ii(c, d, a, b, x[i + 14], 15, -1416354905);\n\t\tb = md5_ii(b, c, d, a, x[i + 5], 21, -57434055);\n\t\ta = md5_ii(a, b, c, d, x[i + 12], 6, 1700485571);\n\t\td = md5_ii(d, a, b, c, x[i + 3], 10, -1894986606);\n\t\tc = md5_ii(c, d, a, b, x[i + 10], 15, -1051523);\n\t\tb = md5_ii(b, c, d, a, x[i + 1], 21, -2054922799);\n\t\ta = md5_ii(a, b, c, d, x[i + 8], 6, 1873313359);\n\t\td = md5_ii(d, a, b, c, x[i + 15], 10, -30611744);\n\t\tc = md5_ii(c, d, a, b, x[i + 6], 15, -1560198380);\n\t\tb = md5_ii(b, c, d, a, x[i + 13], 21, 1309151649);\n\t\ta = md5_ii(a, b, c, d, x[i + 4], 6, -145523070);\n\t\td = md5_ii(d, a, b, c, x[i + 11], 10, -1120210379);\n\t\tc = md5_ii(c, d, a, b, x[i + 2], 15, 718787259);\n\t\tb = md5_ii(b, c, d, a, x[i + 9], 21, -343485551);\n\t\ta = safe_add(a, olda);\n\t\tb = safe_add(b, oldb);\n\t\tc = safe_add(c, oldc);\n\t\td = safe_add(d, oldd);\n\t}\n\treturn [a, b, c, d];\n}\n/*\n * Convert an array of little-endian words to a string\n */\nfunction binl2rstr(input) {\n\tvar i,\n\t    output = '';\n\tfor (i = 0; i < input.length * 32; i += 8) {\n\t\toutput += String.fromCharCode(input[i >> 5] >>> i % 32 & 0xFF);\n\t}\n\treturn output;\n}\n/*\n * Convert a raw string to an array of little-endian words\n * Characters >255 have their high-byte silently ignored.\n */\nfunction rstr2binl(input) {\n\tvar i,\n\t    output = [];\n\toutput[(input.length >> 2) - 1] = undefined;\n\tfor (i = 0; i < output.length; i += 1) {\n\t\toutput[i] = 0;\n\t}\n\tfor (i = 0; i < input.length * 8; i += 8) {\n\t\toutput[i >> 5] |= (input.charCodeAt(i / 8) & 0xFF) << i % 32;\n\t}\n\treturn output;\n}\n/*\n * Calculate the MD5 of a raw string\n */\nfunction rstr_md5(s) {\n\treturn binl2rstr(binl_md5(rstr2binl(s), s.length * 8));\n}\n/*\n * Calculate the HMAC-MD5, of a key and some data (raw strings)\n */\nfunction rstr_hmac_md5(key, data) {\n\tvar i,\n\t    bkey = rstr2binl(key),\n\t    ipad = [],\n\t    opad = [],\n\t    hash;\n\tipad[15] = opad[15] = undefined;\n\tif (bkey.length > 16) {\n\t\tbkey = binl_md5(bkey, key.length * 8);\n\t}\n\tfor (i = 0; i < 16; i += 1) {\n\t\tipad[i] = bkey[i] ^ 0x36363636;\n\t\topad[i] = bkey[i] ^ 0x5C5C5C5C;\n\t}\n\thash = binl_md5(ipad.concat(rstr2binl(data)), 512 + data.length * 8);\n\treturn binl2rstr(binl_md5(opad.concat(hash), 512 + 128));\n}\n/*\n * Convert a raw string to a hex string\n */\nfunction rstr2hex(input) {\n\tvar hex_tab = '0123456789abcdef',\n\t    output = '',\n\t    x,\n\t    i;\n\tfor (i = 0; i < input.length; i += 1) {\n\t\tx = input.charCodeAt(i);\n\t\toutput += hex_tab.charAt(x >>> 4 & 0x0F) + hex_tab.charAt(x & 0x0F);\n\t}\n\treturn output;\n}\n/*\n * Encode a string as utf-8\n */\nfunction str2rstr_utf8(input) {\n\treturn unescape(encodeURIComponent(input));\n}\n/*\n * Take string arguments and return either raw or hex encoded strings\n */\nfunction raw_md5(s) {\n\treturn rstr_md5(str2rstr_utf8(s));\n}\nfunction hex_md5(s) {\n\treturn rstr2hex(raw_md5(s));\n}\nfunction raw_hmac_md5(k, d) {\n\treturn rstr_hmac_md5(str2rstr_utf8(k), str2rstr_utf8(d));\n}\nfunction hex_hmac_md5(k, d) {\n\treturn rstr2hex(raw_hmac_md5(k, d));\n}\nfunction md5(string, key, raw) {\n\tif (!key) {\n\t\tif (!raw) {\n\t\t\treturn hex_md5(string);\n\t\t}\n\t\treturn raw_md5(string);\n\t}\n\tif (!raw) {\n\t\treturn hex_hmac_md5(key, string);\n\t}\n\treturn raw_hmac_md5(key, string);\n}\n\nexports.default = {\n\tmd5: md5\n};//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9FOi9naXRfcHJvL2V4cHJlc3Mtd2VicGFjay12dWUvc3JjL3V0aWwvbWQ1LmpzPzNhM2EiXSwibmFtZXMiOlsic2FmZV9hZGQiLCJ4IiwieSIsImxzdyIsIm1zdyIsImJpdF9yb2wiLCJudW0iLCJjbnQiLCJtZDVfY21uIiwicSIsImEiLCJiIiwicyIsInQiLCJtZDVfZmYiLCJjIiwiZCIsIm1kNV9nZyIsIm1kNV9oaCIsIm1kNV9paSIsImJpbmxfbWQ1IiwibGVuIiwiaSIsIm9sZGEiLCJvbGRiIiwib2xkYyIsIm9sZGQiLCJsZW5ndGgiLCJiaW5sMnJzdHIiLCJpbnB1dCIsIm91dHB1dCIsIlN0cmluZyIsImZyb21DaGFyQ29kZSIsInJzdHIyYmlubCIsInVuZGVmaW5lZCIsImNoYXJDb2RlQXQiLCJyc3RyX21kNSIsInJzdHJfaG1hY19tZDUiLCJrZXkiLCJkYXRhIiwiYmtleSIsImlwYWQiLCJvcGFkIiwiaGFzaCIsImNvbmNhdCIsInJzdHIyaGV4IiwiaGV4X3RhYiIsImNoYXJBdCIsInN0cjJyc3RyX3V0ZjgiLCJ1bmVzY2FwZSIsImVuY29kZVVSSUNvbXBvbmVudCIsInJhd19tZDUiLCJoZXhfbWQ1IiwicmF3X2htYWNfbWQ1IiwiayIsImhleF9obWFjX21kNSIsIm1kNSIsInN0cmluZyIsInJhdyJdLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQzs7O0FBR0EsU0FBU0EsUUFBVCxDQUFrQkMsQ0FBbEIsRUFBcUJDLENBQXJCLEVBQXdCO0FBQ3ZCLEtBQUlDLE1BQU0sQ0FBQ0YsSUFBSSxNQUFMLEtBQWdCQyxJQUFJLE1BQXBCLENBQVY7QUFBQSxLQUNDRSxNQUFNLENBQUNILEtBQUssRUFBTixLQUFhQyxLQUFLLEVBQWxCLEtBQXlCQyxPQUFPLEVBQWhDLENBRFA7QUFFQSxRQUFRQyxPQUFPLEVBQVIsR0FBZUQsTUFBTSxNQUE1QjtBQUNBO0FBQ0Q7OztBQUdBLFNBQVNFLE9BQVQsQ0FBaUJDLEdBQWpCLEVBQXNCQyxHQUF0QixF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QUFULENBQVA7QUFDQTtBQUNELFNBQVN3QyxPQUFULENBQWlCeEMsQ0FBakIsRUFBb0I7QUFDbkIsUUFBT2lDLFNBQVNNLFFBQVF2QyxDQUFSLENBQVQsQ0FBUDtBQUNBO0FBQ0QsU0FBU3lDLFlBQVQsQ0FBc0JDLENBQXRCLEVBQXlCdEMsQ0FBekIsRUFBNEI7QUFDM0IsUUFBT3FCLGNBQWNXLGNBQWNNLENBQWQsQ0FBZCxFQUFnQ04sY0FBY2hDLENBQWQsQ0FBaEMsQ0FBUDtBQUNBO0FBQ0QsU0FBU3VDLFlBQVQsQ0FBc0JELENBQXRCLEVBQXlCdEMsQ0FBekIsRUFBNEI7QUFDM0IsUUFBTzZCLFNBQVNRLGFBQWFDLENBQWIsRUFBZ0J0QyxDQUFoQixDQUFULENBQVA7QUFDQTtBQUNELFNBQVN3QyxHQUFULENBQWFDLE1BQWIsRUFBcUJuQixHQUFyQixFQUEwQm9CLEdBQTFCLEVBQStCO0FBQzlCLEtBQUksQ0FBQ3BCLEdBQUwsRUFBVTtBQUNULE1BQUksQ0FBQ29CLEdBQUwsRUFBVTtBQUNULFVBQU9OLFFBQVFLLE1BQVIsQ0FBUDtBQUNBO0FBQ0QsU0FBT04sUUFBUU0sTUFBUixDQUFQO0FBQ0E7QUFDRCxLQUFJLENBQUNDLEdBQUwsRUFBVTtBQUNULFNBQU9ILGFBQWFqQixHQUFiLEVBQWtCbUIsTUFBbEIsQ0FBUDtBQUNBO0FBQ0QsUUFBT0osYUFBYWYsR0FBYixFQUFrQm1CLE1BQWxCLENBQVA7QUFDQTs7a0JBRWM7QUFDWkQsTUFBS0E7QUFETyxDIiwiZmlsZSI6IjIzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiXHQvKlxuXHQgKiBNRDXnvJbnoIFcblx0ICovXG5cdGZ1bmN0aW9uIHNhZmVfYWRkKHgsIHkpIHtcblx0XHR2YXIgbHN3ID0gKHggJiAweEZGRkYpICsgKHkgJiAweEZGRkYpLFxuXHRcdFx0bXN3ID0gKHggPj4gMTYpICsgKHkgPj4gMTYpICsgKGxzdyA+PiAxNik7XG5cdFx0cmV0dXJuIChtc3cgPDwgMTYpIHwgKGxzdyAmIDB4RkZGRik7XG5cdH1cblx0Lypcblx0ICogQml0d2lzZSByb3RhdGUgYSAzMi1iaXQgbnVtYmVyIHRvIHRoZSBsZWZ0LlxuXHQgKi9cblx0ZnVuY3Rpb24gYml0X3JvbChudW0sIGNudCkge1xuXHRcdHJldHVybiAobnVtIDw8IGNudCkgfCAobnVtID4+PiAoMzIgLSBjbnQpKTtcblx0fVxuXHQvKlxuXHQgKiBUaGVzZSBmdW5jdGlvbnMgaW1wbGVtZW50IHRoZSBmb3VyIGJhc2ljIG9wZXJhdGlvbnMgdGhlIGFsZ29yaXRobSB1c2VzLlxuXHQgKi9cblx0ZnVuY3Rpb24gbWQ1X2NtbihxLCBhLCBiLCB4LCBzLCB0KSB7XG5cdFx0cmV0dXJuIHNhZmVfYWRkKGJpdF9yb2woc2FmZV9hZGQoc2FmZV9hZGQoYSwgcSksIHNhZmVfYWRkKHgsIHQpKSwgcyksIGIpO1xuXHR9XG5cdGZ1bmN0aW9uIG1kNV9mZihhLCBiLCBjLCBkLCB4LCBzLCB0KSB7XG5cdFx0cmV0dXJuIG1kNV9jbW4oKGIgJiBjKSB8ICgofmIpICYgZCksIGEsIGIsIHgsIHMsIHQpO1xuXHR9XG5cdGZ1bmN0aW9uIG1kNV9nZyhhLCBiLCBjLCBkLCB4LCBzLCB0KSB7XG5cdFx0cmV0dXJuIG1kNV9jbW4oKGIgJiBkKSB8IChjICYgKH5kKSksIGEsIGIsIHgsIHMsIHQpO1xuXHR9XG5cdGZ1bmN0aW9uIG1kNV9oaChhLCBiLCBjLCBkLCB4LCBzLCB0KSB7XG5cdFx0cmV0dXJuIG1kNV9jbW4oYiBeIGMgXiBkLCBhLCBiLCB4LCBzLCB0KTtcblx0fVxuXHRmdW5jdGlvbiBtZDVfaWkoYSwgYiwgYywgZCwgeCwgcywgdCkge1xuXHRcdHJldHVybiBtZDVfY21uKGMgXiAoYiB8ICh+ZCkpLCBhLCBiLCB4LCBzLCB0KTtcblx0fVxuXHQvKlxuXHQgKiBDYWxjdWxhdGUgdGhlIE1ENSBvZiBhbiBhcnJheSBvZiBsaXR0bGUtZW5kaWFuIHdvcmRzLCBhbmQgYSBiaXQgbGVuZ3RoLlxuXHQgKi9cblx0ZnVuY3Rpb24gYmlubF9tZDUoeCwgbGVuKSB7IC8qIGFwcGVuZCBwYWRkaW5nICovXG5cdFx0eFtsZW4gPj4gNV0gfD0gMHg4MCA8PCAobGVuICUgMzIpO1xuXHRcdHhbKCgobGVuICsgNjQpID4+PiA5KSA8PCA0KSArIDE0XSA9IGxlbjtcblx0XHR2YXIgaSwgb2xkYSwgb2xkYiwgb2xkYywgb2xkZCxcblx0XHRcdGEgPSAxNzMyNTg0MTkzLFxuXHRcdFx0YiA9IC0yNzE3MzM4NzksXG5cdFx0XHRjID0gLTE3MzI1ODQxOTQsXG5cdFx0XHRkID0gMjcxNzMzODc4O1xuXHRcdGZvciAoaSA9IDA7IGkgPCB4Lmxlbmd0aDsgaSArPSAxNikge1xuXHRcdFx0b2xkYSA9IGE7XG5cdFx0XHRvbGRiID0gYjtcblx0XHRcdG9sZGMgPSBjO1xuXHRcdFx0b2xkZCA9IGQ7XG5cdFx0XHRhID0gbWQ1X2ZmKGEsIGIsIGMsIGQsIHhbaV0sIDcsIC02ODA4NzY5MzYpO1xuXHRcdFx0ZCA9IG1kNV9mZihkLCBhLCBiLCBjLCB4W2kgKyAxXSwgMTIsIC0zODk1NjQ1ODYpO1xuXHRcdFx0YyA9IG1kNV9mZihjLCBkLCBhLCBiLCB4W2kgKyAyXSwgMTcsIDYwNjEwNTgxOSk7XG5cdFx0XHRiID0gbWQ1X2ZmKGIsIGMsIGQsIGEsIHhbaSArIDNdLCAyMiwgLTEwNDQ1MjUzMzApO1xuXHRcdFx0YSA9IG1kNV9mZihhLCBiLCBjLCBkLCB4W2kgKyA0XSwgNywgLTE3NjQxODg5Nyk7XG5cdFx0XHRkID0gbWQ1X2ZmKGQsIGEsIGIsIGMsIHhbaSArIDVdLCAxMiwgMTIwMDA4MDQyNik7XG5cdFx0XHRjID0gbWQ1X2ZmKGMsIGQsIGEsIGIsIHhbaSArIDZdLCAxNywgLTE0NzMyMzEzNDEpO1xuXHRcdFx0YiA9IG1kNV9mZihiLCBjLCBkLCBhLCB4W2kgKyA3XSwgMjIsIC00NTcwNTk4Myk7XG5cdFx0XHRhID0gbWQ1X2ZmKGEsIGIsIGMsIGQsIHhbaSArIDhdLCA3LCAxNzcwMDM1NDE2KTtcblx0XHRcdGQgPSBtZDVfZmYoZCwgYSwgYiwgYywgeFtpICsgOV0sIDEyLCAtMTk1ODQxNDQxNyk7XG5cdFx0XHRjID0gbWQ1X2ZmKGMsIGQsIGEsIGIsIHhbaSArIDEwXSwgMTcsIC00MjA2Myk7XG5cdFx0XHRiID0gbWQ1X2ZmKGIsIGMsIGQsIGEsIHhbaSArIDExXSwgMjIsIC0xOTkwNDA0MTYyKTtcblx0XHRcdGEgPSBtZDVfZmYoYSwgYiwgYywgZCwgeFtpICsgMTJdLCA3LCAxODA0NjAzNjgyKTtcblx0XHRcdGQgPSBtZDVfZmYoZCwgYSwgYiwgYywgeFtpICsgMTNdLCAxMiwgLTQwMzQxMTAxKTtcblx0XHRcdGMgPSBtZDVfZmYoYywgZCwgYSwgYiwgeFtpICsgMTRdLCAxNywgLTE1MDIwMDIyOTApO1xuXHRcdFx0YiA9IG1kNV9mZihiLCBjLCBkLCBhLCB4W2kgKyAxNV0sIDIyLCAxMjM2NTM1MzI5KTtcblx0XHRcdGEgPSBtZDVfZ2coYSwgYiwgYywgZCwgeFtpICsgMV0sIDUsIC0xNjU3OTY1MTApO1xuXHRcdFx0ZCA9IG1kNV9nZyhkLCBhLCBiLCBjLCB4W2kgKyA2XSwgOSwgLTEwNjk1MDE2MzIpO1xuXHRcdFx0YyA9IG1kNV9nZyhjLCBkLCBhLCBiLCB4W2kgKyAxMV0sIDE0LCA2NDM3MTc3MTMpO1xuXHRcdFx0YiA9IG1kNV9nZyhiLCBjLCBkLCBhLCB4W2ldLCAyMCwgLTM3Mzg5NzMwMik7XG5cdFx0XHRhID0gbWQ1X2dnKGEsIGIsIGMsIGQsIHhbaSArIDVdLCA1LCAtNzAxNTU4NjkxKTtcblx0XHRcdGQgPSBtZDVfZ2coZCwgYSwgYiwgYywgeFtpICsgMTBdLCA5LCAzODAxNjA4Myk7XG5cdFx0XHRjID0gbWQ1X2dnKGMsIGQsIGEsIGIsIHhbaSArIDE1XSwgMTQsIC02NjA0NzgzMzUpO1xuXHRcdFx0YiA9IG1kNV9nZyhiLCBjLCBkLCBhLCB4W2kgKyA0XSwgMjAsIC00MDU1Mzc4NDgpO1xuXHRcdFx0YSA9IG1kNV9nZyhhLCBiLCBjLCBkLCB4W2kgKyA5XSwgNSwgNTY4NDQ2NDM4KTtcblx0XHRcdGQgPSBtZDVfZ2coZCwgYSwgYiwgYywgeFtpICsgMTRdLCA5LCAtMTAxOTgwMzY5MCk7XG5cdFx0XHRjID0gbWQ1X2dnKGMsIGQsIGEsIGIsIHhbaSArIDNdLCAxNCwgLTE4NzM2Mzk2MSk7XG5cdFx0XHRiID0gbWQ1X2dnKGIsIGMsIGQsIGEsIHhbaSArIDhdLCAyMCwgMTE2MzUzMTUwMSk7XG5cdFx0XHRhID0gbWQ1X2dnKGEsIGIsIGMsIGQsIHhbaSArIDEzXSwgNSwgLTE0NDQ2ODE0NjcpO1xuXHRcdFx0ZCA9IG1kNV9nZyhkLCBhLCBiLCBjLCB4W2kgKyAyXSwgOSwgLTUxNDAzNzg0KTtcblx0XHRcdGMgPSBtZDVfZ2coYywgZCwgYSwgYiwgeFtpICsgN10sIDE0LCAxNzM1MzI4NDczKTtcblx0XHRcdGIgPSBtZDVfZ2coYiwgYywgZCwgYSwgeFtpICsgMTJdLCAyMCwgLTE5MjY2MDc3MzQpO1xuXHRcdFx0YSA9IG1kNV9oaChhLCBiLCBjLCBkLCB4W2kgKyA1XSwgNCwgLTM3ODU1OCk7XG5cdFx0XHRkID0gbWQ1X2hoKGQsIGEsIGIsIGMsIHhbaSArIDhdLCAxMSwgLTIwMjI1NzQ0NjMpO1xuXHRcdFx0YyA9IG1kNV9oaChjLCBkLCBhLCBiLCB4W2kgKyAxMV0sIDE2LCAxODM5MDMwNTYyKTtcblx0XHRcdGIgPSBtZDVfaGgoYiwgYywgZCwgYSwgeFtpICsgMTRdLCAyMywgLTM1MzA5NTU2KTtcblx0XHRcdGEgPSBtZDVfaGgoYSwgYiwgYywgZCwgeFtpICsgMV0sIDQsIC0xNTMwOTkyMDYwKTtcblx0XHRcdGQgPSBtZDVfaGgoZCwgYSwgYiwgYywgeFtpICsgNF0sIDExLCAxMjcyODkzMzUzKTtcblx0XHRcdGMgPSBtZDVfaGgoYywgZCwgYSwgYiwgeFtpICsgN10sIDE2LCAtMTU1NDk3NjMyKTtcblx0XHRcdGIgPSBtZDVfaGgoYiwgYywgZCwgYSwgeFtpICsgMTBdLCAyMywgLTEwOTQ3MzA2NDApO1xuXHRcdFx0YSA9IG1kNV9oaChhLCBiLCBjLCBkLCB4W2kgKyAxM10sIDQsIDY4MTI3OTE3NCk7XG5cdFx0XHRkID0gbWQ1X2hoKGQsIGEsIGIsIGMsIHhbaV0sIDExLCAtMzU4NTM3MjIyKTtcblx0XHRcdGMgPSBtZDVfaGgoYywgZCwgYSwgYiwgeFtpICsgM10sIDE2LCAtNzIyNTIxOTc5KTtcblx0XHRcdGIgPSBtZDVfaGgoYiwgYywgZCwgYSwgeFtpICsgNl0sIDIzLCA3NjAyOTE4OSk7XG5cdFx0XHRhID0gbWQ1X2hoKGEsIGIsIGMsIGQsIHhbaSArIDldLCA0LCAtNjQwMzY0NDg3KTtcblx0XHRcdGQgPSBtZDVfaGgoZCwgYSwgYiwgYywgeFtpICsgMTJdLCAxMSwgLTQyMTgxNTgzNSk7XG5cdFx0XHRjID0gbWQ1X2hoKGMsIGQsIGEsIGIsIHhbaSArIDE1XSwgMTYsIDUzMDc0MjUyMCk7XG5cdFx0XHRiID0gbWQ1X2hoKGIsIGMsIGQsIGEsIHhbaSArIDJdLCAyMywgLTk5NTMzODY1MSk7XG5cdFx0XHRhID0gbWQ1X2lpKGEsIGIsIGMsIGQsIHhbaV0sIDYsIC0xOTg2MzA4NDQpO1xuXHRcdFx0ZCA9IG1kNV9paShkLCBhLCBiLCBjLCB4W2kgKyA3XSwgMTAsIDExMjY4OTE0MTUpO1xuXHRcdFx0YyA9IG1kNV9paShjLCBkLCBhLCBiLCB4W2kgKyAxNF0sIDE1LCAtMTQxNjM1NDkwNSk7XG5cdFx0XHRiID0gbWQ1X2lpKGIsIGMsIGQsIGEsIHhbaSArIDVdLCAyMSwgLTU3NDM0MDU1KTtcblx0XHRcdGEgPSBtZDVfaWkoYSwgYiwgYywgZCwgeFtpICsgMTJdLCA2LCAxNzAwNDg1NTcxKTtcblx0XHRcdGQgPSBtZDVfaWkoZCwgYSwgYiwgYywgeFtpICsgM10sIDEwLCAtMTg5NDk4NjYwNik7XG5cdFx0XHRjID0gbWQ1X2lpKGMsIGQsIGEsIGIsIHhbaSArIDEwXSwgMTUsIC0xMDUxNTIzKTtcblx0XHRcdGIgPSBtZDVfaWkoYiwgYywgZCwgYSwgeFtpICsgMV0sIDIxLCAtMjA1NDkyMjc5OSk7XG5cdFx0XHRhID0gbWQ1X2lpKGEsIGIsIGMsIGQsIHhbaSArIDhdLCA2LCAxODczMzEzMzU5KTtcblx0XHRcdGQgPSBtZDVfaWkoZCwgYSwgYiwgYywgeFtpICsgMTVdLCAxMCwgLTMwNjExNzQ0KTtcblx0XHRcdGMgPSBtZDVfaWkoYywgZCwgYSwgYiwgeFtpICsgNl0sIDE1LCAtMTU2MDE5ODM4MCk7XG5cdFx0XHRiID0gbWQ1X2lpKGIsIGMsIGQsIGEsIHhbaSArIDEzXSwgMjEsIDEzMDkxNTE2NDkpO1xuXHRcdFx0YSA9IG1kNV9paShhLCBiLCBjLCBkLCB4W2kgKyA0XSwgNiwgLTE0NTUyMzA3MCk7XG5cdFx0XHRkID0gbWQ1X2lpKGQsIGEsIGIsIGMsIHhbaSArIDExXSwgMTAsIC0xMTIwMjEwMzc5KTtcblx0XHRcdGMgPSBtZDVfaWkoYywgZCwgYSwgYiwgeFtpICsgMl0sIDE1LCA3MTg3ODcyNTkpO1xuXHRcdFx0YiA9IG1kNV9paShiLCBjLCBkLCBhLCB4W2kgKyA5XSwgMjEsIC0zNDM0ODU1NTEpO1xuXHRcdFx0YSA9IHNhZmVfYWRkKGEsIG9sZGEpO1xuXHRcdFx0YiA9IHNhZmVfYWRkKGIsIG9sZGIpO1xuXHRcdFx0YyA9IHNhZmVfYWRkKGMsIG9sZGMpO1xuXHRcdFx0ZCA9IHNhZmVfYWRkKGQsIG9sZGQpO1xuXHRcdH1cblx0XHRyZXR1cm4gW2EsIGIsIGMsIGRdO1xuXHR9XG5cdC8qXG5cdCAqIENvbnZlcnQgYW4gYXJyYXkgb2YgbGl0dGxlLWVuZGlhbiB3b3JkcyB0byBhIHN0cmluZ1xuXHQgKi9cblx0ZnVuY3Rpb24gYmlubDJyc3RyKGlucHV0KSB7XG5cdFx0dmFyIGksXG5cdFx0XHRvdXRwdXQgPSAnJztcblx0XHRmb3IgKGkgPSAwOyBpIDwgaW5wdXQubGVuZ3RoICogMzI7IGkgKz0gOCkge1xuXHRcdFx0b3V0cHV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoKGlucHV0W2kgPj4gNV0gPj4+IChpICUgMzIpKSAmIDB4RkYpO1xuXHRcdH1cblx0XHRyZXR1cm4gb3V0cHV0O1xuXHR9XG5cdC8qXG5cdCAqIENvbnZlcnQgYSByYXcgc3RyaW5nIHRvIGFuIGFycmF5IG9mIGxpdHRsZS1lbmRpYW4gd29yZHNcblx0ICogQ2hhcmFjdGVycyA+MjU1IGhhdmUgdGhlaXIgaGlnaC1ieXRlIHNpbGVudGx5IGlnbm9yZWQuXG5cdCAqL1xuXHRmdW5jdGlvbiByc3RyMmJpbmwoaW5wdXQpIHtcblx0XHR2YXIgaSxcblx0XHRcdG91dHB1dCA9IFtdO1xuXHRcdG91dHB1dFsoaW5wdXQubGVuZ3RoID4+IDIpIC0gMV0gPSB1bmRlZmluZWQ7XG5cdFx0Zm9yIChpID0gMDsgaSA8IG91dHB1dC5sZW5ndGg7IGkgKz0gMSkge1xuXHRcdFx0b3V0cHV0W2ldID0gMDtcblx0XHR9XG5cdFx0Zm9yIChpID0gMDsgaSA8IGlucHV0Lmxlbmd0aCAqIDg7IGkgKz0gOCkge1xuXHRcdFx0b3V0cHV0W2kgPj4gNV0gfD0gKGlucHV0LmNoYXJDb2RlQXQoaSAvIDgpICYgMHhGRikgPDwgKGkgJSAzMik7XG5cdFx0fVxuXHRcdHJldHVybiBvdXRwdXQ7XG5cdH1cblx0Lypcblx0ICogQ2FsY3VsYXRlIHRoZSBNRDUgb2YgYSByYXcgc3RyaW5nXG5cdCAqL1xuXHRmdW5jdGlvbiByc3RyX21kNShzKSB7XG5cdFx0cmV0dXJuIGJpbmwycnN0cihiaW5sX21kNShyc3RyMmJpbmwocyksIHMubGVuZ3RoICogOCkpO1xuXHR9XG5cdC8qXG5cdCAqIENhbGN1bGF0ZSB0aGUgSE1BQy1NRDUsIG9mIGEga2V5IGFuZCBzb21lIGRhdGEgKHJhdyBzdHJpbmdzKVxuXHQgKi9cblx0ZnVuY3Rpb24gcnN0cl9obWFjX21kNShrZXksIGRhdGEpIHtcblx0XHR2YXIgaSxcblx0XHRcdGJrZXkgPSByc3RyMmJpbmwoa2V5KSxcblx0XHRcdGlwYWQgPSBbXSxcblx0XHRcdG9wYWQgPSBbXSxcblx0XHRcdGhhc2g7XG5cdFx0aXBhZFsxNV0gPSBvcGFkWzE1XSA9IHVuZGVmaW5lZDtcblx0XHRpZiAoYmtleS5sZW5ndGggPiAxNikge1xuXHRcdFx0YmtleSA9IGJpbmxfbWQ1KGJrZXksIGtleS5sZW5ndGggKiA4KTtcblx0XHR9XG5cdFx0Zm9yIChpID0gMDsgaSA8IDE2OyBpICs9IDEpIHtcblx0XHRcdGlwYWRbaV0gPSBia2V5W2ldIF4gMHgzNjM2MzYzNjtcblx0XHRcdG9wYWRbaV0gPSBia2V5W2ldIF4gMHg1QzVDNUM1Qztcblx0XHR9XG5cdFx0aGFzaCA9IGJpbmxfbWQ1KGlwYWQuY29uY2F0KHJzdHIyYmlubChkYXRhKSksIDUxMiArIGRhdGEubGVuZ3RoICogOCk7XG5cdFx0cmV0dXJuIGJpbmwycnN0cihiaW5sX21kNShvcGFkLmNvbmNhdChoYXNoKSwgNTEyICsgMTI4KSk7XG5cdH1cblx0Lypcblx0ICogQ29udmVydCBhIHJhdyBzdHJpbmcgdG8gYSBoZXggc3RyaW5nXG5cdCAqL1xuXHRmdW5jdGlvbiByc3RyMmhleChpbnB1dCkge1xuXHRcdHZhciBoZXhfdGFiID0gJzAxMjM0NTY3ODlhYmNkZWYnLFxuXHRcdFx0b3V0cHV0ID0gJycsXG5cdFx0XHR4LFxuXHRcdFx0aTtcblx0XHRmb3IgKGkgPSAwOyBpIDwgaW5wdXQubGVuZ3RoOyBpICs9IDEpIHtcblx0XHRcdHggPSBpbnB1dC5jaGFyQ29kZUF0KGkpO1xuXHRcdFx0b3V0cHV0ICs9IGhleF90YWIuY2hhckF0KCh4ID4+PiA0KSAmIDB4MEYpICsgaGV4X3RhYi5jaGFyQXQoeCAmIDB4MEYpO1xuXHRcdH1cblx0XHRyZXR1cm4gb3V0cHV0O1xuXHR9XG5cdC8qXG5cdCAqIEVuY29kZSBhIHN0cmluZyBhcyB1dGYtOFxuXHQgKi9cblx0ZnVuY3Rpb24gc3RyMnJzdHJfdXRmOChpbnB1dCkge1xuXHRcdHJldHVybiB1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoaW5wdXQpKTtcblx0fVxuXHQvKlxuXHQgKiBUYWtlIHN0cmluZyBhcmd1bWVudHMgYW5kIHJldHVybiBlaXRoZXIgcmF3IG9yIGhleCBlbmNvZGVkIHN0cmluZ3Ncblx0ICovXG5cdGZ1bmN0aW9uIHJhd19tZDUocykge1xuXHRcdHJldHVybiByc3RyX21kNShzdHIycnN0cl91dGY4KHMpKTtcblx0fVxuXHRmdW5jdGlvbiBoZXhfbWQ1KHMpIHtcblx0XHRyZXR1cm4gcnN0cjJoZXgocmF3X21kNShzKSk7XG5cdH1cblx0ZnVuY3Rpb24gcmF3X2htYWNfbWQ1KGssIGQpIHtcblx0XHRyZXR1cm4gcnN0cl9obWFjX21kNShzdHIycnN0cl91dGY4KGspLCBzdHIycnN0cl91dGY4KGQpKTtcblx0fVxuXHRmdW5jdGlvbiBoZXhfaG1hY19tZDUoaywgZCkge1xuXHRcdHJldHVybiByc3RyMmhleChyYXdfaG1hY19tZDUoaywgZCkpO1xuXHR9XG5cdGZ1bmN0aW9uIG1kNShzdHJpbmcsIGtleSwgcmF3KSB7XG5cdFx0aWYgKCFrZXkpIHtcblx0XHRcdGlmICghcmF3KSB7XG5cdFx0XHRcdHJldHVybiBoZXhfbWQ1KHN0cmluZyk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcmF3X21kNShzdHJpbmcpO1xuXHRcdH1cblx0XHRpZiAoIXJhdykge1xuXHRcdFx0cmV0dXJuIGhleF9obWFjX21kNShrZXksIHN0cmluZyk7XG5cdFx0fVxuXHRcdHJldHVybiByYXdfaG1hY19tZDUoa2V5LCBzdHJpbmcpO1xuXHR9XG5cblx0ZXhwb3J0IGRlZmF1bHQge1xuICAgIG1kNTogbWQ1XG4gIH07XG5cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL0U6L2dpdF9wcm8vZXhwcmVzcy13ZWJwYWNrLXZ1ZS9zcmMvdXRpbC9tZDUuanMiXSwic291cmNlUm9vdCI6IiJ9");

/***/ },
/* 24 */
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _base = __webpack_require__(19);\n\nvar _base2 = _interopRequireDefault(_base);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n// 时间单位\nvar TimeUnit = {\n\tSEC: 1000,\n\tMIN: 60 * 1000,\n\tHOUR: 60 * 60 * 1000,\n\tDAY: 24 * 60 * 60 * 1000,\n\tMONTH: 30 * 24 * 60 * 60 * 1000,\n\tYEAR: 365 * 24 * 60 * 60 * 1000\n};\n\n// 匹配带单位的时间值\n/**\n * 本模块提供cookie读写接口\n * @module cookie/1.0.x/\n * @category Utility\n */\nvar rTime = /^(\\d+(?:\\.\\d+)?)\\s*([a-z]+?)s?$/i;\n\n// 转换为时间数字\nfunction toTimeSpan(val) {\n\tif (rTime.test(val)) {\n\t\tvar unit = RegExp.$2.toUpperCase();\n\t\t// 无此时间单位，抛出异常\n\t\tif (!TimeUnit.hasOwnProperty(unit)) {\n\t\t\tthrow new Error('not such time unit(' + RegExp.$2 + ')');\n\t\t}\n\n\t\treturn parseFloat(RegExp.$1) * TimeUnit[unit];\n\t}\n\n\treturn parseFloat(val) || 0;\n}\n\nexports.default = {\n\t/**\n  * 写入cookie\n  * @method set\n  * @param {String} name cookie名\n  * @param {String} value cookie值\n  * @param {Object} [o] 参数\n  *   @param {String} [o.domain] 所在域\n  *   @param {String} [o.path] 所在路径\n  *   @param {Date|Number|String} [o.expires] 过期时间。可传入带单位的时间值，例如'1 hour'，\n  *     支持的时间单位有sec、min、hour、day，month、year\n  *   @param {Boolean} [o.secure] 是否只在https连接中有效\n  *   @param {Function(value)} [o.encode=encodeURIComponent] 编码函数\n  */\n\tset: function set(name, value, o) {\n\t\to = _base2.default.extend({\n\t\t\tencode: encodeURIComponent\n\t\t}, o);\n\n\t\tvar expires = o.expires,\n\t\t    text = o.encode(name) + '=' + o.encode(value);\n\n\t\tif (typeof expires === 'string') {\n\t\t\texpires = toTimeSpan(expires);\n\t\t}\n\t\tif (typeof expires === 'number') {\n\t\t\tvar d = new Date();\n\t\t\td.setTime(d.getTime() + expires);\n\t\t\texpires = d;\n\t\t}\n\t\tif (_base2.default.isDate(expires)) {\n\t\t\ttext += '; expires=' + expires.toUTCString();\n\t\t}\n\n\t\tif (o.path) {\n\t\t\ttext += '; path=' + o.path;\n\t\t}\n\t\tif (o.domain) {\n\t\t\ttext += '; domain=' + o.domain;\n\t\t}\n\t\tif (o.secure === true) {\n\t\t\ttext += '; secure';\n\t\t}\n\n\t\tdocument.cookie = text;\n\t},\n\n\t/**\n  * 读取cookie\n  * @method get\n  * @param {String} name cookie名\n  * @param {Object} [o] 参数\n  *   @param {Function(value)} [o.encode=encodeURIComponent] 编码函数\n  *   @param {Function(value)} [o.decode=decodeURIComponent] 解码函数\n  * @return {String} cookie值\n  */\n\tget: function get(name, o) {\n\t\to = _base2.default.extend({\n\t\t\tencode: encodeURIComponent,\n\t\t\tdecode: decodeURIComponent\n\t\t}, o);\n\n\t\tname = '; ' + o.encode(name) + '=';\n\t\tvar cookie = '; ' + document.cookie,\n\t\t    beginPos = cookie.indexOf(name),\n\t\t    endPos;\n\n\t\tif (beginPos === -1) {\n\t\t\treturn null;\n\t\t}\n\n\t\tbeginPos += name.length;\n\t\tendPos = cookie.indexOf(';', beginPos);\n\t\tif (endPos === -1) {\n\t\t\tendPos = cookie.length;\n\t\t}\n\n\t\treturn o.decode(cookie.substring(beginPos, endPos));\n\t},\n\n\t/**\n  * 移除cookie\n  * @method remove\n  * @param {String} name cookie名\n  * @param {Object} [o] 参数\n  *   @param {String} [o.domain] 所在域\n  *   @param {String} [o.path] 所在路径\n  *   @param {Function(value)} [o.encode=encodeURIComponent] 编码函数\n  *   @param {Function(value)} [o.decode=decodeURIComponent] 解码函数\n  */\n\tremove: function remove(name, o) {\n\t\to = o || {};\n\t\to.expires = new Date(0);\n\n\t\tthis.set(name, '', o);\n\t}\n};//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9FOi9naXRfcHJvL2V4cHJlc3Mtd2VicGFjay12dWUvc3JjL3V0aWwvY29va2llLmpzPzQ5ZTgiXSwibmFtZXMiOlsiVGltZVVuaXQiLCJTRUMiLCJNSU4iLCJIT1VSIiwiREFZIiwiTU9OVEgiLCJZRUFSIiwiclRpbWUiLCJ0b1RpbWVTcGFuIiwidmFsIiwidGVzdCIsInVuaXQiLCJSZWdFeHAiLCIkMiIsInRvVXBwZXJDYXNlIiwiaGFzT3duUHJvcGVydHkiLCJFcnJvciIsInBhcnNlRmxvYXQiLCIkMSIsInNldCIsIm5hbWUiLCJ2YWx1ZSIsIm8iLCJleHRlbmQiLCJlbmNvZGUiLCJlbmNvZGVVUklDb21wb25lbnQiLCJleHBpcmVzIiwidGV4dCIsImQiLCJEYXRlIiwic2V0VGltZSIsImdldFRpbWUiLCJpc0RhdGUiLCJ0b1VUQ1N0cmluZyIsInBhdGgiLCJkb21haW4iLCJzZWN1cmUiLCJkb2N1bWVudCIsImNvb2tpZSIsImdldCIsImRlY29kZSIsImRlY29kZVVSSUNvbXBvbmVudCIsImJlZ2luUG9zIiwiaW5kZXhPZiIsImVuZFBvcyIsImxlbmd0aCIsInN1YnN0cmluZyIsInJlbW92ZSJdLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBS0E7Ozs7OztBQUNBO0FBQ0EsSUFBSUEsV0FBVztBQUNkQyxNQUFLLElBRFM7QUFFZEMsTUFBSyxLQUFLLElBRkk7QUFHZEMsT0FBTSxLQUFLLEVBQUwsR0FBVSxJQUhGO0FBSWRDLE1BQUssS0FBSyxFQUFMLEdBQVUsRUFBVixHQUFlLElBSk47QUFLZEMsUUFBTyxLQUFLLEVBQUwsR0FBVSxFQUFWLEdBQWUsRUFBZixHQUFvQixJQUxiO0FBTWRDLE9BQU0sTUFBTSxFQUFOLEdBQVcsRUFBWCxHQUFnQixFQUFoQixHQUFxQjtBQU5iLENBQWY7O0FBU0E7QUFoQkE7Ozs7O0FBaUJBLElBQUlDLFFBQVEsa0NBQVo7O0FBRUE7QUFDQSxTQUFTQyxVQUFULENBQW9CQyxHQUFwQixFQUF5QjtBQUN4QixL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Q0FBUyxDQUFULENBQVo7O0FBRUEsT0FBS1YsR0FBTCxDQUFTQyxJQUFULEVBQWUsRUFBZixFQUFtQkUsQ0FBbkI7QUFDQTtBQTlFYSxDIiwiZmlsZSI6IjI0LmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiDmnKzmqKHlnZfmj5Dkvptjb29raWXor7vlhpnmjqXlj6NcbiAqIEBtb2R1bGUgY29va2llLzEuMC54L1xuICogQGNhdGVnb3J5IFV0aWxpdHlcbiAqL1xuaW1wb3J0IGJhc2UgZnJvbSAnLi9iYXNlJztcbi8vIOaXtumXtOWNleS9jVxudmFyIFRpbWVVbml0ID0ge1xuXHRTRUM6IDEwMDAsXG5cdE1JTjogNjAgKiAxMDAwLFxuXHRIT1VSOiA2MCAqIDYwICogMTAwMCxcblx0REFZOiAyNCAqIDYwICogNjAgKiAxMDAwLFxuXHRNT05USDogMzAgKiAyNCAqIDYwICogNjAgKiAxMDAwLFxuXHRZRUFSOiAzNjUgKiAyNCAqIDYwICogNjAgKiAxMDAwXG59O1xuXG4vLyDljLnphY3luKbljZXkvY3nmoTml7bpl7TlgLxcbnZhciByVGltZSA9IC9eKFxcZCsoPzpcXC5cXGQrKT8pXFxzKihbYS16XSs/KXM/JC9pO1xuXG4vLyDovazmjaLkuLrml7bpl7TmlbDlrZdcbmZ1bmN0aW9uIHRvVGltZVNwYW4odmFsKSB7XG5cdGlmICggclRpbWUudGVzdCh2YWwpICkge1xuXHRcdHZhciB1bml0ID0gUmVnRXhwLiQyLnRvVXBwZXJDYXNlKCk7XG5cdFx0Ly8g5peg5q2k5pe26Ze05Y2V5L2N77yM5oqb5Ye65byC5bi4XG5cdFx0aWYgKCAhVGltZVVuaXQuaGFzT3duUHJvcGVydHkodW5pdCkgKSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ25vdCBzdWNoIHRpbWUgdW5pdCgnICsgUmVnRXhwLiQyICsgJyknKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gcGFyc2VGbG9hdChSZWdFeHAuJDEpICogVGltZVVuaXRbdW5pdF07XG5cdH1cblxuXHRyZXR1cm4gcGFyc2VGbG9hdCh2YWwpIHx8IDA7XG59XG5cblxuZXhwb3J0IGRlZmF1bHQge1xuXHQvKipcblx0ICog5YaZ5YWlY29va2llXG5cdCAqIEBtZXRob2Qgc2V0XG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIGNvb2tpZeWQjVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gdmFsdWUgY29va2ll5YC8XG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBbb10g5Y+C5pWwXG5cdCAqICAgQHBhcmFtIHtTdHJpbmd9IFtvLmRvbWFpbl0g5omA5Zyo5Z+fXG5cdCAqICAgQHBhcmFtIHtTdHJpbmd9IFtvLnBhdGhdIOaJgOWcqOi3r+W+hFxuXHQgKiAgIEBwYXJhbSB7RGF0ZXxOdW1iZXJ8U3RyaW5nfSBbby5leHBpcmVzXSDov4fmnJ/ml7bpl7TjgILlj6/kvKDlhaXluKbljZXkvY3nmoTml7bpl7TlgLzvvIzkvovlpoInMSBob3VyJ++8jFxuXHQgKiAgICAg5pSv5oyB55qE5pe26Ze05Y2V5L2N5pyJc2Vj44CBbWlu44CBaG91cuOAgWRhee+8jG1vbnRo44CBeWVhclxuXHQgKiAgIEBwYXJhbSB7Qm9vbGVhbn0gW28uc2VjdXJlXSDmmK/lkKblj6rlnKhodHRwc+i/nuaOpeS4reacieaViFxuXHQgKiAgIEBwYXJhbSB7RnVuY3Rpb24odmFsdWUpfSBbby5lbmNvZGU9ZW5jb2RlVVJJQ29tcG9uZW50XSDnvJbnoIHlh73mlbBcblx0ICovXG5cdHNldDogZnVuY3Rpb24gKG5hbWUsIHZhbHVlLCBvKSB7XG5cdFx0byA9IGJhc2UuZXh0ZW5kKHtcblx0XHRcdGVuY29kZTogZW5jb2RlVVJJQ29tcG9uZW50XG5cdFx0fSwgbyk7XG5cblx0XHR2YXIgZXhwaXJlcyA9IG8uZXhwaXJlcywgdGV4dCA9IG8uZW5jb2RlKG5hbWUpICsgJz0nICsgby5lbmNvZGUodmFsdWUpO1xuXG5cdFx0aWYgKHR5cGVvZiBleHBpcmVzID09PSAnc3RyaW5nJykgeyBleHBpcmVzID0gdG9UaW1lU3BhbihleHBpcmVzKTsgfVxuXHRcdGlmICh0eXBlb2YgZXhwaXJlcyA9PT0gJ251bWJlcicpIHtcblx0XHRcdHZhciBkID0gbmV3IERhdGUoKTtcblx0XHRcdGQuc2V0VGltZShkLmdldFRpbWUoKSArIGV4cGlyZXMpO1xuXHRcdFx0ZXhwaXJlcyA9IGQ7XG5cdFx0fVxuXHRcdGlmICggYmFzZS5pc0RhdGUoZXhwaXJlcykgKSB7IHRleHQgKz0gJzsgZXhwaXJlcz0nICsgZXhwaXJlcy50b1VUQ1N0cmluZygpOyB9XG5cblx0XHRpZiAoby5wYXRoKSB7IHRleHQgKz0gJzsgcGF0aD0nICsgby5wYXRoOyB9XG5cdFx0aWYgKG8uZG9tYWluKSB7IHRleHQgKz0gJzsgZG9tYWluPScgKyBvLmRvbWFpbjsgfVxuXHRcdGlmIChvLnNlY3VyZSA9PT0gdHJ1ZSkgeyB0ZXh0ICs9ICc7IHNlY3VyZSc7IH1cblxuXHRcdGRvY3VtZW50LmNvb2tpZSA9IHRleHQ7XG5cdH0sXG5cblx0LyoqXG5cdCAqIOivu+WPlmNvb2tpZVxuXHQgKiBAbWV0aG9kIGdldFxuXHQgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBjb29raWXlkI1cblx0ICogQHBhcmFtIHtPYmplY3R9IFtvXSDlj4LmlbBcblx0ICogICBAcGFyYW0ge0Z1bmN0aW9uKHZhbHVlKX0gW28uZW5jb2RlPWVuY29kZVVSSUNvbXBvbmVudF0g57yW56CB5Ye95pWwXG5cdCAqICAgQHBhcmFtIHtGdW5jdGlvbih2YWx1ZSl9IFtvLmRlY29kZT1kZWNvZGVVUklDb21wb25lbnRdIOino+eggeWHveaVsFxuXHQgKiBAcmV0dXJuIHtTdHJpbmd9IGNvb2tpZeWAvFxuXHQgKi9cblx0Z2V0OiBmdW5jdGlvbihuYW1lLCBvKSB7XG5cdFx0byA9IGJhc2UuZXh0ZW5kKHtcblx0XHRcdGVuY29kZTogZW5jb2RlVVJJQ29tcG9uZW50LFxuXHRcdFx0ZGVjb2RlOiBkZWNvZGVVUklDb21wb25lbnRcblx0XHR9LCBvKTtcblxuXHRcdG5hbWUgPSAnOyAnICsgby5lbmNvZGUobmFtZSkgKyAnPSc7XG5cdFx0dmFyIGNvb2tpZSA9ICc7ICcgKyBkb2N1bWVudC5jb29raWUsIGJlZ2luUG9zID0gY29va2llLmluZGV4T2YobmFtZSksIGVuZFBvcztcblxuXHRcdGlmIChiZWdpblBvcyA9PT0gLTEpIHsgcmV0dXJuIG51bGw7IH1cblxuXHRcdGJlZ2luUG9zICs9IG5hbWUubGVuZ3RoO1xuXHRcdGVuZFBvcyA9IGNvb2tpZS5pbmRleE9mKCc7JywgYmVnaW5Qb3MpO1xuXHRcdGlmIChlbmRQb3MgPT09IC0xKSB7IGVuZFBvcyA9IGNvb2tpZS5sZW5ndGg7IH1cblxuXHRcdHJldHVybiBvLmRlY29kZSggY29va2llLnN1YnN0cmluZyhiZWdpblBvcywgZW5kUG9zKSApO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiDnp7vpmaRjb29raWVcblx0ICogQG1ldGhvZCByZW1vdmVcblx0ICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgY29va2ll5ZCNXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBbb10g5Y+C5pWwXG5cdCAqICAgQHBhcmFtIHtTdHJpbmd9IFtvLmRvbWFpbl0g5omA5Zyo5Z+fXG5cdCAqICAgQHBhcmFtIHtTdHJpbmd9IFtvLnBhdGhdIOaJgOWcqOi3r+W+hFxuXHQgKiAgIEBwYXJhbSB7RnVuY3Rpb24odmFsdWUpfSBbby5lbmNvZGU9ZW5jb2RlVVJJQ29tcG9uZW50XSDnvJbnoIHlh73mlbBcblx0ICogICBAcGFyYW0ge0Z1bmN0aW9uKHZhbHVlKX0gW28uZGVjb2RlPWRlY29kZVVSSUNvbXBvbmVudF0g6Kej56CB5Ye95pWwXG5cdCAqL1xuXHRyZW1vdmU6IGZ1bmN0aW9uIChuYW1lLCBvKSB7XG5cdFx0byA9IG8gfHwgeyB9O1xuXHRcdG8uZXhwaXJlcyA9IG5ldyBEYXRlKDApO1xuXG5cdFx0dGhpcy5zZXQobmFtZSwgJycsIG8pO1xuXHR9XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vRTovZ2l0X3Byby9leHByZXNzLXdlYnBhY2stdnVlL3NyYy91dGlsL2Nvb2tpZS5qcyJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ },
/* 25 */
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _base = __webpack_require__(19);\n\nvar _base2 = _interopRequireDefault(_base);\n\nvar _uadetector = __webpack_require__(20);\n\nvar _uadetector2 = _interopRequireDefault(_uadetector);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n//_czc.push([\"_trackEvent\",category,action,label,value,nodeid]);\n//各参数含义如下：\n//category：事件类别，必填项，表示事件发生在谁身上，如“视频”、“小说”、“轮显层”等等。\n//action：事件操作，必填项，表示访客跟元素交互的行为动作，如\"播放\"、\"收藏\"、\"翻层\"等等。\n//label：事件标签，选填项，用于更详细的描述事件，从各个方面都可以，比如具体是哪个视频，哪部小说，翻到了第几层等等。\n//value：事件值，选填项，整数型，用于填写打分型事件的分值，加载时间型事件的时长，订单型事件的价格等等。\n//nodeid：div元素id，选填项，填写网页中的div元素id值，用于在“用户视点”功能上重绘元素的事件发生情况。\nexports.default = {\n  send: function send(category, options) {\n    options = _base2.default.extend({\n      action: _uadetector2.default.isDevice('mobile') ? 'tap' : 'click',\n      label: '',\n      value: ''\n    }, options);\n    if (_czc) _czc.push([\"_trackEvent\", category, options.action, options.label, options.value]);\n  }\n};//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9FOi9naXRfcHJvL2V4cHJlc3Mtd2VicGFjay12dWUvc3JjL3V0aWwvU3RhdC5qcz80MDQzIl0sIm5hbWVzIjpbInNlbmQiLCJjYXRlZ29yeSIsIm9wdGlvbnMiLCJleHRlbmQiLCJhY3Rpb24iLCJpc0RldmljZSIsImxhYmVsIiwidmFsdWUiLCJfY3pjIiwicHVzaCJdLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUE7Ozs7QUFDQTs7Ozs7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7a0JBQ2U7QUFDYkEsUUFBTSxjQUFVQyxRQUFWLEVBQW9CQyxPQUFwQixFQUE2QjtBQUNqQ0EsY0FBVSxlQUFLQyxNQUFMLENBQVk7QUFDcEJDLGNBQVEscUJBQVdDLFFBQVgsQ0FBb0IsUUFBcEIsSUFBZ0MsS0FBaEMsR0FBd0MsT0FENUI7QUFFcEJDLGFBQU8sRUFGYTtBQUdwQkMsYUFBTztBQUhhLEtBQVosRUFJUEwsT0FKTyxDQUFWO0FBS0EsUUFBSU0sSUFBSixFQUFVQSxLQUFLQyxJQUFMLENBQVUsQ0FBQyxhQUFELEVBQWdCUixRQUFoQixFQUEwQkMsUUFBUUUsTUFBbEMsRUFBMENGLFFBQVFJLEtBQWxELEVBQXlESixRQUFRSyxLQUFqRSxDQUFWO0FBQ1g7QUFSWSxDIiwiZmlsZSI6IjI1LmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGJhc2UgZnJvbSAnLi9iYXNlJztcbmltcG9ydCB1YWRldGVjdG9yIGZyb20gJy4vdWFkZXRlY3Rvcic7XG5cbi8vX2N6Yy5wdXNoKFtcIl90cmFja0V2ZW50XCIsY2F0ZWdvcnksYWN0aW9uLGxhYmVsLHZhbHVlLG5vZGVpZF0pO1xuLy/lkITlj4LmlbDlkKvkuYnlpoLkuIvvvJpcbi8vY2F0ZWdvcnnvvJrkuovku7bnsbvliKvvvIzlv4XloavpobnvvIzooajnpLrkuovku7blj5HnlJ/lnKjosIHouqvkuIrvvIzlpoLigJzop4bpopHigJ3jgIHigJzlsI/or7TigJ3jgIHigJzova7mmL7lsYLigJ3nrYnnrYnjgIJcbi8vYWN0aW9u77ya5LqL5Lu25pON5L2c77yM5b+F5aGr6aG577yM6KGo56S66K6/5a6i6Lef5YWD57Sg5Lqk5LqS55qE6KGM5Li65Yqo5L2c77yM5aaCXCLmkq3mlL5cIuOAgVwi5pS26JePXCLjgIFcIue/u+Wxglwi562J562J44CCXG4vL2xhYmVs77ya5LqL5Lu25qCH562+77yM6YCJ5aGr6aG577yM55So5LqO5pu06K+m57uG55qE5o+P6L+w5LqL5Lu277yM5LuO5ZCE5Liq5pa56Z2i6YO95Y+v5Lul77yM5q+U5aaC5YW35L2T5piv5ZOq5Liq6KeG6aKR77yM5ZOq6YOo5bCP6K+077yM57+75Yiw5LqG56ys5Yeg5bGC562J562J44CCXG4vL3ZhbHVl77ya5LqL5Lu25YC877yM6YCJ5aGr6aG577yM5pW05pWw5Z6L77yM55So5LqO5aGr5YaZ5omT5YiG5Z6L5LqL5Lu255qE5YiG5YC877yM5Yqg6L295pe26Ze05Z6L5LqL5Lu255qE5pe26ZW/77yM6K6i5Y2V5Z6L5LqL5Lu255qE5Lu35qC8562J562J44CCXG4vL25vZGVpZO+8mmRpduWFg+e0oGlk77yM6YCJ5aGr6aG577yM5aGr5YaZ572R6aG15Lit55qEZGl25YWD57SgaWTlgLzvvIznlKjkuo7lnKjigJznlKjmiLfop4bngrnigJ3lip/og73kuIrph43nu5jlhYPntKDnmoTkuovku7blj5HnlJ/mg4XlhrXjgIJcbmV4cG9ydCBkZWZhdWx0IHtcbiAgc2VuZDogZnVuY3Rpb24gKGNhdGVnb3J5LCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IGJhc2UuZXh0ZW5kKHtcbiAgICAgIGFjdGlvbjogdWFkZXRlY3Rvci5pc0RldmljZSgnbW9iaWxlJykgPyAndGFwJyA6ICdjbGljaycsXG4gICAgICBsYWJlbDogJycsXG4gICAgICB2YWx1ZTogJydcbiAgICB9LCBvcHRpb25zKTtcbiAgICBpZiAoX2N6YykgX2N6Yy5wdXNoKFtcIl90cmFja0V2ZW50XCIsIGNhdGVnb3J5LCBvcHRpb25zLmFjdGlvbiwgb3B0aW9ucy5sYWJlbCwgb3B0aW9ucy52YWx1ZV0pO1xuICB9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9FOi9naXRfcHJvL2V4cHJlc3Mtd2VicGFjay12dWUvc3JjL3V0aWwvU3RhdC5qcyJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ },
/* 26 */
/***/ function(module, exports, __webpack_require__) {

	eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;'use strict';\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\n/* Zepto 1.1.4 - zepto ajax assets callbacks data deferred detect event form fx_methods fx gesture ie selector stack touch - zeptojs.com/license */\n\nvar Zepto = function () {\n  var undefined,\n      key,\n      $,\n      classList,\n      emptyArray = [],\n      _slice = emptyArray.slice,\n      _filter = emptyArray.filter,\n      document = window.document,\n      elementDisplay = {},\n      classCache = {},\n      cssNumber = { 'column-count': 1, 'columns': 1, 'font-weight': 1, 'line-height': 1, 'opacity': 1, 'z-index': 1, 'zoom': 1 },\n      fragmentRE = /^\\s*<(\\w+|!)[^>]*>/,\n      singleTagRE = /^<(\\w+)\\s*\\/?>(?:<\\/\\1>|)$/,\n      tagExpanderRE = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\\w:]+)[^>]*)\\/>/ig,\n      rootNodeRE = /^(?:body|html)$/i,\n      capitalRE = /([A-Z])/g,\n\n\n  // special attributes that should be get/set via method calls\n  methodAttributes = ['val', 'css', 'html', 'text', 'data', 'width', 'height', 'offset'],\n      adjacencyOperators = ['after', 'prepend', 'before', 'append'],\n      table = document.createElement('table'),\n      tableRow = document.createElement('tr'),\n      containers = {\n    'tr': document.createElement('tbody'),\n    'tbody': table, 'thead': table, 'tfoot': table,\n    'td': tableRow, 'th': tableRow,\n    '*': document.createElement('div')\n  },\n      readyRE = /complete|loaded|interactive/,\n      simpleSelectorRE = /^[\\w-]*$/,\n      class2type = {},\n      toString = class2type.toString,\n      zepto = {},\n      camelize,\n      uniq,\n      tempParent = document.createElement('div'),\n      propMap = {\n    'tabindex': 'tabIndex',\n    'readonly': 'readOnly',\n    'for': 'htmlFor',\n    'class': 'className',\n    'maxlength': 'maxLength',\n    'cellspacing': 'cellSpacing',\n    'cellpadding': 'cellPadding',\n    'rowspan': 'rowSpan',\n    'colspan': 'colSpan',\n    'usemap': 'useMap',\n    'frameborder': 'frameBorder',\n    'contenteditable': 'contentEditable'\n  },\n      isArray = Array.isArray || function (object) {\n    return object instanceof Array;\n  };\n\n  zepto.matches = function (element, selector) {\n    if (!selector || !element || element.nodeType !== 1) return false;\n    var matchesSelector = element.webkitMatchesSelector || element.mozMatchesSelector || element.oMatchesSelector || element.matchesSelector;\n    if (matchesSelector) return matchesSelector.call(element, selector);\n    // fall back to performing a selector:\n    var match,\n        parent = element.parentNode,\n        temp = !parent;\n    if (temp) (parent = tempParent).appendChild(element);\n    match = ~zepto.qsa(parent, selector).indexOf(element);\n    temp && tempParent.removeChild(element);\n    return match;\n  };\n\n  function type(obj) {\n    return obj == null ? String(obj) : class2type[toString.call(obj)] || \"object\";\n  }\n\n  function isFunction(value) {\n    return type(value) == \"function\";\n  }\n  function isWindow(obj) {\n    return obj != null && obj == obj.window;\n  }\n  function isDocument(obj) {\n    return obj != null && obj.nodeType == obj.DOCUMENT_NODE;\n  }\n  function isObject(obj) {\n    return type(obj) == \"object\";\n  }\n  function isPlainObject(obj) {\n    return isObject(obj) && !isWindow(obj) && Object.getPrototypeOf(obj) == Object.prototype;\n  }\n  function likeArray(obj) {\n    return typeof obj.length == 'number';\n  }\n\n  function compact(array) {\n    return _filter.call(array, function (item) {\n      return item != null;\n    });\n  }\n  function flatten(array) {\n    return array.length > 0 ? $.fn.concat.apply([], array) : array;\n  }\n  camelize = function camelize(str) {\n    return str.replace(/-+(.)?/g, function (match, chr) {\n      return chr ? chr.toUpperCase() : '';\n    });\n  };\n  function dasherize(str) {\n    return str.replace(/::/g, '/').replace(/([A-Z]+)([A-Z][a-z])/g, '$1_$2').replace(/([a-z\\d])([A-Z])/g, '$1_$2').replace(/_/g, '-').toLowerCase();\n  }\n  uniq = function uniq(array) {\n    return _filter.call(array, function (item, idx) {\n      return array.indexOf(item) == idx;\n    });\n  };\n\n  function classRE(name) {\n    return name in classCache ? classCache[name] : classCache[name] = new RegExp('(^|\\\\s)' + name + '(\\\\s|$)');\n  }\n\n  function maybeAddPx(name, value) {\n    return typeof value == \"number\" && !cssNumber[dasherize(name)] ? value + \"px\" : value;\n  }\n\n  function defaultDisplay(nodeName) {\n    var element, display;\n    if (!elementDisplay[nodeName]) {\n      element = document.createElement(nodeName);\n      document.body.appendChild(element);\n      display = getComputedStyle(element, '').getPropertyValue(\"display\");\n      element.parentNode.removeChild(element);\n      display == \"none\" && (display = \"block\");\n      elementDisplay[nodeName] = display;\n    }\n    return elementDisplay[nodeName];\n  }\n\n  function _children(element) {\n    return 'children' in element ? _slice.call(element.children) : $.map(element.childNodes, function (node) {\n      if (node.nodeType == 1) return node;\n    });\n  }\n\n  // `$.zepto.fragment` takes a html string and an optional tag name\n  // to generate DOM nodes nodes from the given html string.\n  // The generated DOM nodes are returned as an array.\n  // This function can be overriden in plugins for example to make\n  // it compatible with browsers that don't support the DOM fully.\n  zepto.fragment = function (html, name, properties) {\n    var dom, nodes, container;\n\n    // A special case optimization for a single tag\n    if (singleTagRE.test(html)) dom = $(document.createElement(RegExp.$1));\n\n    if (!dom) {\n      if (html.replace) html = html.replace(tagExpanderRE, \"<$1></$2>\");\n      if (name === undefined) name = fragmentRE.test(html) && RegExp.$1;\n      if (!(name in containers)) name = '*';\n\n      container = containers[name];\n      container.innerHTML = '' + html;\n      dom = $.each(_slice.call(container.childNodes), function () {\n        container.removeChild(this);\n      });\n    }\n\n    if (isPlainObject(properties)) {\n      nodes = $(dom);\n      $.each(properties, function (key, value) {\n        if (methodAttributes.indexOf(key) > -1) nodes[key](value);else nodes.attr(key, value);\n      });\n    }\n\n    return dom;\n  };\n\n  // `$.zepto.Z` swaps out the prototype of the given `dom` array\n  // of nodes with `$.fn` and thus supplying all the Zepto functions\n  // to the array. Note that `__proto__` is not supported on Internet\n  // Explorer. This method can be overriden in plugins.\n  zepto.Z = function (dom, selector) {\n    dom = dom || [];\n    dom.__proto__ = $.fn;\n    dom.selector = selector || '';\n    return dom;\n  };\n\n  // `$.zepto.isZ` should return `true` if the given object is a Zepto\n  // collection. This method can be overriden in plugins.\n  zepto.isZ = function (object) {\n    return object instanceof zepto.Z;\n  };\n\n  // `$.zepto.init` is Zepto's counterpart to jQuery's `$.fn.init` and\n  // takes a CSS selector and an optional context (and handles various\n  // special cases).\n  // This method can be overriden in plugins.\n  zepto.init = function (selector, context) {\n    var dom;\n    // If nothing given, return an empty Zepto collection\n    if (!selector) return zepto.Z();\n    // Optimize for string selectors\n    else if (typeof selector == 'string') {\n        selector = selector.trim();\n        // If it's a html fragment, create nodes from it\n        // Note: In both Chrome 21 and Firefox 15, DOM error 12\n        // is thrown if the fragment doesn't begin with <\n        if (selector[0] == '<' && fragmentRE.test(selector)) dom = zepto.fragment(selector, RegExp.$1, context), selector = null;\n        // If there's a context, create a collection on that context first, and select\n        // nodes from there\n        else if (context !== undefined) return $(context).find(selector);\n          // If it's a CSS selector, use it to select nodes.\n          else dom = zepto.qsa(document, selector);\n      }\n      // If a function is given, call it when the DOM is ready\n      else if (isFunction(selector)) return $(document).ready(selector);\n        // If a Zepto collection is given, just return it\n        else if (zepto.isZ(selector)) return selector;else {\n            // normalize array if an array of nodes is given\n            if (isArray(selector)) dom = compact(selector);\n            // Wrap DOM nodes.\n            else if (isObject(selector)) dom = [selector], selector = null;\n              // If it's a html fragment, create nodes from it\n              else if (fragmentRE.test(selector)) dom = zepto.fragment(selector.trim(), RegExp.$1, context), selector = null;\n                // If there's a context, create a collection on that context first, and select\n                // nodes from there\n                else if (context !== undefined) return $(context).find(selector);\n                  // And last but no least, if it's a CSS selector, use it to select nodes.\n                  else dom = zepto.qsa(document, selector);\n          }\n    // create a new Zepto collection from the nodes found\n    return zepto.Z(dom, selector);\n  };\n\n  // `$` will be the base `Zepto` object. When calling this\n  // function just call `$.zepto.init, which makes the implementation\n  // details of selecting nodes and creating Zepto collections\n  // patchable in plugins.\n  $ = function $(selector, context) {\n    return zepto.init(selector, context);\n  };\n\n  function extend(target, source, deep) {\n    for (key in source) {\n      if (deep && (isPlainObject(source[key]) || isArray(source[key]))) {\n        if (isPlainObject(source[key]) && !isPlainObject(target[key])) target[key] = {};\n        if (isArray(source[key]) && !isArray(target[key])) target[key] = [];\n        extend(target[key], source[key], deep);\n      } else if (source[key] !== undefined) target[key] = source[key];\n    }\n  }\n\n  // Copy all but undefined properties from one or more\n  // objects to the `target` object.\n  $.extend = function (target) {\n    var deep,\n        args = _slice.call(arguments, 1);\n    if (typeof target == 'boolean') {\n      deep = target;\n      target = args.shift();\n    }\n    args.forEach(function (arg) {\n      extend(target, arg, deep);\n    });\n    return target;\n  };\n\n  // `$.zepto.qsa` is Zepto's CSS selector implementation which\n  // uses `document.querySelectorAll` and optimizes for some special cases, like `#id`.\n  // This method can be overriden in plugins.\n  zepto.qsa = function (element, selector) {\n    var found,\n        maybeID = selector[0] == '#',\n        maybeClass = !maybeID && selector[0] == '.',\n        nameOnly = maybeID || maybeClass ? selector.slice(1) : selector,\n        // Ensure that a 1 char tag name still gets checked\n    isSimple = simpleSelectorRE.test(nameOnly);\n    return isDocument(element) && isSimple && maybeID ? (found = element.getElementById(nameOnly)) ? [found] : [] : element.nodeType !== 1 && element.nodeType !== 9 ? [] : _slice.call(isSimple && !maybeID ? maybeClass ? element.getElementsByClassName(nameOnly) : // If it's simple, it could be a class\n    element.getElementsByTagName(selector) : // Or a tag\n    element.querySelectorAll(selector) // Or it's not simple, and we need to query all\n    );\n  };\n\n  function filtered(nodes, selector) {\n    return selector == null ? $(nodes) : $(nodes).filter(selector);\n  }\n\n  $.contains = document.documentElement.contains ? function (parent, node) {\n    return parent !== node && parent.contains(node);\n  } : function (parent, node) {\n    while (node && (node = node.parentNode)) {\n      if (node === parent) return true;\n    }return false;\n  };\n\n  function funcArg(context, arg, idx, payload) {\n    return isFunction(arg) ? arg.call(context, idx, payload) : arg;\n  }\n\n  function setAttribute(node, name, value) {\n    value == null ? node.removeAttribute(name) : node.setAttribute(name, value);\n  }\n\n  // access className property while respecting SVGAnimatedString\n  function className(node, value) {\n    var klass = node.className || '',\n        svg = klass && klass.baseVal !== undefined;\n\n    if (value === undefined) return svg ? klass.baseVal : klass;\n    svg ? klass.baseVal = value : node.className = value;\n  }\n\n  // \"true\"  => true\n  // \"false\" => false\n  // \"null\"  => null\n  // \"42\"    => 42\n  // \"42.5\"  => 42.5\n  // \"08\"    => \"08\"\n  // JSON    => parse if valid\n  // String  => self\n  function deserializeValue(value) {\n    var num;\n    try {\n      return value ? value == \"true\" || (value == \"false\" ? false : value == \"null\" ? null : !/^0/.test(value) && !isNaN(num = Number(value)) ? num : /^[\\[\\{]/.test(value) ? $.parseJSON(value) : value) : value;\n    } catch (e) {\n      return value;\n    }\n  }\n\n  $.type = type;\n  $.isFunction = isFunction;\n  $.isWindow = isWindow;\n  $.isArray = isArray;\n  $.isPlainObject = isPlainObject;\n  $.isObject = isObject; //这个原本木有的 俺加的!!\n\n  $.isEmptyObject = function (obj) {\n    var name;\n    for (name in obj) {\n      return false;\n    }return true;\n  };\n\n  $.inArray = function (elem, array, i) {\n    return emptyArray.indexOf.call(array, elem, i);\n  };\n\n  $.camelCase = camelize;\n  $.trim = function (str) {\n    return str == null ? \"\" : String.prototype.trim.call(str);\n  };\n\n  // plugin compatibility\n  $.uuid = 0;\n  $.support = {};\n  $.expr = {};\n\n  $.map = function (elements, callback) {\n    var value,\n        values = [],\n        i,\n        key;\n    if (likeArray(elements)) for (i = 0; i < elements.length; i++) {\n      value = callback(elements[i], i);\n      if (value != null) values.push(value);\n    } else for (key in elements) {\n      value = callback(elements[key], key);\n      if (value != null) values.push(value);\n    }\n    return flatten(values);\n  };\n\n  $.each = function (elements, callback) {\n    var i, key;\n    if (likeArray(elements)) {\n      for (i = 0; i < elements.length; i++) {\n        if (callback.call(elements[i], i, elements[i]) === false) return elements;\n      }\n    } else {\n      for (key in elements) {\n        if (callback.call(elements[key], key, elements[key]) === false) return elements;\n      }\n    }\n\n    return elements;\n  };\n\n  $.grep = function (elements, callback) {\n    return _filter.call(elements, callback);\n  };\n\n  if (window.JSON) $.parseJSON = JSON.parse;\n\n  // Populate the class2type map\n  $.each(\"Boolean Number String Function Array Date RegExp Object Error\".split(\" \"), function (i, name) {\n    class2type[\"[object \" + name + \"]\"] = name.toLowerCase();\n  });\n\n  // Define methods that will be available on all\n  // Zepto collections\n  $.fn = {\n    // Because a collection acts like an array\n    // copy over these useful array functions.\n    forEach: emptyArray.forEach,\n    reduce: emptyArray.reduce,\n    push: emptyArray.push,\n    sort: emptyArray.sort,\n    indexOf: emptyArray.indexOf,\n    concat: emptyArray.concat,\n\n    // `map` and `slice` in the jQuery API work differently\n    // from their array counterparts\n    map: function map(fn) {\n      return $($.map(this, function (el, i) {\n        return fn.call(el, i, el);\n      }));\n    },\n    slice: function slice() {\n      return $(_slice.apply(this, arguments));\n    },\n\n    ready: function ready(callback) {\n      // need to check if document.body exists for IE as that browser reports\n      // document ready when it hasn't yet created the body element\n      if (readyRE.test(document.readyState) && document.body) callback($);else document.addEventListener('DOMContentLoaded', function () {\n        callback($);\n      }, false);\n      return this;\n    },\n    get: function get(idx) {\n      return idx === undefined ? _slice.call(this) : this[idx >= 0 ? idx : idx + this.length];\n    },\n    toArray: function toArray() {\n      return this.get();\n    },\n    size: function size() {\n      return this.length;\n    },\n    remove: function remove() {\n      return this.each(function () {\n        if (this.parentNode != null) this.parentNode.removeChild(this);\n      });\n    },\n    each: function each(callback) {\n      emptyArray.every.call(this, function (el, idx) {\n        return callback.call(el, idx, el) !== false;\n      });\n      return this;\n    },\n    filter: function filter(selector) {\n      if (isFunction(selector)) return this.not(this.not(selector));\n      return $(_filter.call(this, function (element) {\n        return zepto.matches(element, selector);\n      }));\n    },\n    add: function add(selector, context) {\n      return $(uniq(this.concat($(selector, context))));\n    },\n    is: function is(selector) {\n      return this.length > 0 && zepto.matches(this[0], selector);\n    },\n    not: function not(selector) {\n      var nodes = [];\n      if (isFunction(selector) && selector.call !== undefined) this.each(function (idx) {\n        if (!selector.call(this, idx)) nodes.push(this);\n      });else {\n        var excludes = typeof selector == 'string' ? this.filter(selector) : likeArray(selector) && isFunction(selector.item) ? _slice.call(selector) : $(selector);\n        this.forEach(function (el) {\n          if (excludes.indexOf(el) < 0) nodes.push(el);\n        });\n      }\n      return $(nodes);\n    },\n    has: function has(selector) {\n      return this.filter(function () {\n        return isObject(selector) ? $.contains(this, selector) : $(this).find(selector).size();\n      });\n    },\n    eq: function eq(idx) {\n      return idx === -1 ? this.slice(idx) : this.slice(idx, +idx + 1);\n    },\n    first: function first() {\n      var el = this[0];\n      return el && !isObject(el) ? el : $(el);\n    },\n    last: function last() {\n      var el = this[this.length - 1];\n      return el && !isObject(el) ? el : $(el);\n    },\n    find: function find(selector) {\n      var result,\n          $this = this;\n      if (!selector) result = [];else if ((typeof selector === 'undefined' ? 'undefined' : _typeof(selector)) == 'object') result = $(selector).filter(function () {\n        var node = this;\n        return emptyArray.some.call($this, function (parent) {\n          return $.contains(parent, node);\n        });\n      });else if (this.length == 1) result = $(zepto.qsa(this[0], selector));else result = this.map(function () {\n        return zepto.qsa(this, selector);\n      });\n      return result;\n    },\n    closest: function closest(selector, context) {\n      var node = this[0],\n          collection = false;\n      if ((typeof selector === 'undefined' ? 'undefined' : _typeof(selector)) == 'object') collection = $(selector);\n      while (node && !(collection ? collection.indexOf(node) >= 0 : zepto.matches(node, selector))) {\n        node = node !== context && !isDocument(node) && node.parentNode;\n      }return $(node);\n    },\n    parents: function parents(selector) {\n      var ancestors = [],\n          nodes = this;\n      while (nodes.length > 0) {\n        nodes = $.map(nodes, function (node) {\n          if ((node = node.parentNode) && !isDocument(node) && ancestors.indexOf(node) < 0) {\n            ancestors.push(node);\n            return node;\n          }\n        });\n      }return filtered(ancestors, selector);\n    },\n    parent: function parent(selector) {\n      return filtered(uniq(this.pluck('parentNode')), selector);\n    },\n    children: function children(selector) {\n      return filtered(this.map(function () {\n        return _children(this);\n      }), selector);\n    },\n    contents: function contents() {\n      return this.map(function () {\n        return _slice.call(this.childNodes);\n      });\n    },\n    siblings: function siblings(selector) {\n      return filtered(this.map(function (i, el) {\n        return _filter.call(_children(el.parentNode), function (child) {\n          return child !== el;\n        });\n      }), selector);\n    },\n    empty: function empty() {\n      return this.each(function () {\n        this.innerHTML = '';\n      });\n    },\n    // `pluck` is borrowed from Prototype.js\n    pluck: function pluck(property) {\n      return $.map(this, function (el) {\n        return el[property];\n      });\n    },\n    show: function show() {\n      return this.each(function () {\n        this.style.display == \"none\" && (this.style.display = '');\n        if (getComputedStyle(this, '').getPropertyValue(\"display\") == \"none\") this.style.display = defaultDisplay(this.nodeName);\n      });\n    },\n    replaceWith: function replaceWith(newContent) {\n      return this.before(newContent).remove();\n    },\n    wrap: function wrap(structure) {\n      var func = isFunction(structure);\n      if (this[0] && !func) var dom = $(structure).get(0),\n          clone = dom.parentNode || this.length > 1;\n\n      return this.each(function (index) {\n        $(this).wrapAll(func ? structure.call(this, index) : clone ? dom.cloneNode(true) : dom);\n      });\n    },\n    wrapAll: function wrapAll(structure) {\n      if (this[0]) {\n        $(this[0]).before(structure = $(structure));\n        var children;\n        // drill down to the inmost element\n        while ((children = structure.children()).length) {\n          structure = children.first();\n        }$(structure).append(this);\n      }\n      return this;\n    },\n    wrapInner: function wrapInner(structure) {\n      var func = isFunction(structure);\n      return this.each(function (index) {\n        var self = $(this),\n            contents = self.contents(),\n            dom = func ? structure.call(this, index) : structure;\n        contents.length ? contents.wrapAll(dom) : self.append(dom);\n      });\n    },\n    unwrap: function unwrap() {\n      this.parent().each(function () {\n        $(this).replaceWith($(this).children());\n      });\n      return this;\n    },\n    clone: function clone() {\n      return this.map(function () {\n        return this.cloneNode(true);\n      });\n    },\n    hide: function hide() {\n      return this.css(\"display\", \"none\");\n    },\n    toggle: function toggle(setting) {\n      return this.each(function () {\n        var el = $(this);(setting === undefined ? el.css(\"display\") == \"none\" : setting) ? el.show() : el.hide();\n      });\n    },\n    prev: function prev(selector) {\n      return $(this.pluck('previousElementSibling')).filter(selector || '*');\n    },\n    next: function next(selector) {\n      return $(this.pluck('nextElementSibling')).filter(selector || '*');\n    },\n    html: function html(_html) {\n      return 0 in arguments ? this.each(function (idx) {\n        var originHtml = this.innerHTML;\n        $(this).empty().append(funcArg(this, _html, idx, originHtml));\n      }) : 0 in this ? this[0].innerHTML : null;\n    },\n    text: function text(_text) {\n      return 0 in arguments ? this.each(function (idx) {\n        var newText = funcArg(this, _text, idx, this.textContent);\n        this.textContent = newText == null ? '' : '' + newText;\n      }) : 0 in this ? this[0].textContent : null;\n    },\n    attr: function attr(name, value) {\n      var result;\n      return typeof name == 'string' && !(1 in arguments) ? !this.length || this[0].nodeType !== 1 ? undefined : !(result = this[0].getAttribute(name)) && name in this[0] ? this[0][name] : result : this.each(function (idx) {\n        if (this.nodeType !== 1) return;\n        if (isObject(name)) for (key in name) {\n          setAttribute(this, key, name[key]);\n        } else setAttribute(this, name, funcArg(this, value, idx, this.getAttribute(name)));\n      });\n    },\n    removeAttr: function removeAttr(name) {\n      return this.each(function () {\n        this.nodeType === 1 && setAttribute(this, name);\n      });\n    },\n    prop: function prop(name, value) {\n      name = propMap[name] || name;\n      return 1 in arguments ? this.each(function (idx) {\n        this[name] = funcArg(this, value, idx, this[name]);\n      }) : this[0] && this[0][name];\n    },\n    data: function data(name, value) {\n      var attrName = 'data-' + name.replace(capitalRE, '-$1').toLowerCase();\n\n      var data = 1 in arguments ? this.attr(attrName, value) : this.attr(attrName);\n\n      return data !== null ? deserializeValue(data) : undefined;\n    },\n    val: function val(value) {\n      return 0 in arguments ? this.each(function (idx) {\n        this.value = funcArg(this, value, idx, this.value);\n      }) : this[0] && (this[0].multiple ? $(this[0]).find('option').filter(function () {\n        return this.selected;\n      }).pluck('value') : this[0].value);\n    },\n    offset: function offset(coordinates) {\n      if (coordinates) return this.each(function (index) {\n        var $this = $(this),\n            coords = funcArg(this, coordinates, index, $this.offset()),\n            parentOffset = $this.offsetParent().offset(),\n            props = {\n          top: coords.top - parentOffset.top,\n          left: coords.left - parentOffset.left\n        };\n\n        if ($this.css('position') == 'static') props['position'] = 'relative';\n        $this.css(props);\n      });\n      if (!this.length) return null;\n      var obj = this[0].getBoundingClientRect();\n      return {\n        left: obj.left + window.pageXOffset,\n        top: obj.top + window.pageYOffset,\n        width: Math.round(obj.width),\n        height: Math.round(obj.height)\n      };\n    },\n    css: function css(property, value) {\n      if (arguments.length < 2) {\n        var element = this[0],\n            computedStyle = getComputedStyle(element, '');\n        if (!element) return;\n        if (typeof property == 'string') return element.style[camelize(property)] || computedStyle.getPropertyValue(property);else if (isArray(property)) {\n          var props = {};\n          $.each(property, function (_, prop) {\n            props[prop] = element.style[camelize(prop)] || computedStyle.getPropertyValue(prop);\n          });\n          return props;\n        }\n      }\n\n      var css = '';\n      if (type(property) == 'string') {\n        if (!value && value !== 0) this.each(function () {\n          this.style.removeProperty(dasherize(property));\n        });else css = dasherize(property) + \":\" + maybeAddPx(property, value);\n      } else {\n        for (key in property) {\n          if (!property[key] && property[key] !== 0) this.each(function () {\n            this.style.removeProperty(dasherize(key));\n          });else css += dasherize(key) + ':' + maybeAddPx(key, property[key]) + ';';\n        }\n      }\n\n      return this.each(function () {\n        this.style.cssText += ';' + css;\n      });\n    },\n    index: function index(element) {\n      return element ? this.indexOf($(element)[0]) : this.parent().children().indexOf(this[0]);\n    },\n    hasClass: function hasClass(name) {\n      if (!name) return false;\n      return emptyArray.some.call(this, function (el) {\n        return this.test(className(el));\n      }, classRE(name));\n    },\n    addClass: function addClass(name) {\n      if (!name) return this;\n      return this.each(function (idx) {\n        if (!('className' in this)) return;\n        classList = [];\n        var cls = className(this),\n            newName = funcArg(this, name, idx, cls);\n        newName.split(/\\s+/g).forEach(function (klass) {\n          if (!$(this).hasClass(klass)) classList.push(klass);\n        }, this);\n        classList.length && className(this, cls + (cls ? \" \" : \"\") + classList.join(\" \"));\n      });\n    },\n    removeClass: function removeClass(name) {\n      return this.each(function (idx) {\n        if (!('className' in this)) return;\n        if (name === undefined) return className(this, '');\n        classList = className(this);\n        funcArg(this, name, idx, classList).split(/\\s+/g).forEach(function (klass) {\n          classList = classList.replace(classRE(klass), \" \");\n        });\n        className(this, classList.trim());\n      });\n    },\n    toggleClass: function toggleClass(name, when) {\n      if (!name) return this;\n      return this.each(function (idx) {\n        var $this = $(this),\n            names = funcArg(this, name, idx, className(this));\n        names.split(/\\s+/g).forEach(function (klass) {\n          (when === undefined ? !$this.hasClass(klass) : when) ? $this.addClass(klass) : $this.removeClass(klass);\n        });\n      });\n    },\n    scrollTop: function scrollTop(value) {\n      if (!this.length) return;\n      var hasScrollTop = 'scrollTop' in this[0];\n      if (value === undefined) return hasScrollTop ? this[0].scrollTop : this[0].pageYOffset;\n      return this.each(hasScrollTop ? function () {\n        this.scrollTop = value;\n      } : function () {\n        this.scrollTo(this.scrollX, value);\n      });\n    },\n    scrollLeft: function scrollLeft(value) {\n      if (!this.length) return;\n      var hasScrollLeft = 'scrollLeft' in this[0];\n      if (value === undefined) return hasScrollLeft ? this[0].scrollLeft : this[0].pageXOffset;\n      return this.each(hasScrollLeft ? function () {\n        this.scrollLeft = value;\n      } : function () {\n        this.scrollTo(value, this.scrollY);\n      });\n    },\n    position: function position() {\n      if (!this.length) return;\n\n      var elem = this[0],\n\n      // Get *real* offsetParent\n      offsetParent = this.offsetParent(),\n\n      // Get correct offsets\n      offset = this.offset(),\n          parentOffset = rootNodeRE.test(offsetParent[0].nodeName) ? { top: 0, left: 0 } : offsetParent.offset();\n\n      // Subtract element margins\n      // note: when an element has margin: auto the offsetLeft and marginLeft\n      // are the same in Safari causing offset.left to incorrectly be 0\n      offset.top -= parseFloat($(elem).css('margin-top')) || 0;\n      offset.left -= parseFloat($(elem).css('margin-left')) || 0;\n\n      // Add offsetParent borders\n      parentOffset.top += parseFloat($(offsetParent[0]).css('border-top-width')) || 0;\n      parentOffset.left += parseFloat($(offsetParent[0]).css('border-left-width')) || 0;\n\n      // Subtract the two offsets\n      return {\n        top: offset.top - parentOffset.top,\n        left: offset.left - parentOffset.left\n      };\n    },\n    offsetParent: function offsetParent() {\n      return this.map(function () {\n        var parent = this.offsetParent || document.body;\n        while (parent && !rootNodeRE.test(parent.nodeName) && $(parent).css(\"position\") == \"static\") {\n          parent = parent.offsetParent;\n        }return parent;\n      });\n    }\n  };\n\n  // for now\n  $.fn.detach = $.fn.remove\n\n  // Generate the `width` and `height` functions\n  ;['width', 'height'].forEach(function (dimension) {\n    var dimensionProperty = dimension.replace(/./, function (m) {\n      return m[0].toUpperCase();\n    });\n\n    $.fn[dimension] = function (value) {\n      var offset,\n          el = this[0];\n      if (value === undefined) return isWindow(el) ? el['inner' + dimensionProperty] : isDocument(el) ? el.documentElement['scroll' + dimensionProperty] : (offset = this.offset()) && offset[dimension];else return this.each(function (idx) {\n        el = $(this);\n        el.css(dimension, funcArg(this, value, idx, el[dimension]()));\n      });\n    };\n  });\n\n  function traverseNode(node, fun) {\n    fun(node);\n    for (var i = 0, len = node.childNodes.length; i < len; i++) {\n      traverseNode(node.childNodes[i], fun);\n    }\n  }\n\n  // Generate the `after`, `prepend`, `before`, `append`,\n  // `insertAfter`, `insertBefore`, `appendTo`, and `prependTo` methods.\n  adjacencyOperators.forEach(function (operator, operatorIndex) {\n    var inside = operatorIndex % 2; //=> prepend, append\n\n    $.fn[operator] = function () {\n      // arguments can be nodes, arrays of nodes, Zepto objects and HTML strings\n      var argType,\n          nodes = $.map(arguments, function (arg) {\n        argType = type(arg);\n        return argType == \"object\" || argType == \"array\" || arg == null ? arg : zepto.fragment(arg);\n      }),\n          parent,\n          copyByClone = this.length > 1;\n      if (nodes.length < 1) return this;\n\n      return this.each(function (_, target) {\n        parent = inside ? target : target.parentNode;\n\n        // convert all methods to a \"before\" operation\n        target = operatorIndex == 0 ? target.nextSibling : operatorIndex == 1 ? target.firstChild : operatorIndex == 2 ? target : null;\n\n        var parentInDocument = $.contains(document.documentElement, parent);\n\n        nodes.forEach(function (node) {\n          if (copyByClone) node = node.cloneNode(true);else if (!parent) return $(node).remove();\n\n          parent.insertBefore(node, target);\n          if (parentInDocument) traverseNode(node, function (el) {\n            if (el.nodeName != null && el.nodeName.toUpperCase() === 'SCRIPT' && (!el.type || el.type === 'text/javascript') && !el.src) window['eval'].call(window, el.innerHTML);\n          });\n        });\n      });\n    };\n\n    // after    => insertAfter\n    // prepend  => prependTo\n    // before   => insertBefore\n    // append   => appendTo\n    $.fn[inside ? operator + 'To' : 'insert' + (operatorIndex ? 'Before' : 'After')] = function (html) {\n      $(html)[operator](this);\n      return this;\n    };\n  });\n\n  zepto.Z.prototype = $.fn;\n\n  // Export internal API functions in the `$.zepto` namespace\n  zepto.uniq = uniq;\n  zepto.deserializeValue = deserializeValue;\n  $.zepto = zepto;\n\n  return $;\n}();\n\nwindow.Zepto = Zepto;\nwindow.$ === undefined && (window.$ = Zepto);(function ($) {\n  var jsonpID = 0,\n      document = window.document,\n      key,\n      name,\n      rscript = /<script\\b[^<]*(?:(?!<\\/script>)<[^<]*)*<\\/script>/gi,\n      scriptTypeRE = /^(?:text|application)\\/javascript/i,\n      xmlTypeRE = /^(?:text|application)\\/xml/i,\n      jsonType = 'application/json',\n      htmlType = 'text/html',\n      blankRE = /^\\s*$/;\n\n  // trigger a custom event and return false if it was cancelled\n  function triggerAndReturn(context, eventName, data) {\n    var event = $.Event(eventName);\n    $(context).trigger(event, data);\n    return !event.isDefaultPrevented();\n  }\n\n  // trigger an Ajax \"global\" event\n  function triggerGlobal(settings, context, eventName, data) {\n    if (settings.global) return triggerAndReturn(context || document, eventName, data);\n  }\n\n  // Number of active Ajax requests\n  $.active = 0;\n\n  function ajaxStart(settings) {\n    if (settings.global && $.active++ === 0) triggerGlobal(settings, null, 'ajaxStart');\n  }\n  function ajaxStop(settings) {\n    if (settings.global && ! --$.active) triggerGlobal(settings, null, 'ajaxStop');\n  }\n\n  // triggers an extra global event \"ajaxBeforeSend\" that's like \"ajaxSend\" but cancelable\n  function ajaxBeforeSend(xhr, settings) {\n    var context = settings.context;\n    if (settings.beforeSend.call(context, xhr, settings) === false || triggerGlobal(settings, context, 'ajaxBeforeSend', [xhr, settings]) === false) return false;\n\n    triggerGlobal(settings, context, 'ajaxSend', [xhr, settings]);\n  }\n  function ajaxSuccess(data, xhr, settings, deferred) {\n    var context = settings.context,\n        status = 'success';\n    settings.success.call(context, data, status, xhr);\n    if (deferred) deferred.resolveWith(context, [data, status, xhr]);\n    triggerGlobal(settings, context, 'ajaxSuccess', [xhr, settings, data]);\n    ajaxComplete(status, xhr, settings);\n  }\n  // type: \"timeout\", \"error\", \"abort\", \"parsererror\"\n  function ajaxError(error, type, xhr, settings, deferred) {\n    var context = settings.context;\n    settings.error.call(context, xhr, type, error);\n    if (deferred) deferred.rejectWith(context, [xhr, type, error]);\n    triggerGlobal(settings, context, 'ajaxError', [xhr, settings, error || type]);\n    ajaxComplete(type, xhr, settings);\n  }\n  // status: \"success\", \"notmodified\", \"error\", \"timeout\", \"abort\", \"parsererror\"\n  function ajaxComplete(status, xhr, settings) {\n    var context = settings.context;\n    settings.complete.call(context, xhr, status);\n    triggerGlobal(settings, context, 'ajaxComplete', [xhr, settings]);\n    ajaxStop(settings);\n  }\n\n  // Empty function, used as default callback\n  function empty() {}\n\n  $.ajaxJSONP = function (options, deferred) {\n    if (!('type' in options)) return $.ajax(options);\n\n    var _callbackName = options.jsonpCallback,\n        callbackName = ($.isFunction(_callbackName) ? _callbackName() : _callbackName) || 'jsonp' + ++jsonpID,\n        script = document.createElement('script'),\n        originalCallback = window[callbackName],\n        responseData,\n        abort = function abort(errorType) {\n      $(script).triggerHandler('error', errorType || 'abort');\n    },\n        xhr = { abort: abort },\n        abortTimeout;\n\n    if (deferred) deferred.promise(xhr);\n\n    $(script).on('load error', function (e, errorType) {\n      clearTimeout(abortTimeout);\n      $(script).off().remove();\n\n      if (e.type == 'error' || !responseData) {\n        ajaxError(null, errorType || 'error', xhr, options, deferred);\n      } else {\n        ajaxSuccess(responseData[0], xhr, options, deferred);\n      }\n\n      window[callbackName] = originalCallback;\n      if (responseData && $.isFunction(originalCallback)) originalCallback(responseData[0]);\n\n      originalCallback = responseData = undefined;\n    });\n\n    if (ajaxBeforeSend(xhr, options) === false) {\n      abort('abort');\n      return xhr;\n    }\n\n    window[callbackName] = function () {\n      responseData = arguments;\n    };\n\n    script.src = options.url.replace(/\\?(.+)=\\?/, '?$1=' + callbackName);\n    document.head.appendChild(script);\n\n    if (options.timeout > 0) abortTimeout = setTimeout(function () {\n      abort('timeout');\n    }, options.timeout);\n\n    return xhr;\n  };\n\n  $.ajaxSettings = {\n    // Default type of request\n    type: 'GET',\n    // Callback that is executed before request\n    beforeSend: empty,\n    // Callback that is executed if the request succeeds\n    success: empty,\n    // Callback that is executed the the server drops error\n    error: empty,\n    // Callback that is executed on request complete (both: error and success)\n    complete: empty,\n    // The context for the callbacks\n    context: null,\n    // Whether to trigger \"global\" Ajax events\n    global: true,\n    // Transport\n    xhr: function xhr() {\n      return new window.XMLHttpRequest();\n    },\n    // MIME types mapping\n    // IIS returns Javascript as \"application/x-javascript\"\n    accepts: {\n      script: 'text/javascript, application/javascript, application/x-javascript',\n      json: jsonType,\n      xml: 'application/xml, text/xml',\n      html: htmlType,\n      text: 'text/plain'\n    },\n    // Whether the request is to another domain\n    crossDomain: false,\n    // Default timeout\n    timeout: 0,\n    // Whether data should be serialized to string\n    processData: true,\n    // Whether the browser should be allowed to cache GET responses\n    cache: true\n  };\n\n  function mimeToDataType(mime) {\n    if (mime) mime = mime.split(';', 2)[0];\n    return mime && (mime == htmlType ? 'html' : mime == jsonType ? 'json' : scriptTypeRE.test(mime) ? 'script' : xmlTypeRE.test(mime) && 'xml') || 'text';\n  }\n\n  function appendQuery(url, query) {\n    if (query == '') return url;\n    return (url + '&' + query).replace(/[&?]{1,2}/, '?');\n  }\n\n  // serialize payload and append it to the URL for GET requests\n  function serializeData(options) {\n    if (options.processData && options.data && $.type(options.data) != \"string\") options.data = $.param(options.data, options.traditional);\n    if (options.data && (!options.type || options.type.toUpperCase() == 'GET')) options.url = appendQuery(options.url, options.data), options.data = undefined;\n  }\n\n  $.ajax = function (options) {\n    var settings = $.extend({}, options || {}),\n        deferred = $.Deferred && $.Deferred();\n    for (key in $.ajaxSettings) {\n      if (settings[key] === undefined) settings[key] = $.ajaxSettings[key];\n    }ajaxStart(settings);\n\n    if (!settings.crossDomain) settings.crossDomain = /^([\\w-]+:)?\\/\\/([^\\/]+)/.test(settings.url) && RegExp.$2 != window.location.host;\n\n    if (!settings.url) settings.url = window.location.toString();\n    serializeData(settings);\n\n    var dataType = settings.dataType,\n        hasPlaceholder = /\\?.+=\\?/.test(settings.url);\n    if (hasPlaceholder) dataType = 'jsonp';\n\n    if (settings.cache === false || (!options || options.cache !== true) && ('script' == dataType || 'jsonp' == dataType)) settings.url = appendQuery(settings.url, '_=' + Date.now());\n\n    if ('jsonp' == dataType) {\n      if (!hasPlaceholder) settings.url = appendQuery(settings.url, settings.jsonp ? settings.jsonp + '=?' : settings.jsonp === false ? '' : 'callback=?');\n      return $.ajaxJSONP(settings, deferred);\n    }\n\n    var mime = settings.accepts[dataType],\n        headers = {},\n        setHeader = function setHeader(name, value) {\n      headers[name.toLowerCase()] = [name, value];\n    },\n        protocol = /^([\\w-]+:)\\/\\//.test(settings.url) ? RegExp.$1 : window.location.protocol,\n        xhr = settings.xhr(),\n        nativeSetHeader = xhr.setRequestHeader,\n        abortTimeout;\n\n    if (deferred) deferred.promise(xhr);\n\n    if (!settings.crossDomain) setHeader('X-Requested-With', 'XMLHttpRequest');\n    setHeader('Accept', mime || '*/*');\n    if (mime = settings.mimeType || mime) {\n      if (mime.indexOf(',') > -1) mime = mime.split(',', 2)[0];\n      xhr.overrideMimeType && xhr.overrideMimeType(mime);\n    }\n    if (settings.contentType || settings.contentType !== false && settings.data && settings.type.toUpperCase() != 'GET') setHeader('Content-Type', settings.contentType || 'application/x-www-form-urlencoded');\n\n    if (settings.headers) for (name in settings.headers) {\n      setHeader(name, settings.headers[name]);\n    }xhr.setRequestHeader = setHeader;\n\n    xhr.onreadystatechange = function () {\n      if (xhr.readyState == 4) {\n        xhr.onreadystatechange = empty;\n        clearTimeout(abortTimeout);\n        var result,\n            error = false;\n        if (xhr.status >= 200 && xhr.status < 300 || xhr.status == 304 || xhr.status == 0 && protocol == 'file:') {\n          dataType = dataType || mimeToDataType(settings.mimeType || xhr.getResponseHeader('content-type'));\n          result = xhr.responseText;\n\n          try {\n            // http://perfectionkills.com/global-eval-what-are-the-options/\n            if (dataType == 'script') (1, eval)(result);else if (dataType == 'xml') result = xhr.responseXML;else if (dataType == 'json') result = blankRE.test(result) ? null : $.parseJSON(result);\n          } catch (e) {\n            error = e;\n          }\n\n          if (error) ajaxError(error, 'parsererror', xhr, settings, deferred);else ajaxSuccess(result, xhr, settings, deferred);\n        } else {\n          ajaxError(xhr.statusText || null, xhr.status ? 'error' : 'abort', xhr, settings, deferred);\n        }\n      }\n    };\n\n    if (ajaxBeforeSend(xhr, settings) === false) {\n      xhr.abort();\n      ajaxError(null, 'abort', xhr, settings, deferred);\n      return xhr;\n    }\n\n    if (settings.xhrFields) for (name in settings.xhrFields) {\n      xhr[name] = settings.xhrFields[name];\n    }var async = 'async' in settings ? settings.async : true;\n    xhr.open(settings.type, settings.url, async, settings.username, settings.password);\n\n    for (name in headers) {\n      nativeSetHeader.apply(xhr, headers[name]);\n    }if (settings.timeout > 0) abortTimeout = setTimeout(function () {\n      xhr.onreadystatechange = empty;\n      xhr.abort();\n      ajaxError(null, 'timeout', xhr, settings, deferred);\n    }, settings.timeout);\n\n    // avoid sending empty string (#319)\n    xhr.send(settings.data ? settings.data : null);\n    return xhr;\n  };\n\n  // handle optional data/success arguments\n  function parseArguments(url, data, success, dataType) {\n    if ($.isFunction(data)) dataType = success, success = data, data = undefined;\n    if (!$.isFunction(success)) dataType = success, success = undefined;\n    return {\n      url: url,\n      data: data,\n      success: success,\n      dataType: dataType\n    };\n  }\n\n  $.get = function () /* url, data, success, dataType */{\n    return $.ajax(parseArguments.apply(null, arguments));\n  };\n\n  $.post = function () /* url, data, success, dataType */{\n    var options = parseArguments.apply(null, arguments);\n    options.type = 'POST';\n    return $.ajax(options);\n  };\n\n  $.getJSON = function () /* url, data, success */{\n    var options = parseArguments.apply(null, arguments);\n    options.dataType = 'json';\n    return $.ajax(options);\n  };\n\n  $.fn.load = function (url, data, success) {\n    if (!this.length) return this;\n    var self = this,\n        parts = url.split(/\\s/),\n        selector,\n        options = parseArguments(url, data, success),\n        callback = options.success;\n    if (parts.length > 1) options.url = parts[0], selector = parts[1];\n    options.success = function (response) {\n      self.html(selector ? $('<div>').html(response.replace(rscript, \"\")).find(selector) : response);\n      callback && callback.apply(self, arguments);\n    };\n    $.ajax(options);\n    return this;\n  };\n\n  var escape = encodeURIComponent;\n\n  function serialize(params, obj, traditional, scope) {\n    var type,\n        array = $.isArray(obj),\n        hash = $.isPlainObject(obj);\n    $.each(obj, function (key, value) {\n      type = $.type(value);\n      if (scope) key = traditional ? scope : scope + '[' + (hash || type == 'object' || type == 'array' ? key : '') + ']';\n      // handle data in serializeArray() format\n      if (!scope && array) params.add(value.name, value.value);\n      // recurse into nested objects\n      else if (type == \"array\" || !traditional && type == \"object\") serialize(params, value, traditional, key);else params.add(key, value);\n    });\n  }\n\n  $.param = function (obj, traditional) {\n    var params = [];\n    params.add = function (k, v) {\n      this.push(escape(k) + '=' + escape(v));\n    };\n    serialize(params, obj, traditional);\n    return params.join('&').replace(/%20/g, '+');\n  };\n})(Zepto);(function ($) {\n  var cache = [],\n      timeout;\n\n  $.fn.remove = function () {\n    return this.each(function () {\n      if (this.parentNode) {\n        if (this.tagName === 'IMG') {\n          cache.push(this);\n          this.src = 'data:image/gif;base64,R0lGODlhAQABAAD/ACwAAAAAAQABAAACADs=';\n          if (timeout) clearTimeout(timeout);\n          timeout = setTimeout(function () {\n            cache = [];\n          }, 60000);\n        }\n        this.parentNode.removeChild(this);\n      }\n    });\n  };\n})(Zepto);(function ($) {\n  // Create a collection of callbacks to be fired in a sequence, with configurable behaviour\n  // Option flags:\n  //   - once: Callbacks fired at most one time.\n  //   - memory: Remember the most recent context and arguments\n  //   - stopOnFalse: Cease iterating over callback list\n  //   - unique: Permit adding at most one instance of the same callback\n  $.Callbacks = function (options) {\n    options = $.extend({}, options);\n\n    var memory,\n        // Last fire value (for non-forgettable lists)\n    _fired,\n        // Flag to know if list was already fired\n    firing,\n        // Flag to know if list is currently firing\n    firingStart,\n        // First callback to fire (used internally by add and fireWith)\n    firingLength,\n        // End of the loop when firing\n    firingIndex,\n        // Index of currently firing callback (modified by remove if needed)\n    list = [],\n        // Actual callback list\n    stack = !options.once && [],\n        // Stack of fire calls for repeatable lists\n    fire = function fire(data) {\n      memory = options.memory && data;\n      _fired = true;\n      firingIndex = firingStart || 0;\n      firingStart = 0;\n      firingLength = list.length;\n      firing = true;\n      for (; list && firingIndex < firingLength; ++firingIndex) {\n        if (list[firingIndex].apply(data[0], data[1]) === false && options.stopOnFalse) {\n          memory = false;\n          break;\n        }\n      }\n      firing = false;\n      if (list) {\n        if (stack) stack.length && fire(stack.shift());else if (memory) list.length = 0;else Callbacks.disable();\n      }\n    },\n        Callbacks = {\n      add: function add() {\n        if (list) {\n          var start = list.length,\n              add = function add(args) {\n            $.each(args, function (_, arg) {\n              if (typeof arg === \"function\") {\n                if (!options.unique || !Callbacks.has(arg)) list.push(arg);\n              } else if (arg && arg.length && typeof arg !== 'string') add(arg);\n            });\n          };\n          add(arguments);\n          if (firing) firingLength = list.length;else if (memory) {\n            firingStart = start;\n            fire(memory);\n          }\n        }\n        return this;\n      },\n      remove: function remove() {\n        if (list) {\n          $.each(arguments, function (_, arg) {\n            var index;\n            while ((index = $.inArray(arg, list, index)) > -1) {\n              list.splice(index, 1);\n              // Handle firing indexes\n              if (firing) {\n                if (index <= firingLength) --firingLength;\n                if (index <= firingIndex) --firingIndex;\n              }\n            }\n          });\n        }\n        return this;\n      },\n      has: function has(fn) {\n        return !!(list && (fn ? $.inArray(fn, list) > -1 : list.length));\n      },\n      empty: function empty() {\n        firingLength = list.length = 0;\n        return this;\n      },\n      disable: function disable() {\n        list = stack = memory = undefined;\n        return this;\n      },\n      disabled: function disabled() {\n        return !list;\n      },\n      lock: function lock() {\n        stack = undefined;\n        if (!memory) Callbacks.disable();\n        return this;\n      },\n      locked: function locked() {\n        return !stack;\n      },\n      fireWith: function fireWith(context, args) {\n        if (list && (!_fired || stack)) {\n          args = args || [];\n          args = [context, args.slice ? args.slice() : args];\n          if (firing) stack.push(args);else fire(args);\n        }\n        return this;\n      },\n      fire: function fire() {\n        return Callbacks.fireWith(this, arguments);\n      },\n      fired: function fired() {\n        return !!_fired;\n      }\n    };\n\n    return Callbacks;\n  };\n})(Zepto);(function ($) {\n  var data = {},\n      dataAttr = $.fn.data,\n      camelize = $.camelCase,\n      exp = $.expando = 'Zepto' + +new Date(),\n      emptyArray = [];\n\n  // Get value from node:\n  // 1. first try key as given,\n  // 2. then try camelized key,\n  // 3. fall back to reading \"data-*\" attribute.\n  function getData(node, name) {\n    var id = node[exp],\n        store = id && data[id];\n    if (name === undefined) return store || setData(node);else {\n      if (store) {\n        if (name in store) return store[name];\n        var camelName = camelize(name);\n        if (camelName in store) return store[camelName];\n      }\n      return dataAttr.call($(node), name);\n    }\n  }\n\n  // Store value under camelized key on node\n  function setData(node, name, value) {\n    var id = node[exp] || (node[exp] = ++$.uuid),\n        store = data[id] || (data[id] = attributeData(node));\n    if (name !== undefined) store[camelize(name)] = value;\n    return store;\n  }\n\n  // Read all \"data-*\" attributes from a node\n  function attributeData(node) {\n    var store = {};\n    $.each(node.attributes || emptyArray, function (i, attr) {\n      if (attr.name.indexOf('data-') == 0) store[camelize(attr.name.replace('data-', ''))] = $.zepto.deserializeValue(attr.value);\n    });\n    return store;\n  }\n\n  $.fn.data = function (name, value) {\n    return value === undefined ?\n    // set multiple values via object\n    $.isPlainObject(name) ? this.each(function (i, node) {\n      $.each(name, function (key, value) {\n        setData(node, key, value);\n      });\n    }) :\n    // get value from first element\n    0 in this ? getData(this[0], name) : undefined :\n    // set value on all elements\n    this.each(function () {\n      setData(this, name, value);\n    });\n  };\n\n  $.fn.removeData = function (names) {\n    if (typeof names == 'string') names = names.split(/\\s+/);\n    return this.each(function () {\n      var id = this[exp],\n          store = id && data[id];\n      if (store) $.each(names || store, function (key) {\n        delete store[names ? camelize(this) : key];\n      });\n    });\n  }\n\n  // Generate extended `remove` and `empty` functions\n  ;['remove', 'empty'].forEach(function (methodName) {\n    var origFn = $.fn[methodName];\n    $.fn[methodName] = function () {\n      var elements = this.find('*');\n      if (methodName === 'remove') elements = elements.add(this);\n      elements.removeData();\n      return origFn.call(this);\n    };\n  });\n})(Zepto);(function ($) {\n  var slice = Array.prototype.slice;\n\n  function Deferred(func) {\n    var tuples = [\n    // action, add listener, listener list, final state\n    [\"resolve\", \"done\", $.Callbacks({ once: 1, memory: 1 }), \"resolved\"], [\"reject\", \"fail\", $.Callbacks({ once: 1, memory: 1 }), \"rejected\"], [\"notify\", \"progress\", $.Callbacks({ memory: 1 })]],\n        _state = \"pending\",\n        _promise = {\n      state: function state() {\n        return _state;\n      },\n      always: function always() {\n        deferred.done(arguments).fail(arguments);\n        return this;\n      },\n      then: function then() /* fnDone [, fnFailed [, fnProgress]] */{\n        var fns = arguments;\n        return Deferred(function (defer) {\n          $.each(tuples, function (i, tuple) {\n            var fn = $.isFunction(fns[i]) && fns[i];\n            deferred[tuple[1]](function () {\n              var returned = fn && fn.apply(this, arguments);\n              if (returned && $.isFunction(returned.promise)) {\n                returned.promise().done(defer.resolve).fail(defer.reject).progress(defer.notify);\n              } else {\n                var context = this === _promise ? defer.promise() : this,\n                    values = fn ? [returned] : arguments;\n                defer[tuple[0] + \"With\"](context, values);\n              }\n            });\n          });\n          fns = null;\n        }).promise();\n      },\n\n      promise: function promise(obj) {\n        return obj != null ? $.extend(obj, _promise) : _promise;\n      }\n    },\n        deferred = {};\n\n    $.each(tuples, function (i, tuple) {\n      var list = tuple[2],\n          stateString = tuple[3];\n\n      _promise[tuple[1]] = list.add;\n\n      if (stateString) {\n        list.add(function () {\n          _state = stateString;\n        }, tuples[i ^ 1][2].disable, tuples[2][2].lock);\n      }\n\n      deferred[tuple[0]] = function () {\n        deferred[tuple[0] + \"With\"](this === deferred ? _promise : this, arguments);\n        return this;\n      };\n      deferred[tuple[0] + \"With\"] = list.fireWith;\n    });\n\n    _promise.promise(deferred);\n    if (func) func.call(deferred, deferred);\n    return deferred;\n  }\n\n  $.when = function (sub) {\n    var resolveValues = slice.call(arguments),\n        len = resolveValues.length,\n        i = 0,\n        remain = len !== 1 || sub && $.isFunction(sub.promise) ? len : 0,\n        deferred = remain === 1 ? sub : Deferred(),\n        progressValues,\n        progressContexts,\n        resolveContexts,\n        updateFn = function updateFn(i, ctx, val) {\n      return function (value) {\n        ctx[i] = this;\n        val[i] = arguments.length > 1 ? slice.call(arguments) : value;\n        if (val === progressValues) {\n          deferred.notifyWith(ctx, val);\n        } else if (! --remain) {\n          deferred.resolveWith(ctx, val);\n        }\n      };\n    };\n\n    if (len > 1) {\n      progressValues = new Array(len);\n      progressContexts = new Array(len);\n      resolveContexts = new Array(len);\n      for (; i < len; ++i) {\n        if (resolveValues[i] && $.isFunction(resolveValues[i].promise)) {\n          resolveValues[i].promise().done(updateFn(i, resolveContexts, resolveValues)).fail(deferred.reject).progress(updateFn(i, progressContexts, progressValues));\n        } else {\n          --remain;\n        }\n      }\n    }\n    if (!remain) deferred.resolveWith(resolveContexts, resolveValues);\n    return deferred.promise();\n  };\n\n  $.Deferred = Deferred;\n})(Zepto);(function ($) {\n  function detect(ua) {\n    var os = this.os = {},\n        browser = this.browser = {},\n        webkit = ua.match(/Web[kK]it[\\/]{0,1}([\\d.]+)/),\n        android = ua.match(/(Android);?[\\s\\/]+([\\d.]+)?/),\n        osx = !!ua.match(/\\(Macintosh\\; Intel /),\n        ipad = ua.match(/(iPad).*OS\\s([\\d_]+)/),\n        ipod = ua.match(/(iPod)(.*OS\\s([\\d_]+))?/),\n        iphone = !ipad && ua.match(/(iPhone\\sOS)\\s([\\d_]+)/),\n        webos = ua.match(/(webOS|hpwOS)[\\s\\/]([\\d.]+)/),\n        wp = ua.match(/Windows Phone ([\\d.]+)/),\n        touchpad = webos && ua.match(/TouchPad/),\n        kindle = ua.match(/Kindle\\/([\\d.]+)/),\n        silk = ua.match(/Silk\\/([\\d._]+)/),\n        blackberry = ua.match(/(BlackBerry).*Version\\/([\\d.]+)/),\n        bb10 = ua.match(/(BB10).*Version\\/([\\d.]+)/),\n        rimtabletos = ua.match(/(RIM\\sTablet\\sOS)\\s([\\d.]+)/),\n        playbook = ua.match(/PlayBook/),\n        chrome = ua.match(/Chrome\\/([\\d.]+)/) || ua.match(/CriOS\\/([\\d.]+)/),\n        firefox = ua.match(/Firefox\\/([\\d.]+)/),\n        ie = ua.match(/MSIE\\s([\\d.]+)/) || ua.match(/Trident\\/[\\d](?=[^\\?]+).*rv:([0-9.].)/),\n        webview = !chrome && ua.match(/(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/),\n        safari = webview || ua.match(/Version\\/([\\d.]+)([^S](Safari)|[^M]*(Mobile)[^S]*(Safari))/);\n\n    // Todo: clean this up with a better OS/browser seperation:\n    // - discern (more) between multiple browsers on android\n    // - decide if kindle fire in silk mode is android or not\n    // - Firefox on Android doesn't specify the Android version\n    // - possibly devide in os, device and browser hashes\n\n    if (browser.webkit = !!webkit) browser.version = webkit[1];\n\n    if (android) os.android = true, os.version = android[2];\n    if (iphone && !ipod) os.ios = os.iphone = true, os.version = iphone[2].replace(/_/g, '.');\n    if (ipad) os.ios = os.ipad = true, os.version = ipad[2].replace(/_/g, '.');\n    if (ipod) os.ios = os.ipod = true, os.version = ipod[3] ? ipod[3].replace(/_/g, '.') : null;\n    if (wp) os.wp = true, os.version = wp[1];\n    if (webos) os.webos = true, os.version = webos[2];\n    if (touchpad) os.touchpad = true;\n    if (blackberry) os.blackberry = true, os.version = blackberry[2];\n    if (bb10) os.bb10 = true, os.version = bb10[2];\n    if (rimtabletos) os.rimtabletos = true, os.version = rimtabletos[2];\n    if (playbook) browser.playbook = true;\n    if (kindle) os.kindle = true, os.version = kindle[1];\n    if (silk) browser.silk = true, browser.version = silk[1];\n    if (!silk && os.android && ua.match(/Kindle Fire/)) browser.silk = true;\n    if (chrome) browser.chrome = true, browser.version = chrome[1];\n    if (firefox) browser.firefox = true, browser.version = firefox[1];\n    if (ie) browser.ie = true, browser.version = ie[1];\n    if (safari && (osx || os.ios)) {\n      browser.safari = true;if (osx) browser.version = safari[1];\n    }\n    if (webview) browser.webview = true;\n\n    os.tablet = !!(ipad || playbook || android && !ua.match(/Mobile/) || firefox && ua.match(/Tablet/) || ie && !ua.match(/Phone/) && ua.match(/Touch/));\n    os.phone = !!(!os.tablet && !os.ipod && (android || iphone || webos || blackberry || bb10 || chrome && ua.match(/Android/) || chrome && ua.match(/CriOS\\/([\\d.]+)/) || firefox && ua.match(/Mobile/) || ie && ua.match(/Touch/)));\n  }\n\n  detect.call($, navigator.userAgent);\n  // make available to unit tests\n  $.__detect = detect;\n})(Zepto);(function ($) {\n  var _zid = 1,\n      undefined,\n      slice = Array.prototype.slice,\n      isFunction = $.isFunction,\n      isString = function isString(obj) {\n    return typeof obj == 'string';\n  },\n      handlers = {},\n      specialEvents = {},\n      focusinSupported = 'onfocusin' in window,\n      focus = { focus: 'focusin', blur: 'focusout' },\n      hover = { mouseenter: 'mouseover', mouseleave: 'mouseout' };\n\n  specialEvents.click = specialEvents.mousedown = specialEvents.mouseup = specialEvents.mousemove = 'MouseEvents';\n\n  function zid(element) {\n    return element._zid || (element._zid = _zid++);\n  }\n  function findHandlers(element, event, fn, selector) {\n    event = parse(event);\n    if (event.ns) var matcher = matcherFor(event.ns);\n    return (handlers[zid(element)] || []).filter(function (handler) {\n      return handler && (!event.e || handler.e == event.e) && (!event.ns || matcher.test(handler.ns)) && (!fn || zid(handler.fn) === zid(fn)) && (!selector || handler.sel == selector);\n    });\n  }\n  function parse(event) {\n    var parts = ('' + event).split('.');\n    return { e: parts[0], ns: parts.slice(1).sort().join(' ') };\n  }\n  function matcherFor(ns) {\n    return new RegExp('(?:^| )' + ns.replace(' ', ' .* ?') + '(?: |$)');\n  }\n\n  function eventCapture(handler, captureSetting) {\n    return handler.del && !focusinSupported && handler.e in focus || !!captureSetting;\n  }\n\n  function realEvent(type) {\n    return hover[type] || focusinSupported && focus[type] || type;\n  }\n\n  function add(element, events, fn, data, selector, delegator, capture) {\n    var id = zid(element),\n        set = handlers[id] || (handlers[id] = []);\n    events.split(/\\s/).forEach(function (event) {\n      if (event == 'ready') return $(document).ready(fn);\n      var handler = parse(event);\n      handler.fn = fn;\n      handler.sel = selector;\n      // emulate mouseenter, mouseleave\n      if (handler.e in hover) fn = function fn(e) {\n        var related = e.relatedTarget;\n        if (!related || related !== this && !$.contains(this, related)) return handler.fn.apply(this, arguments);\n      };\n      handler.del = delegator;\n      var callback = delegator || fn;\n      handler.proxy = function (e) {\n        e = compatible(e);\n        if (e.isImmediatePropagationStopped()) return;\n        e.data = data;\n        var result = callback.apply(element, e._args == undefined ? [e] : [e].concat(e._args));\n        if (result === false) e.preventDefault(), e.stopPropagation();\n        return result;\n      };\n      handler.i = set.length;\n      set.push(handler);\n      if ('addEventListener' in element) element.addEventListener(realEvent(handler.e), handler.proxy, eventCapture(handler, capture));\n    });\n  }\n  function remove(element, events, fn, selector, capture) {\n    var id = zid(element);(events || '').split(/\\s/).forEach(function (event) {\n      findHandlers(element, event, fn, selector).forEach(function (handler) {\n        delete handlers[id][handler.i];\n        if ('removeEventListener' in element) element.removeEventListener(realEvent(handler.e), handler.proxy, eventCapture(handler, capture));\n      });\n    });\n  }\n\n  $.event = { add: add, remove: remove };\n\n  $.proxy = function (fn, context) {\n    var args = 2 in arguments && slice.call(arguments, 2);\n    if (isFunction(fn)) {\n      var proxyFn = function proxyFn() {\n        return fn.apply(context, args ? args.concat(slice.call(arguments)) : arguments);\n      };\n      proxyFn._zid = zid(fn);\n      return proxyFn;\n    } else if (isString(context)) {\n      if (args) {\n        args.unshift(fn[context], fn);\n        return $.proxy.apply(null, args);\n      } else {\n        return $.proxy(fn[context], fn);\n      }\n    } else {\n      throw new TypeError(\"expected function\");\n    }\n  };\n\n  $.fn.bind = function (event, data, callback) {\n    return this.on(event, data, callback);\n  };\n  $.fn.unbind = function (event, callback) {\n    return this.off(event, callback);\n  };\n  $.fn.one = function (event, selector, data, callback) {\n    return this.on(event, selector, data, callback, 1);\n  };\n\n  var returnTrue = function returnTrue() {\n    return true;\n  },\n      returnFalse = function returnFalse() {\n    return false;\n  },\n      ignoreProperties = /^([A-Z]|returnValue$|layer[XY]$)/,\n      eventMethods = {\n    preventDefault: 'isDefaultPrevented',\n    stopImmediatePropagation: 'isImmediatePropagationStopped',\n    stopPropagation: 'isPropagationStopped'\n  };\n\n  function compatible(event, source) {\n    if (source || !event.isDefaultPrevented) {\n      source || (source = event);\n\n      $.each(eventMethods, function (name, predicate) {\n        var sourceMethod = source[name];\n        event[name] = function () {\n          this[predicate] = returnTrue;\n          return sourceMethod && sourceMethod.apply(source, arguments);\n        };\n        event[predicate] = returnFalse;\n      });\n\n      if (source.defaultPrevented !== undefined ? source.defaultPrevented : 'returnValue' in source ? source.returnValue === false : source.getPreventDefault && source.getPreventDefault()) event.isDefaultPrevented = returnTrue;\n    }\n    return event;\n  }\n\n  function createProxy(event) {\n    var key,\n        proxy = { originalEvent: event };\n    for (key in event) {\n      if (!ignoreProperties.test(key) && event[key] !== undefined) proxy[key] = event[key];\n    }return compatible(proxy, event);\n  }\n\n  $.fn.delegate = function (selector, event, callback) {\n    return this.on(event, selector, callback);\n  };\n  $.fn.undelegate = function (selector, event, callback) {\n    return this.off(event, selector, callback);\n  };\n\n  $.fn.live = function (event, callback) {\n    $(document.body).delegate(this.selector, event, callback);\n    return this;\n  };\n  $.fn.die = function (event, callback) {\n    $(document.body).undelegate(this.selector, event, callback);\n    return this;\n  };\n\n  $.fn.on = function (event, selector, data, callback, one) {\n    var autoRemove,\n        delegator,\n        $this = this;\n    if (event && !isString(event)) {\n      $.each(event, function (type, fn) {\n        $this.on(type, selector, data, fn, one);\n      });\n      return $this;\n    }\n\n    if (!isString(selector) && !isFunction(callback) && callback !== false) callback = data, data = selector, selector = undefined;\n    if (isFunction(data) || data === false) callback = data, data = undefined;\n\n    if (callback === false) callback = returnFalse;\n\n    return $this.each(function (_, element) {\n      if (one) autoRemove = function autoRemove(e) {\n        remove(element, e.type, callback);\n        return callback.apply(this, arguments);\n      };\n\n      if (selector) delegator = function delegator(e) {\n        var evt,\n            match = $(e.target).closest(selector, element).get(0);\n        if (match && match !== element) {\n          evt = $.extend(createProxy(e), { currentTarget: match, liveFired: element });\n          return (autoRemove || callback).apply(match, [evt].concat(slice.call(arguments, 1)));\n        }\n      };\n\n      add(element, event, callback, data, selector, delegator || autoRemove);\n    });\n  };\n  $.fn.off = function (event, selector, callback) {\n    var $this = this;\n    if (event && !isString(event)) {\n      $.each(event, function (type, fn) {\n        $this.off(type, selector, fn);\n      });\n      return $this;\n    }\n\n    if (!isString(selector) && !isFunction(callback) && callback !== false) callback = selector, selector = undefined;\n\n    if (callback === false) callback = returnFalse;\n\n    return $this.each(function () {\n      remove(this, event, callback, selector);\n    });\n  };\n\n  $.fn.trigger = function (event, args) {\n    event = isString(event) || $.isPlainObject(event) ? $.Event(event) : compatible(event);\n    event._args = args;\n    return this.each(function () {\n      // items in the collection might not be DOM elements\n      if ('dispatchEvent' in this) this.dispatchEvent(event);else $(this).triggerHandler(event, args);\n    });\n  };\n\n  // triggers event handlers on current element just as if an event occurred,\n  // doesn't trigger an actual event, doesn't bubble\n  $.fn.triggerHandler = function (event, args) {\n    var e, result;\n    this.each(function (i, element) {\n      e = createProxy(isString(event) ? $.Event(event) : event);\n      e._args = args;\n      e.target = element;\n      $.each(findHandlers(element, event.type || event), function (i, handler) {\n        result = handler.proxy(e);\n        if (e.isImmediatePropagationStopped()) return false;\n      });\n    });\n    return result;\n  }\n\n  // shortcut methods for `.bind(event, fn)` for each event type\n  ;('focusin focusout load resize scroll unload click dblclick ' + 'mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave ' + 'change select keydown keypress keyup error').split(' ').forEach(function (event) {\n    $.fn[event] = function (callback) {\n      return callback ? this.bind(event, callback) : this.trigger(event);\n    };\n  });['focus', 'blur'].forEach(function (name) {\n    $.fn[name] = function (callback) {\n      if (callback) this.bind(name, callback);else this.each(function () {\n        try {\n          this[name]();\n        } catch (e) {}\n      });\n      return this;\n    };\n  });\n\n  $.Event = function (type, props) {\n    if (!isString(type)) props = type, type = props.type;\n    var event = document.createEvent(specialEvents[type] || 'Events'),\n        bubbles = true;\n    if (props) for (var name in props) {\n      name == 'bubbles' ? bubbles = !!props[name] : event[name] = props[name];\n    }event.initEvent(type, bubbles, true);\n    return compatible(event);\n  };\n})(Zepto);(function ($) {\n  $.fn.serializeArray = function () {\n    var el,\n        type,\n        result = [];\n    $([].slice.call(this.get(0).elements)).each(function () {\n      el = $(this);\n      type = el.attr('type');\n      if (this.name && this.nodeName.toLowerCase() != 'fieldset' && !this.disabled && type != 'submit' && type != 'reset' && type != 'button' && (type != 'radio' && type != 'checkbox' || this.checked)) result.push({\n        name: el.attr('name'),\n        value: el.val()\n      });\n    });\n    return result;\n  };\n\n  $.fn.serialize = function () {\n    var result = [];\n    this.serializeArray().forEach(function (elm) {\n      result.push(encodeURIComponent(elm.name) + '=' + encodeURIComponent(elm.value));\n    });\n    return result.join('&');\n  };\n\n  $.fn.submit = function (callback) {\n    if (callback) this.bind('submit', callback);else if (this.length) {\n      var event = $.Event('submit');\n      this.eq(0).trigger(event);\n      if (!event.isDefaultPrevented()) this.get(0).submit();\n    }\n    return this;\n  };\n})(Zepto);(function ($, undefined) {\n  var document = window.document,\n      docElem = document.documentElement,\n      origShow = $.fn.show,\n      origHide = $.fn.hide,\n      origToggle = $.fn.toggle;\n\n  function anim(el, speed, opacity, scale, callback) {\n    if (typeof speed == 'function' && !callback) callback = speed, speed = undefined;\n    var props = { opacity: opacity };\n    if (scale) {\n      props.scale = scale;\n      el.css($.fx.cssPrefix + 'transform-origin', '0 0');\n    }\n    return el.animate(props, speed, null, callback);\n  }\n\n  function hide(el, speed, scale, callback) {\n    return anim(el, speed, 0, scale, function () {\n      origHide.call($(this));\n      callback && callback.call(this);\n    });\n  }\n\n  $.fn.show = function (speed, callback) {\n    origShow.call(this);\n    if (speed === undefined) speed = 0;else this.css('opacity', 0);\n    return anim(this, speed, 1, '1,1', callback);\n  };\n\n  $.fn.hide = function (speed, callback) {\n    if (speed === undefined) return origHide.call(this);else return hide(this, speed, '0,0', callback);\n  };\n\n  $.fn.toggle = function (speed, callback) {\n    if (speed === undefined || typeof speed == 'boolean') return origToggle.call(this, speed);else return this.each(function () {\n      var el = $(this);\n      el[el.css('display') == 'none' ? 'show' : 'hide'](speed, callback);\n    });\n  };\n\n  $.fn.fadeTo = function (speed, opacity, callback) {\n    return anim(this, speed, opacity, null, callback);\n  };\n\n  $.fn.fadeIn = function (speed, callback) {\n    var target = this.css('opacity');\n    if (target > 0) this.css('opacity', 0);else target = 1;\n    return origShow.call(this).fadeTo(speed, target, callback);\n  };\n\n  $.fn.fadeOut = function (speed, callback) {\n    return hide(this, speed, null, callback);\n  };\n\n  $.fn.fadeToggle = function (speed, callback) {\n    return this.each(function () {\n      var el = $(this);\n      el[el.css('opacity') == 0 || el.css('display') == 'none' ? 'fadeIn' : 'fadeOut'](speed, callback);\n    });\n  };\n})(Zepto);(function ($, undefined) {\n  var prefix = '',\n      eventPrefix,\n      endEventName,\n      endAnimationName,\n      vendors = { Webkit: 'webkit', Moz: '', O: 'o' },\n      document = window.document,\n      testEl = document.createElement('div'),\n      supportedTransforms = /^((translate|rotate|scale)(X|Y|Z|3d)?|matrix(3d)?|perspective|skew(X|Y)?)$/i,\n      transform,\n      transitionProperty,\n      transitionDuration,\n      transitionTiming,\n      transitionDelay,\n      animationName,\n      animationDuration,\n      animationTiming,\n      animationDelay,\n      cssReset = {};\n\n  function dasherize(str) {\n    return str.replace(/([a-z])([A-Z])/, '$1-$2').toLowerCase();\n  }\n  function normalizeEvent(name) {\n    return eventPrefix ? eventPrefix + name : name.toLowerCase();\n  }\n\n  $.each(vendors, function (vendor, event) {\n    if (testEl.style[vendor + 'TransitionProperty'] !== undefined) {\n      prefix = '-' + vendor.toLowerCase() + '-';\n      eventPrefix = event;\n      return false;\n    }\n  });\n\n  transform = prefix + 'transform';\n  cssReset[transitionProperty = prefix + 'transition-property'] = cssReset[transitionDuration = prefix + 'transition-duration'] = cssReset[transitionDelay = prefix + 'transition-delay'] = cssReset[transitionTiming = prefix + 'transition-timing-function'] = cssReset[animationName = prefix + 'animation-name'] = cssReset[animationDuration = prefix + 'animation-duration'] = cssReset[animationDelay = prefix + 'animation-delay'] = cssReset[animationTiming = prefix + 'animation-timing-function'] = '';\n\n  $.fx = {\n    off: eventPrefix === undefined && testEl.style.transitionProperty === undefined,\n    speeds: { _default: 400, fast: 200, slow: 600 },\n    cssPrefix: prefix,\n    transitionEnd: normalizeEvent('TransitionEnd'),\n    animationEnd: normalizeEvent('AnimationEnd')\n  };\n\n  $.fn.animate = function (properties, duration, ease, callback, delay) {\n    if ($.isFunction(duration)) callback = duration, ease = undefined, duration = undefined;\n    if ($.isFunction(ease)) callback = ease, ease = undefined;\n    if ($.isPlainObject(duration)) ease = duration.easing, callback = duration.complete, delay = duration.delay, duration = duration.duration;\n    if (duration) duration = (typeof duration == 'number' ? duration : $.fx.speeds[duration] || $.fx.speeds._default) / 1000;\n    if (delay) delay = parseFloat(delay) / 1000;\n    return this.anim(properties, duration, ease, callback, delay);\n  };\n\n  $.fn.anim = function (properties, duration, ease, callback, delay) {\n    var key,\n        cssValues = {},\n        cssProperties,\n        transforms = '',\n        that = this,\n        _wrappedCallback,\n        endEvent = $.fx.transitionEnd,\n        fired = false;\n\n    if (duration === undefined) duration = $.fx.speeds._default / 1000;\n    if (delay === undefined) delay = 0;\n    if ($.fx.off) duration = 0;\n\n    if (typeof properties == 'string') {\n      // keyframe animation\n      cssValues[animationName] = properties;\n      cssValues[animationDuration] = duration + 's';\n      cssValues[animationDelay] = delay + 's';\n      cssValues[animationTiming] = ease || 'linear';\n      endEvent = $.fx.animationEnd;\n    } else {\n      cssProperties = [];\n      // CSS transitions\n      for (key in properties) {\n        if (supportedTransforms.test(key)) transforms += key + '(' + properties[key] + ') ';else cssValues[key] = properties[key], cssProperties.push(dasherize(key));\n      }if (transforms) cssValues[transform] = transforms, cssProperties.push(transform);\n      if (duration > 0 && (typeof properties === 'undefined' ? 'undefined' : _typeof(properties)) === 'object') {\n        cssValues[transitionProperty] = cssProperties.join(', ');\n        cssValues[transitionDuration] = duration + 's';\n        cssValues[transitionDelay] = delay + 's';\n        cssValues[transitionTiming] = ease || 'linear';\n      }\n    }\n\n    _wrappedCallback = function wrappedCallback(event) {\n      if (typeof event !== 'undefined') {\n        if (event.target !== event.currentTarget) return; // makes sure the event didn't bubble from \"below\"\n        $(event.target).unbind(endEvent, _wrappedCallback);\n      } else $(this).unbind(endEvent, _wrappedCallback); // triggered by setTimeout\n\n      fired = true;\n      $(this).css(cssReset);\n      callback && callback.call(this);\n    };\n    if (duration > 0) {\n      this.bind(endEvent, _wrappedCallback);\n      // transitionEnd is not always firing on older Android phones\n      // so make sure it gets fired\n      setTimeout(function () {\n        if (fired) return;\n        _wrappedCallback.call(that);\n      }, duration * 1000 + 25);\n    }\n\n    // trigger page reflow so new elements can animate\n    this.size() && this.get(0).clientLeft;\n\n    this.css(cssValues);\n\n    if (duration <= 0) setTimeout(function () {\n      that.each(function () {\n        _wrappedCallback.call(this);\n      });\n    }, 0);\n\n    return this;\n  };\n\n  testEl = null;\n})(Zepto);(function ($) {\n  if ($.os.ios) {\n    var gesture, gestureTimeout;\n\n    (function () {\n      var parentIfText = function parentIfText(node) {\n        return 'tagName' in node ? node : node.parentNode;\n      };\n\n      gesture = {};\n\n\n      $(document).bind('gesturestart', function (e) {\n        var now = Date.now(),\n            delta = now - (gesture.last || now);\n        gesture.target = parentIfText(e.target);\n        gestureTimeout && clearTimeout(gestureTimeout);\n        gesture.e1 = e.scale;\n        gesture.last = now;\n      }).bind('gesturechange', function (e) {\n        gesture.e2 = e.scale;\n      }).bind('gestureend', function (e) {\n        if (gesture.e2 > 0) {\n          Math.abs(gesture.e1 - gesture.e2) != 0 && $(gesture.target).trigger('pinch') && $(gesture.target).trigger('pinch' + (gesture.e1 - gesture.e2 > 0 ? 'In' : 'Out'));\n          gesture.e1 = gesture.e2 = gesture.last = 0;\n        } else if ('last' in gesture) {\n          gesture = {};\n        }\n      });['pinch', 'pinchIn', 'pinchOut'].forEach(function (m) {\n        $.fn[m] = function (callback) {\n          return this.bind(m, callback);\n        };\n      });\n    })();\n  }\n})(Zepto);(function ($) {\n  // __proto__ doesn't exist on IE<11, so redefine\n  // the Z function to use object extension instead\n  if (!('__proto__' in {})) {\n    $.extend($.zepto, {\n      Z: function Z(dom, selector) {\n        dom = dom || [];\n        $.extend(dom, $.fn);\n        dom.selector = selector || '';\n        dom.__Z = true;\n        return dom;\n      },\n      // this is a kludge but works\n      isZ: function isZ(object) {\n        return $.type(object) === 'array' && '__Z' in object;\n      }\n    });\n  }\n\n  // getComputedStyle shouldn't freak out when called\n  // without a valid element as argument\n  try {\n    getComputedStyle(undefined);\n  } catch (e) {\n    var nativeGetComputedStyle = getComputedStyle;\n    window.getComputedStyle = function (element) {\n      try {\n        return nativeGetComputedStyle(element);\n      } catch (e) {\n        return null;\n      }\n    };\n  }\n})(Zepto);(function ($) {\n  var zepto = $.zepto,\n      oldQsa = zepto.qsa,\n      oldMatches = zepto.matches;\n\n  function _visible(elem) {\n    elem = $(elem);\n    return !!(elem.width() || elem.height()) && elem.css(\"display\") !== \"none\";\n  }\n\n  // Implements a subset from:\n  // http://api.jquery.com/category/selectors/jquery-selector-extensions/\n  //\n  // Each filter function receives the current index, all nodes in the\n  // considered set, and a value if there were parentheses. The value\n  // of `this` is the node currently being considered. The function returns the\n  // resulting node(s), null, or undefined.\n  //\n  // Complex selectors are not supported:\n  //   li:has(label:contains(\"foo\")) + li:has(label:contains(\"bar\"))\n  //   ul.inner:first > li\n  var filters = $.expr[':'] = {\n    visible: function visible() {\n      if (_visible(this)) return this;\n    },\n    hidden: function hidden() {\n      if (!_visible(this)) return this;\n    },\n    selected: function selected() {\n      if (this.selected) return this;\n    },\n    checked: function checked() {\n      if (this.checked) return this;\n    },\n    parent: function parent() {\n      return this.parentNode;\n    },\n    first: function first(idx) {\n      if (idx === 0) return this;\n    },\n    last: function last(idx, nodes) {\n      if (idx === nodes.length - 1) return this;\n    },\n    eq: function eq(idx, _, value) {\n      if (idx === value) return this;\n    },\n    contains: function contains(idx, _, text) {\n      if ($(this).text().indexOf(text) > -1) return this;\n    },\n    has: function has(idx, _, sel) {\n      if (zepto.qsa(this, sel).length) return this;\n    }\n  };\n\n  var filterRe = new RegExp('(.*):(\\\\w+)(?:\\\\(([^)]+)\\\\))?$\\\\s*'),\n      childRe = /^\\s*>/,\n      classTag = 'Zepto' + +new Date();\n\n  function process(sel, fn) {\n    // quote the hash in `a[href^=#]` expression\n    sel = sel.replace(/=#\\]/g, '=\"#\"]');\n    var filter,\n        arg,\n        match = filterRe.exec(sel);\n    if (match && match[2] in filters) {\n      filter = filters[match[2]], arg = match[3];\n      sel = match[1];\n      if (arg) {\n        var num = Number(arg);\n        if (isNaN(num)) arg = arg.replace(/^[\"']|[\"']$/g, '');else arg = num;\n      }\n    }\n    return fn(sel, filter, arg);\n  }\n\n  zepto.qsa = function (node, selector) {\n    return process(selector, function (sel, filter, arg) {\n      try {\n        var taggedParent;\n        if (!sel && filter) sel = '*';else if (childRe.test(sel))\n          // support \"> *\" child queries by tagging the parent node with a\n          // unique class and prepending that classname onto the selector\n          taggedParent = $(node).addClass(classTag), sel = '.' + classTag + ' ' + sel;\n\n        var nodes = oldQsa(node, sel);\n      } catch (e) {\n        console.error('error performing selector: %o', selector);\n        throw e;\n      } finally {\n        if (taggedParent) taggedParent.removeClass(classTag);\n      }\n      return !filter ? nodes : zepto.uniq($.map(nodes, function (n, i) {\n        return filter.call(n, i, nodes, arg);\n      }));\n    });\n  };\n\n  zepto.matches = function (node, selector) {\n    return process(selector, function (sel, filter, arg) {\n      return (!sel || oldMatches(node, sel)) && (!filter || filter.call(node, null, arg) === node);\n    });\n  };\n})(Zepto);(function ($) {\n  $.fn.end = function () {\n    return this.prevObject || $();\n  };\n\n  $.fn.andSelf = function () {\n    return this.add(this.prevObject || $());\n  };\n\n  'filter,add,not,eq,first,last,find,closest,parents,parent,children,siblings'.split(',').forEach(function (property) {\n    var fn = $.fn[property];\n    $.fn[property] = function () {\n      var ret = fn.apply(this, arguments);\n      ret.prevObject = this;\n      return ret;\n    };\n  });\n})(Zepto);(function ($) {\n  var touch = {},\n      touchTimeout,\n      tapTimeout,\n      swipeTimeout,\n      longTapTimeout,\n      longTapDelay = 750,\n      gesture;\n\n  function swipeDirection(x1, x2, y1, y2) {\n    return Math.abs(x1 - x2) >= Math.abs(y1 - y2) ? x1 - x2 > 0 ? 'Left' : 'Right' : y1 - y2 > 0 ? 'Up' : 'Down';\n  }\n\n  function longTap() {\n    longTapTimeout = null;\n    if (touch.last) {\n      touch.el.trigger('longTap');\n      touch = {};\n    }\n  }\n\n  function cancelLongTap() {\n    if (longTapTimeout) clearTimeout(longTapTimeout);\n    longTapTimeout = null;\n  }\n\n  function cancelAll() {\n    if (touchTimeout) clearTimeout(touchTimeout);\n    if (tapTimeout) clearTimeout(tapTimeout);\n    if (swipeTimeout) clearTimeout(swipeTimeout);\n    if (longTapTimeout) clearTimeout(longTapTimeout);\n    touchTimeout = tapTimeout = swipeTimeout = longTapTimeout = null;\n    touch = {};\n  }\n\n  function isPrimaryTouch(event) {\n    return (event.pointerType == 'touch' || event.pointerType == event.MSPOINTER_TYPE_TOUCH) && event.isPrimary;\n  }\n\n  function isPointerEventType(e, type) {\n    return e.type == 'pointer' + type || e.type.toLowerCase() == 'mspointer' + type;\n  }\n\n  $(document).ready(function () {\n    var now,\n        delta,\n        deltaX = 0,\n        deltaY = 0,\n        firstTouch,\n        _isPointerType;\n\n    if ('MSGesture' in window) {\n      gesture = new MSGesture();\n      gesture.target = document.body;\n    }\n\n    $(document).bind('MSGestureEnd', function (e) {\n      var swipeDirectionFromVelocity = e.velocityX > 1 ? 'Right' : e.velocityX < -1 ? 'Left' : e.velocityY > 1 ? 'Down' : e.velocityY < -1 ? 'Up' : null;\n      if (swipeDirectionFromVelocity) {\n        touch.el.trigger('swipe');\n        touch.el.trigger('swipe' + swipeDirectionFromVelocity);\n      }\n    }).on('touchstart MSPointerDown pointerdown', function (e) {\n      if ((_isPointerType = isPointerEventType(e, 'down')) && !isPrimaryTouch(e)) return;\n      firstTouch = _isPointerType ? e : e.touches[0];\n      if (e.touches && e.touches.length === 1 && touch.x2) {\n        // Clear out touch movement data if we have it sticking around\n        // This can occur if touchcancel doesn't fire due to preventDefault, etc.\n        touch.x2 = undefined;\n        touch.y2 = undefined;\n      }\n      now = Date.now();\n      delta = now - (touch.last || now);\n      touch.el = $('tagName' in firstTouch.target ? firstTouch.target : firstTouch.target.parentNode);\n      touchTimeout && clearTimeout(touchTimeout);\n      touch.x1 = firstTouch.pageX;\n      touch.y1 = firstTouch.pageY;\n      if (delta > 0 && delta <= 250) touch.isDoubleTap = true;\n      touch.last = now;\n      longTapTimeout = setTimeout(longTap, longTapDelay);\n      // adds the current touch contact for IE gesture recognition\n      if (gesture && _isPointerType) gesture.addPointer(e.pointerId);\n    }).on('touchmove MSPointerMove pointermove', function (e) {\n      if ((_isPointerType = isPointerEventType(e, 'move')) && !isPrimaryTouch(e)) return;\n      firstTouch = _isPointerType ? e : e.touches[0];\n      cancelLongTap();\n      touch.x2 = firstTouch.pageX;\n      touch.y2 = firstTouch.pageY;\n\n      deltaX += Math.abs(touch.x1 - touch.x2);\n      deltaY += Math.abs(touch.y1 - touch.y2);\n    }).on('touchend MSPointerUp pointerup', function (e) {\n      if ((_isPointerType = isPointerEventType(e, 'up')) && !isPrimaryTouch(e)) return;\n      cancelLongTap();\n\n      // swipe\n      if (touch.x2 && Math.abs(touch.x1 - touch.x2) > 30 || touch.y2 && Math.abs(touch.y1 - touch.y2) > 30) swipeTimeout = setTimeout(function () {\n        touch.el.trigger('swipe');\n        touch.el.trigger('swipe' + swipeDirection(touch.x1, touch.x2, touch.y1, touch.y2));\n        touch = {};\n      }, 0);\n\n      // normal tap\n      else if ('last' in touch)\n          // don't fire tap when delta position changed by more than 30 pixels,\n          // for instance when moving to a point and back to origin\n          if (deltaX < 30 && deltaY < 30) {\n            // delay by one tick so we can cancel the 'tap' event if 'scroll' fires\n            // ('tap' fires before 'scroll')\n            tapTimeout = setTimeout(function () {\n\n              // trigger universal 'tap' with the option to cancelTouch()\n              // (cancelTouch cancels processing of single vs double taps for faster 'tap' response)\n              var event = $.Event('tap');\n              event.cancelTouch = cancelAll;\n              touch.el.trigger(event);\n\n              // trigger double tap immediately\n              if (touch.isDoubleTap) {\n                if (touch.el) touch.el.trigger('doubleTap');\n                touch = {};\n              }\n\n              // trigger single tap after 250ms of inactivity\n              else {\n                  touchTimeout = setTimeout(function () {\n                    touchTimeout = null;\n                    if (touch.el) touch.el.trigger('singleTap');\n                    touch = {};\n                  }, 250);\n                }\n            }, 0);\n          } else {\n            touch = {};\n          }\n      deltaX = deltaY = 0;\n    })\n    // when the browser window loses focus,\n    // for example when a modal dialog is shown,\n    // cancel all ongoing events\n    .on('touchcancel MSPointerCancel pointercancel', cancelAll);\n\n    // scrolling the window indicates intention of the user\n    // to scroll, not tap or swipe, so cancel all ongoing events\n    $(window).on('scroll', cancelAll);\n  });['swipe', 'swipeLeft', 'swipeRight', 'swipeUp', 'swipeDown', 'doubleTap', 'tap', 'singleTap', 'longTap'].forEach(function (eventName) {\n    $.fn[eventName] = function (callback) {\n      return this.on(eventName, callback);\n    };\n  });\n})(Zepto);\n\n!function (factory) {\n  if (true) {\n    !(__WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  }\n}(function (require, exports, module) {\n  module.exports = Zepto;\n});//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9FOi9naXRfcHJvL2V4cHJlc3Mtd2VicGFjay12dWUvc3JjL3V0aWwvemVwdG8uanM/NDlmMiJdLCJuYW1lcyI6WyJaZXB0byIsInVuZGVmaW5lZCIsImtleSIsIiQiLCJjbGFzc0xpc3QiLCJlbXB0eUFycmF5Iiwic2xpY2UiLCJmaWx0ZXIiLCJkb2N1bWVudCIsIndpbmRvdyIsImVsZW1lbnREaXNwbGF5IiwiY2xhc3NDYWNoZSIsImNzc051bWJlciIsImZyYWdtZW50UkUiLCJzaW5nbGVUYWdSRSIsInRhZ0V4cGFuZGVyUkUiLCJyb290Tm9kZVJFIiwiY2FwaXRhbFJFIiwibWV0aG9kQXR0cmlidXRlcyIsImFkamFjZW5jeU9wZXJhdG9ycyIsInRhYmxlIiwiY3JlYXRlRWxlbWVudCIsInRhYmxlUm93IiwiY29udGFpbmVycyIsInJlYWR5UkUiLCJzaW1wbGVTZWxlY3RvclJFIiwiY2xhc3MydHlwZSIsInRvU3RyaW5nIiwiemVwdG8iLCJjYW1lbGl6ZSIsInVuaXEiLCJ0ZW1wUGFyZW50IiwicHJvcE1hcCIsImlzQXJyYXkiLCJBcnJheSIsIm9iamVjdCIsIm1hdGNoZXMiLCJlbGVtZW50Iiwic2VsZWN0b3IiLCJub2RlVHlwZSIsIm1hdGNoZXNTZWxlY3RvciIsIndlYmtpdE1hdGNoZXNTZWxlY3RvciIsIm1vek1hdGNoZXNTZWxlY3RvciIsIm9NYXRjaGVzU2VsZWN0b3IiLCJjYWxsIiwibWF0Y2giLCJwYXJlbnQiLCJwYXJlbnROb2RlIiwidGVtcCIsImFwcGVuZENoaWxkIiwicXNhIiwiaW5kZXhPZiIsInJlbW92ZUNoaWxkIiwidHlwZSIsIm9iaiIsIlN0cmluZyIsImlzRnVuY3Rpb24iLCJ2YWx1ZSIsImlzV2luZG93IiwiaXNEb2N1bWVudCIsIkRPQ1VNRU5UX05PREUiLCJpc09iamVjdCIsImlzUGxhaW5PYmplY3QiLCJPYmplY3QiLCJnZXRQcm90b3R5cGVPZiIsInByb3RvdHlwZSIsImxpa2VBcnJheSIsImxlbmd0aCIsImNvbXBhY3QiLCJhcnJheSIsIml0ZW0iLCJmbGF0dGVuIiwiZm4iLCJjb25jYXQiLCJhcHBseSIsInN0ciIsInJlcGxhY2UiLCJjaHIiLCJ0b1VwcGVyQ2FzZSIsImRhc2hlcml6ZSIsInRvTG93ZXJDYXNlIiwiaWR4IiwiY2xhc3NSRSIsIm5hbWUiLCJSZWdFeHAiLCJtYXliZUFkZFB4IiwiZGVmYXVsdERpc3BsYXkiLCJub2RlTmFtZSIsImRpc3BsYXkiLCJib2R5IiwiZ2V0Q29tcHV0ZWRTdHlsZSIsImdldFByb3BlcnR5VmFsdWUiLCJjaGlsZHJlbiIsIm1hcCIsImNoaWxkTm9kZXMiLCJub2RlIiwiZnJhZ21lbnQiLCJodG1sIiwicHJvcGVydGllcyIsImRvbSIsIm5vZGVzIiwiY29udGFpbmVyIiwidGVzdCIsIiQxIiwiaW5uZXJIVE1MIiwiZWFjaCIsImF0dHIiLCJaIiwiX19wcm90b19fIiwiaXNaIiwiaW5pdCIsImNvbnRleHQiLCJ0cmltIiwiZmluZCIsInJlYWR5IiwiZXh0ZW5kIiwidGFyZ2V0Iiwic291cmNlIiwiZGVlcCIsImFyZ3MiLCJhcmd1bWVudHMiLCJzaGlmdCIsImZvckVhY2giLCJhcmciLCJmb3VuZCIsIm1heWJlSUQiLCJtYXliZUNsYXNzIiwibmFtZU9ubHkiLCJpc1NpbXBsZSIsImdldEVsZW1lbnRCeUlkIiwiZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSIsImdldEVsZW1lbnRzQnlUYWdOYW1lIiwicXVlcnlTZWxlY3RvckFsbCIsImZpbHRlcmVkIiwiY29udGFpbnMiLCJkb2N1bWVudEVsZW1lbnQiLCJmdW5jQXJnIiwicGF5bG9hZCIsInNldEF0dHJpYnV0ZSIsInJlbW92ZUF0dHJpYnV0ZSIsImNsYXNzTmFtZSIsImtsYXNzIiwic3ZnIiwiYmFzZVZhbCIsImRlc2VyaWFsaXplVmFsdWUiLCJudW0iLCJpc05hTiIsIk51bWJlciIsInBhcnNlSlNPTiIsImUiLCJpc0VtcHR5T2JqZWN0IiwiaW5BcnJheSIsImVsZW0iLCJpIiwiY2FtZWxDYXNlIiwidXVpZCIsInN1cHBvcnQiLCJleHByIiwiZWxlbWVudHMiLCJjYWxsYmFjayIsInZhbHVlcyIsInB1c2giLCJncmVwIiwiSlNPTiIsInBhcnNlIiwic3BsaXQiLCJyZWR1Y2UiLCJzb3J0IiwiZWwiLCJyZWFkeVN0YXRlIiwiYWRkRXZlbnRMaXN0ZW5lciIsImdldCIsInRvQXJyYXkiLCJzaXplIiwicmVtb3ZlIiwiZXZlcnkiLCJub3QiLCJhZGQiLCJpcyIsImV4Y2x1ZGVzIiwiaGFzIiwiZXEiLCJmaXJzdCIsImxhc3QiLCJyZXN1bHQiLCIkdGhpcyIsInNvbWUiLCJjbG9zZXN0IiwiY29sbGVjdGlvbiIsInBhcmVudHMiLCJhbmNlc3RvcnMiLCJwbHVjayIsImNvbnRlbnRzIiwic2libGluZ3MiLCJjaGlsZCIsImVtcHR5IiwicHJvcGVydHkiLCJzaG93Iiwic3R5bGUiLCJyZXBsYWNlV2l0aCIsIm5ld0NvbnRlbnQiLCJiZWZvcmUiLCJ3cmFwIiwic3RydWN0dXJlIiwiZnVuYyIsImNsb25lIiwiaW5kZXgiLCJ3cmFwQWxsIiwiY2xvbmVOb2RlIiwiYXBwZW5kIiwid3JhcElubmVyIiwic2VsZiIsInVud3JhcCIsImhpZGUiLCJjc3MiLCJ0b2dnbGUiLCJzZXR0aW5nIiwicHJldiIsIm5leHQiLCJvcmlnaW5IdG1sIiwidGV4dCIsIm5ld1RleHQiLCJ0ZXh0Q29udGVudCIsImdldEF0dHJpYnV0ZSIsInJlbW92ZUF0dHIiLCJwcm9wIiwiZGF0YSIsImF0dHJOYW1lIiwidmFsIiwibXVsdGlwbGUiLCJzZWxlY3RlZCIsIm9mZnNldCIsImNvb3JkaW5hdGVzIiwiY29vcmRzIiwicGFyZW50T2Zmc2V0Iiwib2Zmc2V0UGFyZW50IiwicHJvcHMiLCJ0b3AiLCJsZWZ0IiwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0IiwicGFnZVhPZmZzZXQiLCJwYWdlWU9mZnNldCIsIndpZHRoIiwiTWF0aCIsInJvdW5kIiwiaGVpZ2h0IiwiY29tcHV0ZWRTdHlsZSIsIl8iLCJyZW1vdmVQcm9wZXJ0eSIsImNzc1RleHQiLCJoYXNDbGFzcyIsImFkZENsYXNzIiwiY2xzIiwibmV3TmFtZSIsImpvaW4iLCJyZW1vdmVDbGFzcyIsInRvZ2dsZUNsYXNzIiwid2hlbiIsIm5hbWVzIiwic2Nyb2xsVG9wIiwiaGFzU2Nyb2xsVG9wIiwic2Nyb2xsVG8iLCJzY3JvbGxYIiwic2Nyb2xsTGVmdCIsImhhc1Njcm9sbExlZnQiLCJzY3JvbGxZIiwicG9zaXRpb24iLCJwYXJzZUZsb2F0IiwiZGV0YWNoIiwiZGltZW5zaW9uIiwiZGltZW5zaW9uUHJvcGVydHkiLCJtIiwidHJhdmVyc2VOb2RlIiwiZnVuIiwibGVuIiwib3BlcmF0b3IiLCJvcGVyYXRvckluZGV4IiwiaW5zaWRlIiwiYXJnVHlwZSIsImNvcHlCeUNsb25lIiwibmV4dFNpYmxpbmciLCJmaXJzdENoaWxkIiwicGFyZW50SW5Eb2N1bWVudCIsImluc2VydEJlZm9yZSIsInNyYyIsImpzb25wSUQiLCJyc2NyaXB0Iiwic2NyaXB0VHlwZVJFIiwieG1sVHlwZVJFIiwianNvblR5cGUiLCJodG1sVHlwZSIsImJsYW5rUkUiLCJ0cmlnZ2VyQW5kUmV0dXJuIiwiZXZlbnROYW1lIiwiZXZlbnQiLCJFdmVudCIsInRyaWdnZXIiLCJpc0RlZmF1bHRQcmV2ZW50ZWQiLCJ0cmlnZ2VyR2xvYmFsIiwic2V0dGluZ3MiLCJnbG9iYWwiLCJhY3RpdmUiLCJhamF4U3RhcnQiLCJhamF4U3RvcCIsImFqYXhCZWZvcmVTZW5kIiwieGhyIiwiYmVmb3JlU2VuZCIsImFqYXhTdWNjZXNzIiwiZGVmZXJyZWQiLCJzdGF0dXMiLCJzdWNjZXNzIiwicmVzb2x2ZVdpdGgiLCJhamF4Q29tcGxldGUiLCJhamF4RXJyb3IiLCJlcnJvciIsInJlamVjdFdpdGgiLCJjb21wbGV0ZSIsImFqYXhKU09OUCIsIm9wdGlvbnMiLCJhamF4IiwiX2NhbGxiYWNrTmFtZSIsImpzb25wQ2FsbGJhY2siLCJjYWxsYmFja05hbWUiLCJzY3JpcHQiLCJvcmlnaW5hbENhbGxiYWNrIiwicmVzcG9uc2VEYXRhIiwiYWJvcnQiLCJlcnJvclR5cGUiLCJ0cmlnZ2VySGFuZGxlciIsImFib3J0VGltZW91dCIsInByb21pc2UiLCJvbiIsImNsZWFyVGltZW91dCIsIm9mZiIsInVybCIsImhlYWQiLCJ0aW1lb3V0Iiwic2V0VGltZW91dCIsImFqYXhTZXR0aW5ncyIsIlhNTEh0dHBSZXF1ZXN0IiwiYWNjZXB0cyIsImpzb24iLCJ4bWwiLCJjcm9zc0RvbWFpbiIsInByb2Nlc3NEYXRhIiwiY2FjaGUiLCJtaW1lVG9EYXRhVHlwZSIsIm1pbWUiLCJhcHBlbmRRdWVyeSIsInF1ZXJ5Iiwic2VyaWFsaXplRGF0YSIsInBhcmFtIiwidHJhZGl0aW9uYWwiLCJEZWZlcnJlZCIsIiQyIiwibG9jYXRpb24iLCJob3N0IiwiZGF0YVR5cGUiLCJoYXNQbGFjZWhvbGRlciIsIkRhdGUiLCJub3ciLCJqc29ucCIsImhlYWRlcnMiLCJzZXRIZWFkZXIiLCJwcm90b2NvbCIsIm5hdGl2ZVNldEhlYWRlciIsInNldFJlcXVlc3RIZWFkZXIiLCJtaW1lVHlwZSIsIm92ZXJyaWRlTWltZVR5cGUiLCJjb250ZW50VHlwZSIsIm9ucmVhZHlzdGF0ZWNoYW5nZSIsImdldFJlc3BvbnNlSGVhZGVyIiwicmVzcG9uc2VUZXh0IiwiZXZhbCIsInJlc3BvbnNlWE1MIiwic3RhdHVzVGV4dCIsInhockZpZWxkcyIsImFzeW5jIiwib3BlbiIsInVzZXJuYW1lIiwicGFzc3dvcmQiLCJzZW5kIiwicGFyc2VBcmd1bWVudHMiLCJwb3N0IiwiZ2V0SlNPTiIsImxvYWQiLCJwYXJ0cyIsInJlc3BvbnNlIiwiZXNjYXBlIiwiZW5jb2RlVVJJQ29tcG9uZW50Iiwic2VyaWFsaXplIiwicGFyYW1zIiwic2NvcGUiLCJoYXNoIiwiayIsInYiLCJ0YWdOYW1lIiwiQ2FsbGJhY2tzIiwibWVtb3J5IiwiZmlyZWQiLCJmaXJpbmciLCJmaXJpbmdTdGFydCIsImZpcmluZ0xlbmd0aCIsImZpcmluZ0luZGV4IiwibGlzdCIsInN0YWNrIiwib25jZSIsImZpcmUiLCJzdG9wT25GYWxzZSIsImRpc2FibGUiLCJzdGFydCIsInVuaXF1ZSIsInNwbGljZSIsImRpc2FibGVkIiwibG9jayIsImxvY2tlZCIsImZpcmVXaXRoIiwiZGF0YUF0dHIiLCJleHAiLCJleHBhbmRvIiwiZ2V0RGF0YSIsImlkIiwic3RvcmUiLCJzZXREYXRhIiwiY2FtZWxOYW1lIiwiYXR0cmlidXRlRGF0YSIsImF0dHJpYnV0ZXMiLCJyZW1vdmVEYXRhIiwibWV0aG9kTmFtZSIsIm9yaWdGbiIsInR1cGxlcyIsInN0YXRlIiwiYWx3YXlzIiwiZG9uZSIsImZhaWwiLCJ0aGVuIiwiZm5zIiwiZGVmZXIiLCJ0dXBsZSIsInJldHVybmVkIiwicmVzb2x2ZSIsInJlamVjdCIsInByb2dyZXNzIiwibm90aWZ5Iiwic3RhdGVTdHJpbmciLCJzdWIiLCJyZXNvbHZlVmFsdWVzIiwicmVtYWluIiwicHJvZ3Jlc3NWYWx1ZXMiLCJwcm9ncmVzc0NvbnRleHRzIiwicmVzb2x2ZUNvbnRleHRzIiwidXBkYXRlRm4iLCJjdHgiLCJub3RpZnlXaXRoIiwiZGV0ZWN0IiwidWEiLCJvcyIsImJyb3dzZXIiLCJ3ZWJraXQiLCJhbmRyb2lkIiwib3N4IiwiaXBhZCIsImlwb2QiLCJpcGhvbmUiLCJ3ZWJvcyIsIndwIiwidG91Y2hwYWQiLCJraW5kbGUiLCJzaWxrIiwiYmxhY2tiZXJyeSIsImJiMTAiLCJyaW10YWJsZXRvcyIsInBsYXlib29rIiwiY2hyb21lIiwiZmlyZWZveCIsImllIiwid2VidmlldyIsInNhZmFyaSIsInZlcnNpb24iLCJpb3MiLCJ0YWJsZXQiLCJwaG9uZSIsIm5hdmlnYXRvciIsInVzZXJBZ2VudCIsIl9fZGV0ZWN0IiwiX3ppZCIsImlzU3RyaW5nIiwiaGFuZGxlcnMiLCJzcGVjaWFsRXZlbnRzIiwiZm9jdXNpblN1cHBvcnRlZCIsImZvY3VzIiwiYmx1ciIsImhvdmVyIiwibW91c2VlbnRlciIsIm1vdXNlbGVhdmUiLCJjbGljayIsIm1vdXNlZG93biIsIm1vdXNldXAiLCJtb3VzZW1vdmUiLCJ6aWQiLCJmaW5kSGFuZGxlcnMiLCJucyIsIm1hdGNoZXIiLCJtYXRjaGVyRm9yIiwiaGFuZGxlciIsInNlbCIsImV2ZW50Q2FwdHVyZSIsImNhcHR1cmVTZXR0aW5nIiwiZGVsIiwicmVhbEV2ZW50IiwiZXZlbnRzIiwiZGVsZWdhdG9yIiwiY2FwdHVyZSIsInNldCIsInJlbGF0ZWQiLCJyZWxhdGVkVGFyZ2V0IiwicHJveHkiLCJjb21wYXRpYmxlIiwiaXNJbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWQiLCJfYXJncyIsInByZXZlbnREZWZhdWx0Iiwic3RvcFByb3BhZ2F0aW9uIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsInByb3h5Rm4iLCJ1bnNoaWZ0IiwiVHlwZUVycm9yIiwiYmluZCIsInVuYmluZCIsIm9uZSIsInJldHVyblRydWUiLCJyZXR1cm5GYWxzZSIsImlnbm9yZVByb3BlcnRpZXMiLCJldmVudE1ldGhvZHMiLCJzdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24iLCJwcmVkaWNhdGUiLCJzb3VyY2VNZXRob2QiLCJkZWZhdWx0UHJldmVudGVkIiwicmV0dXJuVmFsdWUiLCJnZXRQcmV2ZW50RGVmYXVsdCIsImNyZWF0ZVByb3h5Iiwib3JpZ2luYWxFdmVudCIsImRlbGVnYXRlIiwidW5kZWxlZ2F0ZSIsImxpdmUiLCJkaWUiLCJhdXRvUmVtb3ZlIiwiZXZ0IiwiY3VycmVudFRhcmdldCIsImxpdmVGaXJlZCIsImRpc3BhdGNoRXZlbnQiLCJjcmVhdGVFdmVudCIsImJ1YmJsZXMiLCJpbml0RXZlbnQiLCJzZXJpYWxpemVBcnJheSIsImNoZWNrZWQiLCJlbG0iLCJzdWJtaXQiLCJkb2NFbGVtIiwib3JpZ1Nob3ciLCJvcmlnSGlkZSIsIm9yaWdUb2dnbGUiLCJhbmltIiwic3BlZWQiLCJvcGFjaXR5Iiwic2NhbGUiLCJmeCIsImNzc1ByZWZpeCIsImFuaW1hdGUiLCJmYWRlVG8iLCJmYWRlSW4iLCJmYWRlT3V0IiwiZmFkZVRvZ2dsZSIsInByZWZpeCIsImV2ZW50UHJlZml4IiwiZW5kRXZlbnROYW1lIiwiZW5kQW5pbWF0aW9uTmFtZSIsInZlbmRvcnMiLCJXZWJraXQiLCJNb3oiLCJPIiwidGVzdEVsIiwic3VwcG9ydGVkVHJhbnNmb3JtcyIsInRyYW5zZm9ybSIsInRyYW5zaXRpb25Qcm9wZXJ0eSIsInRyYW5zaXRpb25EdXJhdGlvbiIsInRyYW5zaXRpb25UaW1pbmciLCJ0cmFuc2l0aW9uRGVsYXkiLCJhbmltYXRpb25OYW1lIiwiYW5pbWF0aW9uRHVyYXRpb24iLCJhbmltYXRpb25UaW1pbmciLCJhbmltYXRpb25EZWxheSIsImNzc1Jlc2V0Iiwibm9ybWFsaXplRXZlbnQiLCJ2ZW5kb3IiLCJzcGVlZHMiLCJfZGVmYXVsdCIsImZhc3QiLCJzbG93IiwidHJhbnNpdGlvbkVuZCIsImFuaW1hdGlvbkVuZCIsImR1cmF0aW9uIiwiZWFzZSIsImRlbGF5IiwiZWFzaW5nIiwiY3NzVmFsdWVzIiwiY3NzUHJvcGVydGllcyIsInRyYW5zZm9ybXMiLCJ0aGF0Iiwid3JhcHBlZENhbGxiYWNrIiwiZW5kRXZlbnQiLCJjbGllbnRMZWZ0IiwiZ2VzdHVyZSIsImdlc3R1cmVUaW1lb3V0IiwicGFyZW50SWZUZXh0IiwiZGVsdGEiLCJlMSIsImUyIiwiYWJzIiwiX19aIiwibmF0aXZlR2V0Q29tcHV0ZWRTdHlsZSIsIm9sZFFzYSIsIm9sZE1hdGNoZXMiLCJ2aXNpYmxlIiwiZmlsdGVycyIsImhpZGRlbiIsImZpbHRlclJlIiwiY2hpbGRSZSIsImNsYXNzVGFnIiwicHJvY2VzcyIsImV4ZWMiLCJ0YWdnZWRQYXJlbnQiLCJjb25zb2xlIiwibiIsImVuZCIsInByZXZPYmplY3QiLCJhbmRTZWxmIiwicmV0IiwidG91Y2giLCJ0b3VjaFRpbWVvdXQiLCJ0YXBUaW1lb3V0Iiwic3dpcGVUaW1lb3V0IiwibG9uZ1RhcFRpbWVvdXQiLCJsb25nVGFwRGVsYXkiLCJzd2lwZURpcmVjdGlvbiIsIngxIiwieDIiLCJ5MSIsInkyIiwibG9uZ1RhcCIsImNhbmNlbExvbmdUYXAiLCJjYW5jZWxBbGwiLCJpc1ByaW1hcnlUb3VjaCIsInBvaW50ZXJUeXBlIiwiTVNQT0lOVEVSX1RZUEVfVE9VQ0giLCJpc1ByaW1hcnkiLCJpc1BvaW50ZXJFdmVudFR5cGUiLCJkZWx0YVgiLCJkZWx0YVkiLCJmaXJzdFRvdWNoIiwiX2lzUG9pbnRlclR5cGUiLCJNU0dlc3R1cmUiLCJzd2lwZURpcmVjdGlvbkZyb21WZWxvY2l0eSIsInZlbG9jaXR5WCIsInZlbG9jaXR5WSIsInRvdWNoZXMiLCJwYWdlWCIsInBhZ2VZIiwiaXNEb3VibGVUYXAiLCJhZGRQb2ludGVyIiwicG9pbnRlcklkIiwiY2FuY2VsVG91Y2giLCJmYWN0b3J5IiwiZGVmaW5lIiwicmVxdWlyZSIsImV4cG9ydHMiLCJtb2R1bGUiXSwibWFwcGluZ3MiOiI7Ozs7QUFBQTs7QUFFQSxJQUFJQSxRQUFTLFlBQVc7QUFDdEIsTUFBSUMsU0FBSjtBQUFBLE1BQWVDLEdBQWY7QUFBQSxNQUFvQkMsQ0FBcEI7QUFBQSxNQUF1QkMsU0FBdkI7QUFBQSxNQUFrQ0MsYUFBYSxFQUEvQztBQUFBLE1BQW1EQyxTQUFRRCxXQUFXQyxLQUF0RTtBQUFBLE1BQTZFQyxVQUFTRixXQUFXRSxNQUFqRztBQUFBLE1BQ0VDLFdBQVdDLE9BQU9ELFFBRHBCO0FBQUEsTUFFRUUsaUJBQWlCLEVBRm5CO0FBQUEsTUFFdUJDLGFBQWEsRUFGcEM7QUFBQSxNQUdFQyxZQUFZLEVBQUUsZ0JBQWdCLENBQWxCLEVBQXFCLFdBQVcsQ0FBaEMsRUFBbUMsZUFBZSxDQUFsRCxFQUFxRCxlQUFlLENBQXBFLEVBQXNFLFdBQVcsQ0FBakYsRUFBb0YsV0FBVyxDQUEvRixFQUFrRyxRQUFRLENBQTFHLEVBSGQ7QUFBQSxNQUlFQyxhQUFhLG9CQUpmO0FBQUEsTUFLRUMsY0FBYyw0QkFMaEI7QUFBQSxNQU1FQyxnQkFBZ0IseUVBTmxCO0FBQUEsTUFPRUMsYUFBYSxrQkFQZjtBQUFBLE1BUUVDLFlBQVksVUFSZDs7O0FBVUU7QUFDQUMscUJBQW1CLENBQUMsS0FBRCxFQUFRLEtBQVIsRUFBZSxNQUFmLEVBQXVCLE1BQXZCLEVB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YXggYXNzZXRzIGNhbGxiYWNrcyBkYXRhIGRlZmVycmVkIGRldGVjdCBldmVudCBmb3JtIGZ4X21ldGhvZHMgZnggZ2VzdHVyZSBpZSBzZWxlY3RvciBzdGFjayB0b3VjaCAtIHplcHRvanMuY29tL2xpY2Vuc2UgKi9cclxuXHJcbnZhciBaZXB0byA9IChmdW5jdGlvbigpIHtcclxuICB2YXIgdW5kZWZpbmVkLCBrZXksICQsIGNsYXNzTGlzdCwgZW1wdHlBcnJheSA9IFtdLCBzbGljZSA9IGVtcHR5QXJyYXkuc2xpY2UsIGZpbHRlciA9IGVtcHR5QXJyYXkuZmlsdGVyLFxyXG4gICAgZG9jdW1lbnQgPSB3aW5kb3cuZG9jdW1lbnQsXHJcbiAgICBlbGVtZW50RGlzcGxheSA9IHt9LCBjbGFzc0NhY2hlID0ge30sXHJcbiAgICBjc3NOdW1iZXIgPSB7ICdjb2x1bW4tY291bnQnOiAxLCAnY29sdW1ucyc6IDEsICdmb250LXdlaWdodCc6IDEsICdsaW5lLWhlaWdodCc6IDEsJ29wYWNpdHknOiAxLCAnei1pbmRleCc6IDEsICd6b29tJzogMSB9LFxyXG4gICAgZnJhZ21lbnRSRSA9IC9eXFxzKjwoXFx3K3whKVtePl0qPi8sXHJcbiAgICBzaW5nbGVUYWdSRSA9IC9ePChcXHcrKVxccypcXC8/Pig/OjxcXC9cXDE+fCkkLyxcclxuICAgIHRhZ0V4cGFuZGVyUkUgPSAvPCg/IWFyZWF8YnJ8Y29sfGVtYmVkfGhyfGltZ3xpbnB1dHxsaW5rfG1ldGF8cGFyYW0pKChbXFx3Ol0rKVtePl0qKVxcLz4vaWcsXHJcbiAgICByb290Tm9kZVJFID0gL14oPzpib2R5fGh0bWwpJC9pLFxyXG4gICAgY2FwaXRhbFJFID0gLyhbQS1aXSkvZyxcclxuXHJcbiAgICAvLyBzcGVjaWFsIGF0dHJpYnV0ZXMgdGhhdCBzaG91bGQgYmUgZ2V0L3NldCB2aWEgbWV0aG9kIGNhbGxzXHJcbiAgICBtZXRob2RBdHRyaWJ1dGVzID0gWyd2YWwnLCAnY3NzJywgJ2h0bWwnLCAndGV4dCcsICdkYXRhJywgJ3dpZHRoJywgJ2hlaWdodCcsICdvZmZzZXQnXSxcclxuXHJcbiAgICBhZGphY2VuY3lPcGVyYXRvcnMgPSBbICdhZnRlcicsICdwcmVwZW5kJywgJ2JlZm9yZScsICdhcHBlbmQnIF0sXHJcbiAgICB0YWJsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RhYmxlJyksXHJcbiAgICB0YWJsZVJvdyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RyJyksXHJcbiAgICBjb250YWluZXJzID0ge1xyXG4gICAgICAndHInOiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0Ym9keScpLFxyXG4gICAgICAndGJvZHknOiB0YWJsZSwgJ3RoZWFkJzogdGFibGUsICd0Zm9vdCc6IHRhYmxlLFxyXG4gICAgICAndGQnOiB0YWJsZVJvdywgJ3RoJzogdGFibGVSb3csXHJcbiAgICAgICcqJzogZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JylcclxuICAgIH0sXHJcbiAgICByZWFkeVJFID0gL2NvbXBsZXRlfGxvYWRlZHxpbnRlcmFjdGl2ZS8sXHJcbiAgICBzaW1wbGVTZWxlY3RvclJFID0gL15bXFx3LV0qJC8sXHJcbiAgICBjbGFzczJ0eXBlID0ge30sXHJcbiAgICB0b1N0cmluZyA9IGNsYXNzMnR5cGUudG9TdHJpbmcsXHJcbiAgICB6ZXB0byA9IHt9LFxyXG4gICAgY2FtZWxpemUsIHVuaXEsXHJcbiAgICB0ZW1wUGFyZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JyksXHJcbiAgICBwcm9wTWFwID0ge1xyXG4gICAgICAndGFiaW5kZXgnOiAndGFiSW5kZXgnLFxyXG4gICAgICAncmVhZG9ubHknOiAncmVhZE9ubHknLFxyXG4gICAgICAnZm9yJzogJ2h0bWxGb3InLFxyXG4gICAgICAnY2xhc3MnOiAnY2xhc3NOYW1lJyxcclxuICAgICAgJ21heGxlbmd0aCc6ICdtYXhMZW5ndGgnLFxyXG4gICAgICAnY2VsbHNwYWNpbmcnOiAnY2VsbFNwYWNpbmcnLFxyXG4gICAgICAnY2VsbHBhZGRpbmcnOiAnY2VsbFBhZGRpbmcnLFxyXG4gICAgICAncm93c3Bhbic6ICdyb3dTcGFuJyxcclxuICAgICAgJ2NvbHNwYW4nOiAnY29sU3BhbicsXHJcbiAgICAgICd1c2VtYXAnOiAndXNlTWFwJyxcclxuICAgICAgJ2ZyYW1lYm9yZGVyJzogJ2ZyYW1lQm9yZGVyJyxcclxuICAgICAgJ2NvbnRlbnRlZGl0YWJsZSc6ICdjb250ZW50RWRpdGFibGUnXHJcbiAgICB9LFxyXG4gICAgaXNBcnJheSA9IEFycmF5LmlzQXJyYXkgfHxcclxuICAgICAgZnVuY3Rpb24ob2JqZWN0KXsgcmV0dXJuIG9iamVjdCBpbnN0YW5jZW9mIEFycmF5IH1cclxuXHJcbiAgemVwdG8ubWF0Y2hlcyA9IGZ1bmN0aW9uKGVsZW1lbnQsIHNlbGVjdG9yKSB7XHJcbiAgICBpZiAoIXNlbGVjdG9yIHx8ICFlbGVtZW50IHx8IGVsZW1lbnQubm9kZVR5cGUgIT09IDEpIHJldHVybiBmYWxzZVxyXG4gICAgdmFyIG1hdGNoZXNTZWxlY3RvciA9IGVsZW1lbnQud2Via2l0TWF0Y2hlc1NlbGVjdG9yIHx8IGVsZW1lbnQubW96TWF0Y2hlc1NlbGVjdG9yIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5vTWF0Y2hlc1NlbGVjdG9yIHx8IGVsZW1lbnQubWF0Y2hlc1NlbGVjdG9yXHJcbiAgICBpZiAobWF0Y2hlc1NlbGVjdG9yKSByZXR1cm4gbWF0Y2hlc1NlbGVjdG9yLmNhbGwoZWxlbWVudCwgc2VsZWN0b3IpXHJcbiAgICAvLyBmYWxsIGJhY2sgdG8gcGVyZm9ybWluZyBhIHNlbGVjdG9yOlxyXG4gICAgdmFyIG1hdGNoLCBwYXJlbnQgPSBlbGVtZW50LnBhcmVudE5vZGUsIHRlbXAgPSAhcGFyZW50XHJcbiAgICBpZiAodGVtcCkgKHBhcmVudCA9IHRlbXBQYXJlbnQpLmFwcGVuZENoaWxkKGVsZW1lbnQpXHJcbiAgICBtYXRjaCA9IH56ZXB0by5xc2EocGFyZW50LCBzZWxlY3RvcikuaW5kZXhPZihlbGVtZW50KVxyXG4gICAgdGVtcCAmJiB0ZW1wUGFyZW50LnJlbW92ZUNoaWxkKGVsZW1lbnQpXHJcbiAgICByZXR1cm4gbWF0Y2hcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIHR5cGUob2JqKSB7XHJcbiAgICByZXR1cm4gb2JqID09IG51bGwgPyBTdHJpbmcob2JqKSA6XHJcbiAgICAgIGNsYXNzMnR5cGVbdG9TdHJpbmcuY2FsbChvYmopXSB8fCBcIm9iamVjdFwiXHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBpc0Z1bmN0aW9uKHZhbHVlKSB7IHJldHVybiB0eXBlKHZhbHVlKSA9PSBcImZ1bmN0aW9uXCIgfVxyXG4gIGZ1bmN0aW9uIGlzV2luZG93KG9iaikgICAgIHsgcmV0dXJuIG9iaiAhPSBudWxsICYmIG9iaiA9PSBvYmoud2luZG93IH1cclxuICBmdW5jdGlvbiBpc0RvY3VtZW50KG9iaikgICB7IHJldHVybiBvYmogIT0gbnVsbCAmJiBvYmoubm9kZVR5cGUgPT0gb2JqLkRPQ1VNRU5UX05PREUgfVxyXG4gIGZ1bmN0aW9uIGlzT2JqZWN0KG9iaikgICAgIHsgcmV0dXJuIHR5cGUob2JqKSA9PSBcIm9iamVjdFwiIH1cclxuICBmdW5jdGlvbiBpc1BsYWluT2JqZWN0KG9iaikge1xyXG4gICAgcmV0dXJuIGlzT2JqZWN0KG9iaikgJiYgIWlzV2luZG93KG9iaikgJiYgT2JqZWN0LmdldFByb3RvdHlwZU9mKG9iaikgPT0gT2JqZWN0LnByb3RvdHlwZVxyXG4gIH1cclxuICBmdW5jdGlvbiBsaWtlQXJyYXkob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqLmxlbmd0aCA9PSAnbnVtYmVyJyB9XHJcblxyXG4gIGZ1bmN0aW9uIGNvbXBhY3QoYXJyYXkpIHsgcmV0dXJuIGZpbHRlci5jYWxsKGFycmF5LCBmdW5jdGlvbihpdGVtKXsgcmV0dXJuIGl0ZW0gIT0gbnVsbCB9KSB9XHJcbiAgZnVuY3Rpb24gZmxhdHRlbihhcnJheSkgeyByZXR1cm4gYXJyYXkubGVuZ3RoID4gMCA/ICQuZm4uY29uY2F0LmFwcGx5KFtdLCBhcnJheSkgOiBhcnJheSB9XHJcbiAgY2FtZWxpemUgPSBmdW5jdGlvbihzdHIpeyByZXR1cm4gc3RyLnJlcGxhY2UoLy0rKC4pPy9nLCBmdW5jdGlvbihtYXRjaCwgY2hyKXsgcmV0dXJuIGNociA/IGNoci50b1VwcGVyQ2FzZSgpIDogJycgfSkgfVxyXG4gIGZ1bmN0aW9uIGRhc2hlcml6ZShzdHIpIHtcclxuICAgIHJldHVybiBzdHIucmVwbGFjZSgvOjovZywgJy8nKVxyXG4gICAgICAgICAgIC5yZXBsYWNlKC8oW0EtWl0rKShbQS1aXVthLXpdKS9nLCAnJDFfJDInKVxyXG4gICAgICAgICAgIC5yZXBsYWNlKC8oW2EtelxcZF0pKFtBLVpdKS9nLCAnJDFfJDInKVxyXG4gICAgICAgICAgIC5yZXBsYWNlKC9fL2csICctJylcclxuICAgICAgICAgICAudG9Mb3dlckNhc2UoKVxyXG4gIH1cclxuICB1bmlxID0gZnVuY3Rpb24oYXJyYXkpeyByZXR1cm4gZmlsdGVyLmNhbGwoYXJyYXksIGZ1bmN0aW9uKGl0ZW0sIGlkeCl7IHJldHVybiBhcnJheS5pbmRleE9mKGl0ZW0pID09IGlkeCB9KSB9XHJcblxyXG4gIGZ1bmN0aW9uIGNsYXNzUkUobmFtZSkge1xyXG4gICAgcmV0dXJuIG5hbWUgaW4gY2xhc3NDYWNoZSA/XHJcbiAgICAgIGNsYXNzQ2FjaGVbbmFtZV0gOiAoY2xhc3NDYWNoZVtuYW1lXSA9IG5ldyBSZWdFeHAoJyhefFxcXFxzKScgKyBuYW1lICsgJyhcXFxcc3wkKScpKVxyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gbWF5YmVBZGRQeChuYW1lLCB2YWx1ZSkge1xyXG4gICAgcmV0dXJuICh0eXBlb2YgdmFsdWUgPT0gXCJudW1iZXJcIiAmJiAhY3NzTnVtYmVyW2Rhc2hlcml6ZShuYW1lKV0pID8gdmFsdWUgKyBcInB4XCIgOiB2YWx1ZVxyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gZGVmYXVsdERpc3BsYXkobm9kZU5hbWUpIHtcclxuICAgIHZhciBlbGVtZW50LCBkaXNwbGF5XHJcbiAgICBpZiAoIWVsZW1lbnREaXNwbGF5W25vZGVOYW1lXSkge1xyXG4gICAgICBlbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChub2RlTmFtZSlcclxuICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChlbGVtZW50KVxyXG4gICAgICBkaXNwbGF5ID0gZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50LCAnJykuZ2V0UHJvcGVydHlWYWx1ZShcImRpc3BsYXlcIilcclxuICAgICAgZWxlbWVudC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGVsZW1lbnQpXHJcbiAgICAgIGRpc3BsYXkgPT0gXCJub25lXCIgJiYgKGRpc3BsYXkgPSBcImJsb2NrXCIpXHJcbiAgICAgIGVsZW1lbnREaXNwbGF5W25vZGVOYW1lXSA9IGRpc3BsYXlcclxuICAgIH1cclxuICAgIHJldHVybiBlbGVtZW50RGlzcGxheVtub2RlTmFtZV1cclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGNoaWxkcmVuKGVsZW1lbnQpIHtcclxuICAgIHJldHVybiAnY2hpbGRyZW4nIGluIGVsZW1lbnQgP1xyXG4gICAgICBzbGljZS5jYWxsKGVsZW1lbnQuY2hpbGRyZW4pIDpcclxuICAgICAgJC5tYXAoZWxlbWVudC5jaGlsZE5vZGVzLCBmdW5jdGlvbihub2RlKXsgaWYgKG5vZGUubm9kZVR5cGUgPT0gMSkgcmV0dXJuIG5vZGUgfSlcclxuICB9XHJcblxyXG4gIC8vIGAkLnplcHRvLmZyYWdtZW50YCB0YWtlcyBhIGh0bWwgc3RyaW5nIGFuZCBhbiBvcHRpb25hbCB0YWcgbmFtZVxyXG4gIC8vIHRvIGdlbmVyYXRlIERPTSBub2RlcyBub2RlcyBmcm9tIHRoZSBnaXZlbiBodG1sIHN0cmluZy5cclxuICAvLyBUaGUgZ2VuZXJhdGVkIERPTSBub2RlcyBhcmUgcmV0dXJuZWQgYXMgYW4gYXJyYXkuXHJcbiAgLy8gVGhpcyBmdW5jdGlvbiBjYW4gYmUgb3ZlcnJpZGVuIGluIHBsdWdpbnMgZm9yIGV4YW1wbGUgdG8gbWFrZVxyXG4gIC8vIGl0IGNvbXBhdGlibGUgd2l0aCBicm93c2VycyB0aGF0IGRvbid0IHN1cHBvcnQgdGhlIERPTSBmdWxseS5cclxuICB6ZXB0by5mcmFnbWVudCA9IGZ1bmN0aW9uKGh0bWwsIG5hbWUsIHByb3BlcnRpZXMpIHtcclxuICAgIHZhciBkb20sIG5vZGVzLCBjb250YWluZXJcclxuXHJcbiAgICAvLyBBIHNwZWNpYWwgY2FzZSBvcHRpbWl6YXRpb24gZm9yIGEgc2luZ2xlIHRhZ1xyXG4gICAgaWYgKHNpbmdsZVRhZ1JFLnRlc3QoaHRtbCkpIGRvbSA9ICQoZG9jdW1lbnQuY3JlYXRlRWxlbWVudChSZWdFeHAuJDEpKVxyXG5cclxuICAgIGlmICghZG9tKSB7XHJcbiAgICAgIGlmIChodG1sLnJlcGxhY2UpIGh0bWwgPSBodG1sLnJlcGxhY2UodGFnRXhwYW5kZXJSRSwgXCI8JDE+PC8kMj5cIilcclxuICAgICAgaWYgKG5hbWUgPT09IHVuZGVmaW5lZCkgbmFtZSA9IGZyYWdtZW50UkUudGVzdChodG1sKSAmJiBSZWdFeHAuJDFcclxuICAgICAgaWYgKCEobmFtZSBpbiBjb250YWluZXJzKSkgbmFtZSA9ICcqJ1xyXG5cclxuICAgICAgY29udGFpbmVyID0gY29udGFpbmVyc1tuYW1lXVxyXG4gICAgICBjb250YWluZXIuaW5uZXJIVE1MID0gJycgKyBodG1sXHJcbiAgICAgIGRvbSA9ICQuZWFjaChzbGljZS5jYWxsKGNvbnRhaW5lci5jaGlsZE5vZGVzKSwgZnVuY3Rpb24oKXtcclxuICAgICAgICBjb250YWluZXIucmVtb3ZlQ2hpbGQodGhpcylcclxuICAgICAgfSlcclxuICAgIH1cclxuXHJcbiAgICBpZiAoaXNQbGFpbk9iamVjdChwcm9wZXJ0aWVzKSkge1xyXG4gICAgICBub2RlcyA9ICQoZG9tKVxyXG4gICAgICAkLmVhY2gocHJvcGVydGllcywgZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xyXG4gICAgICAgIGlmIChtZXRob2RBdHRyaWJ1dGVzLmluZGV4T2Yoa2V5KSA+IC0xKSBub2Rlc1trZXldKHZhbHVlKVxyXG4gICAgICAgIGVsc2Ugbm9kZXMuYXR0cihrZXksIHZhbHVlKVxyXG4gICAgICB9KVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBkb21cclxuICB9XHJcblxyXG4gIC8vIGAkLnplcHRvLlpgIHN3YXBzIG91dCB0aGUgcHJvdG90eXBlIG9mIHRoZSBnaXZlbiBgZG9tYCBhcnJheVxyXG4gIC8vIG9mIG5vZGVzIHdpdGggYCQuZm5gIGFuZCB0aHVzIHN1cHBseWluZyBhbGwgdGhlIFplcHRvIGZ1bmN0aW9uc1xyXG4gIC8vIHRvIHRoZSBhcnJheS4gTm90ZSB0aGF0IGBfX3Byb3RvX19gIGlzIG5vdCBzdXBwb3J0ZWQgb24gSW50ZXJuZXRcclxuICAvLyBFeHBsb3Jlci4gVGhpcyBtZXRob2QgY2FuIGJlIG92ZXJyaWRlbiBpbiBwbHVnaW5zLlxyXG4gIHplcHRvLlogPSBmdW5jdGlvbihkb20sIHNlbGVjdG9yKSB7XHJcbiAgICBkb20gPSBkb20gfHwgW11cclxuICAgIGRvbS5fX3Byb3RvX18gPSAkLmZuXHJcbiAgICBkb20uc2VsZWN0b3IgPSBzZWxlY3RvciB8fCAnJ1xyXG4gICAgcmV0dXJuIGRvbVxyXG4gIH1cclxuXHJcbiAgLy8gYCQuemVwdG8uaXNaYCBzaG91bGQgcmV0dXJuIGB0cnVlYCBpZiB0aGUgZ2l2ZW4gb2JqZWN0IGlzIGEgWmVwdG9cclxuICAvLyBjb2xsZWN0aW9uLiBUaGlzIG1ldGhvZCBjYW4gYmUgb3ZlcnJpZGVuIGluIHBsdWdpbnMuXHJcbiAgemVwdG8uaXNaID0gZnVuY3Rpb24ob2JqZWN0KSB7XHJcbiAgICByZXR1cm4gb2JqZWN0IGluc3RhbmNlb2YgemVwdG8uWlxyXG4gIH1cclxuXHJcbiAgLy8gYCQuemVwdG8uaW5pdGAgaXMgWmVwdG8ncyBjb3VudGVycGFydCB0byBqUXVlcnkncyBgJC5mbi5pbml0YCBhbmRcclxuICAvLyB0YWtlcyBhIENTUyBzZWxlY3RvciBhbmQgYW4gb3B0aW9uYWwgY29udGV4dCAoYW5kIGhhbmRsZXMgdmFyaW91c1xyXG4gIC8vIHNwZWNpYWwgY2FzZXMpLlxyXG4gIC8vIFRoaXMgbWV0aG9kIGNhbiBiZSBvdmVycmlkZW4gaW4gcGx1Z2lucy5cclxuICB6ZXB0by5pbml0ID0gZnVuY3Rpb24oc2VsZWN0b3IsIGNvbnRleHQpIHtcclxuICAgIHZhciBkb21cclxuICAgIC8vIElmIG5vdGhpbmcgZ2l2ZW4sIHJldHVybiBhbiBlbXB0eSBaZXB0byBjb2xsZWN0aW9uXHJcbiAgICBpZiAoIXNlbGVjdG9yKSByZXR1cm4gemVwdG8uWigpXHJcbiAgICAvLyBPcHRpbWl6ZSBmb3Igc3RyaW5nIHNlbGVjdG9yc1xyXG4gICAgZWxzZSBpZiAodHlwZW9mIHNlbGVjdG9yID09ICdzdHJpbmcnKSB7XHJcbiAgICAgIHNlbGVjdG9yID0gc2VsZWN0b3IudHJpbSgpXHJcbiAgICAgIC8vIElmIGl0J3MgYSBodG1sIGZyYWdtZW50LCBjcmVhdGUgbm9kZXMgZnJvbSBpdFxyXG4gICAgICAvLyBOb3RlOiBJbiBib3RoIENocm9tZSAyMSBhbmQgRmlyZWZveCAxNSwgRE9NIGVycm9yIDEyXHJcbiAgICAgIC8vIGlzIHRocm93biBpZiB0aGUgZnJhZ21lbnQgZG9lc24ndCBiZWdpbiB3aXRoIDxcclxuICAgICAgaWYgKHNlbGVjdG9yWzBdID09ICc8JyAmJiBmcmFnbWVudFJFLnRlc3Qoc2VsZWN0b3IpKVxyXG4gICAgICAgIGRvbSA9IHplcHRvLmZyYWdtZW50KHNlbGVjdG9yLCBSZWdFeHAuJDEsIGNvbnRleHQpLCBzZWxlY3RvciA9IG51bGxcclxuICAgICAgLy8gSWYgdGhlcmUncyBhIGNvbnRleHQsIGNyZWF0ZSBhIGNvbGxlY3Rpb24gb24gdGhhdCBjb250ZXh0IGZpcnN0LCBhbmQgc2VsZWN0XHJcbiAgICAgIC8vIG5vZGVzIGZyb20gdGhlcmVcclxuICAgICAgZWxzZSBpZiAoY29udGV4dCAhPT0gdW5kZWZpbmVkKSByZXR1cm4gJChjb250ZXh0KS5maW5kKHNlbGVjdG9yKVxyXG4gICAgICAvLyBJZiBpdCdzIGEgQ1NTIHNlbGVjdG9yLCB1c2UgaXQgdG8gc2VsZWN0IG5vZGVzLlxyXG4gICAgICBlbHNlIGRvbSA9IHplcHRvLnFzYShkb2N1bWVudCwgc2VsZWN0b3IpXHJcbiAgICB9XHJcbiAgICAvLyBJZiBhIGZ1bmN0aW9uIGlzIGdpdmVuLCBjYWxsIGl0IHdoZW4gdGhlIERPTSBpcyByZWFkeVxyXG4gICAgZWxzZSBpZiAoaXNGdW5jdGlvbihzZWxlY3RvcikpIHJldHVybiAkKGRvY3VtZW50KS5yZWFkeShzZWxlY3RvcilcclxuICAgIC8vIElmIGEgWmVwdG8gY29sbGVjdGlvbiBpcyBnaXZlbiwganVzdCByZXR1cm4gaXRcclxuICAgIGVsc2UgaWYgKHplcHRvLmlzWihzZWxlY3RvcikpIHJldHVybiBzZWxlY3RvclxyXG4gICAgZWxzZSB7XHJcbiAgICAgIC8vIG5vcm1hbGl6ZSBhcnJheSBpZiBhbiBhcnJheSBvZiBub2RlcyBpcyBnaXZlblxyXG4gICAgICBpZiAoaXNBcnJheShzZWxlY3RvcikpIGRvbSA9IGNvbXBhY3Qoc2VsZWN0b3IpXHJcbiAgICAgIC8vIFdyYXAgRE9NIG5vZGVzLlxyXG4gICAgICBlbHNlIGlmIChpc09iamVjdChzZWxlY3RvcikpXHJcbiAgICAgICAgZG9tID0gW3NlbGVjdG9yXSwgc2VsZWN0b3IgPSBudWxsXHJcbiAgICAgIC8vIElmIGl0J3MgYSBodG1sIGZyYWdtZW50LCBjcmVhdGUgbm9kZXMgZnJvbSBpdFxyXG4gICAgICBlbHNlIGlmIChmcmFnbWVudFJFLnRlc3Qoc2VsZWN0b3IpKVxyXG4gICAgICAgIGRvbSA9IHplcHRvLmZyYWdtZW50KHNlbGVjdG9yLnRyaW0oKSwgUmVnRXhwLiQxLCBjb250ZXh0KSwgc2VsZWN0b3IgPSBudWxsXHJcbiAgICAgIC8vIElmIHRoZXJlJ3MgYSBjb250ZXh0LCBjcmVhdGUgYSBjb2xsZWN0aW9uIG9uIHRoYXQgY29udGV4dCBmaXJzdCwgYW5kIHNlbGVjdFxyXG4gICAgICAvLyBub2RlcyBmcm9tIHRoZXJlXHJcbiAgICAgIGVsc2UgaWYgKGNvbnRleHQgIT09IHVuZGVmaW5lZCkgcmV0dXJuICQoY29udGV4dCkuZmluZChzZWxlY3RvcilcclxuICAgICAgLy8gQW5kIGxhc3QgYnV0IG5vIGxlYXN0LCBpZiBpdCdzIGEgQ1NTIHNlbGVjdG9yLCB1c2UgaXQgdG8gc2VsZWN0IG5vZGVzLlxyXG4gICAgICBlbHNlIGRvbSA9IHplcHRvLnFzYShkb2N1bWVudCwgc2VsZWN0b3IpXHJcbiAgICB9XHJcbiAgICAvLyBjcmVhdGUgYSBuZXcgWmVwdG8gY29sbGVjdGlvbiBmcm9tIHRoZSBub2RlcyBmb3VuZFxyXG4gICAgcmV0dXJuIHplcHRvLlooZG9tLCBzZWxlY3RvcilcclxuICB9XHJcblxyXG4gIC8vIGAkYCB3aWxsIGJlIHRoZSBiYXNlIGBaZXB0b2Agb2JqZWN0LiBXaGVuIGNhbGxpbmcgdGhpc1xyXG4gIC8vIGZ1bmN0aW9uIGp1c3QgY2FsbCBgJC56ZXB0by5pbml0LCB3aGljaCBtYWtlcyB0aGUgaW1wbGVtZW50YXRpb25cclxuICAvLyBkZXRhaWxzIG9mIHNlbGVjdGluZyBub2RlcyBhbmQgY3JlYXRpbmcgWmVwdG8gY29sbGVjdGlvbnNcclxuICAvLyBwYXRjaGFibGUgaW4gcGx1Z2lucy5cclxuICAkID0gZnVuY3Rpb24oc2VsZWN0b3IsIGNvbnRleHQpe1xyXG4gICAgcmV0dXJuIHplcHRvLmluaXQoc2VsZWN0b3IsIGNvbnRleHQpXHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBleHRlbmQodGFyZ2V0LCBzb3VyY2UsIGRlZXApIHtcclxuICAgIGZvciAoa2V5IGluIHNvdXJjZSlcclxuICAgICAgaWYgKGRlZXAgJiYgKGlzUGxhaW5PYmplY3Qoc291cmNlW2tleV0pIHx8IGlzQXJyYXkoc291cmNlW2tleV0pKSkge1xyXG4gICAgICAgIGlmIChpc1BsYWluT2JqZWN0KHNvdXJjZVtrZXldKSAmJiAhaXNQbGFpbk9iamVjdCh0YXJnZXRba2V5XSkpXHJcbiAgICAgICAgICB0YXJnZXRba2V5XSA9IHt9XHJcbiAgICAgICAgaWYgKGlzQXJyYXkoc291cmNlW2tleV0pICYmICFpc0FycmF5KHRhcmdldFtrZXldKSlcclxuICAgICAgICAgIHRhcmdldFtrZXldID0gW11cclxuICAgICAgICBleHRlbmQodGFyZ2V0W2tleV0sIHNvdXJjZVtrZXldLCBkZWVwKVxyXG4gICAgICB9XHJcbiAgICAgIGVsc2UgaWYgKHNvdXJjZVtrZXldICE9PSB1bmRlZmluZWQpIHRhcmdldFtrZXldID0gc291cmNlW2tleV1cclxuICB9XHJcblxyXG4gIC8vIENvcHkgYWxsIGJ1dCB1bmRlZmluZWQgcHJvcGVydGllcyBmcm9tIG9uZSBvciBtb3JlXHJcbiAgLy8gb2JqZWN0cyB0byB0aGUgYHRhcmdldGAgb2JqZWN0LlxyXG4gICQuZXh0ZW5kID0gZnVuY3Rpb24odGFyZ2V0KXtcclxuICAgIHZhciBkZWVwLCBhcmdzID0gc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpXHJcbiAgICBpZiAodHlwZW9mIHRhcmdldCA9PSAnYm9vbGVhbicpIHtcclxuICAgICAgZGVlcCA9IHRhcmdldFxyXG4gICAgICB0YXJnZXQgPSBhcmdzLnNoaWZ0KClcclxuICAgIH1cclxuICAgIGFyZ3MuZm9yRWFjaChmdW5jdGlvbihhcmcpeyBleHRlbmQodGFyZ2V0LCBhcmcsIGRlZXApIH0pXHJcbiAgICByZXR1cm4gdGFyZ2V0XHJcbiAgfVxyXG5cclxuICAvLyBgJC56ZXB0by5xc2FgIGlzIFplcHRvJ3MgQ1NTIHNlbGVjdG9yIGltcGxlbWVudGF0aW9uIHdoaWNoXHJcbiAgLy8gdXNlcyBgZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbGAgYW5kIG9wdGltaXplcyBmb3Igc29tZSBzcGVjaWFsIGNhc2VzLCBsaWtlIGAjaWRgLlxyXG4gIC8vIFRoaXMgbWV0aG9kIGNhbiBiZSBvdmVycmlkZW4gaW4gcGx1Z2lucy5cclxuICB6ZXB0by5xc2EgPSBmdW5jdGlvbihlbGVtZW50LCBzZWxlY3Rvcil7XHJcbiAgICB2YXIgZm91bmQsXHJcbiAgICAgICAgbWF5YmVJRCA9IHNlbGVjdG9yWzBdID09ICcjJyxcclxuICAgICAgICBtYXliZUNsYXNzID0gIW1heWJlSUQgJiYgc2VsZWN0b3JbMF0gPT0gJy4nLFxyXG4gICAgICAgIG5hbWVPbmx5ID0gbWF5YmVJRCB8fCBtYXliZUNsYXNzID8gc2VsZWN0b3Iuc2xpY2UoMSkgOiBzZWxlY3RvciwgLy8gRW5zdXJlIHRoYXQgYSAxIGNoYXIgdGFnIG5hbWUgc3RpbGwgZ2V0cyBjaGVja2VkXHJcbiAgICAgICAgaXNTaW1wbGUgPSBzaW1wbGVTZWxlY3RvclJFLnRlc3QobmFtZU9ubHkpXHJcbiAgICByZXR1cm4gKGlzRG9jdW1lbnQoZWxlbWVudCkgJiYgaXNTaW1wbGUgJiYgbWF5YmVJRCkgP1xyXG4gICAgICAoIChmb3VuZCA9IGVsZW1lbnQuZ2V0RWxlbWVudEJ5SWQobmFtZU9ubHkpKSA/IFtmb3VuZF0gOiBbXSApIDpcclxuICAgICAgKGVsZW1lbnQubm9kZVR5cGUgIT09IDEgJiYgZWxlbWVudC5ub2RlVHlwZSAhPT0gOSkgPyBbXSA6XHJcbiAgICAgIHNsaWNlLmNhbGwoXHJcbiAgICAgICAgaXNTaW1wbGUgJiYgIW1heWJlSUQgP1xyXG4gICAgICAgICAgbWF5YmVDbGFzcyA/IGVsZW1lbnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZShuYW1lT25seSkgOiAvLyBJZiBpdCdzIHNpbXBsZSwgaXQgY291bGQgYmUgYSBjbGFzc1xyXG4gICAgICAgICAgZWxlbWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZShzZWxlY3RvcikgOiAvLyBPciBhIHRhZ1xyXG4gICAgICAgICAgZWxlbWVudC5xdWVyeVNlbGVjdG9yQWxsKHNlbGVjdG9yKSAvLyBPciBpdCdzIG5vdCBzaW1wbGUsIGFuZCB3ZSBuZWVkIHRvIHF1ZXJ5IGFsbFxyXG4gICAgICApXHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBmaWx0ZXJlZChub2Rlcywgc2VsZWN0b3IpIHtcclxuICAgIHJldHVybiBzZWxlY3RvciA9PSBudWxsID8gJChub2RlcykgOiAkKG5vZGVzKS5maWx0ZXIoc2VsZWN0b3IpXHJcbiAgfVxyXG5cclxuICAkLmNvbnRhaW5zID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNvbnRhaW5zID9cclxuICAgIGZ1bmN0aW9uKHBhcmVudCwgbm9kZSkge1xyXG4gICAgICByZXR1cm4gcGFyZW50ICE9PSBub2RlICYmIHBhcmVudC5jb250YWlucyhub2RlKVxyXG4gICAgfSA6XHJcbiAgICBmdW5jdGlvbihwYXJlbnQsIG5vZGUpIHtcclxuICAgICAgd2hpbGUgKG5vZGUgJiYgKG5vZGUgPSBub2RlLnBhcmVudE5vZGUpKVxyXG4gICAgICAgIGlmIChub2RlID09PSBwYXJlbnQpIHJldHVybiB0cnVlXHJcbiAgICAgIHJldHVybiBmYWxzZVxyXG4gICAgfVxyXG5cclxuICBmdW5jdGlvbiBmdW5jQXJnKGNvbnRleHQsIGFyZywgaWR4LCBwYXlsb2FkKSB7XHJcbiAgICByZXR1cm4gaXNGdW5jdGlvbihhcmcpID8gYXJnLmNhbGwoY29udGV4dCwgaWR4LCBwYXlsb2FkKSA6IGFyZ1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gc2V0QXR0cmlidXRlKG5vZGUsIG5hbWUsIHZhbHVlKSB7XHJcbiAgICB2YWx1ZSA9PSBudWxsID8gbm9kZS5yZW1vdmVBdHRyaWJ1dGUobmFtZSkgOiBub2RlLnNldEF0dHJpYnV0ZShuYW1lLCB2YWx1ZSlcclxuICB9XHJcblxyXG4gIC8vIGFjY2VzcyBjbGFzc05hbWUgcHJvcGVydHkgd2hpbGUgcmVzcGVjdGluZyBTVkdBbmltYXRlZFN0cmluZ1xyXG4gIGZ1bmN0aW9uIGNsYXNzTmFtZShub2RlLCB2YWx1ZSl7XHJcbiAgICB2YXIga2xhc3MgPSBub2RlLmNsYXNzTmFtZSB8fCAnJyxcclxuICAgICAgICBzdmcgICA9IGtsYXNzICYmIGtsYXNzLmJhc2VWYWwgIT09IHVuZGVmaW5lZFxyXG5cclxuICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSByZXR1cm4gc3ZnID8ga2xhc3MuYmFzZVZhbCA6IGtsYXNzXHJcbiAgICBzdmcgPyAoa2xhc3MuYmFzZVZhbCA9IHZhbHVlKSA6IChub2RlLmNsYXNzTmFtZSA9IHZhbHVlKVxyXG4gIH1cclxuXHJcbiAgLy8gXCJ0cnVlXCIgID0+IHRydWVcclxuICAvLyBcImZhbHNlXCIgPT4gZmFsc2VcclxuICAvLyBcIm51bGxcIiAgPT4gbnVsbFxyXG4gIC8vIFwiNDJcIiAgICA9PiA0MlxyXG4gIC8vIFwiNDIuNVwiICA9PiA0Mi41XHJcbiAgLy8gXCIwOFwiICAgID0+IFwiMDhcIlxyXG4gIC8vIEpTT04gICAgPT4gcGFyc2UgaWYgdmFsaWRcclxuICAvLyBTdHJpbmcgID0+IHNlbGZcclxuICBmdW5jdGlvbiBkZXNlcmlhbGl6ZVZhbHVlKHZhbHVlKSB7XHJcbiAgICB2YXIgbnVtXHJcbiAgICB0cnkge1xyXG4gICAgICByZXR1cm4gdmFsdWUgP1xyXG4gICAgICAgIHZhbHVlID09IFwidHJ1ZVwiIHx8XHJcbiAgICAgICAgKCB2YWx1ZSA9PSBcImZhbHNlXCIgPyBmYWxzZSA6XHJcbiAgICAgICAgICB2YWx1ZSA9PSBcIm51bGxcIiA/IG51bGwgOlxyXG4gICAgICAgICAgIS9eMC8udGVzdCh2YWx1ZSkgJiYgIWlzTmFOKG51bSA9IE51bWJlcih2YWx1ZSkpID8gbnVtIDpcclxuICAgICAgICAgIC9eW1xcW1xce10vLnRlc3QodmFsdWUpID8gJC5wYXJzZUpTT04odmFsdWUpIDpcclxuICAgICAgICAgIHZhbHVlIClcclxuICAgICAgICA6IHZhbHVlXHJcbiAgICB9IGNhdGNoKGUpIHtcclxuICAgICAgcmV0dXJuIHZhbHVlXHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAkLnR5cGUgPSB0eXBlXHJcbiAgJC5pc0Z1bmN0aW9uID0gaXNGdW5jdGlvblxyXG4gICQuaXNXaW5kb3cgPSBpc1dpbmRvd1xyXG4gICQuaXNBcnJheSA9IGlzQXJyYXlcclxuICAkLmlzUGxhaW5PYmplY3QgPSBpc1BsYWluT2JqZWN0XHJcbiAgJC5pc09iamVjdCA9IGlzT2JqZWN0ICAgLy/ov5nkuKrljp/mnKzmnKjmnInnmoQg5L+65Yqg55qEISFcclxuXHJcbiAgJC5pc0VtcHR5T2JqZWN0ID0gZnVuY3Rpb24ob2JqKSB7XHJcbiAgICB2YXIgbmFtZVxyXG4gICAgZm9yIChuYW1lIGluIG9iaikgcmV0dXJuIGZhbHNlXHJcbiAgICByZXR1cm4gdHJ1ZVxyXG4gIH1cclxuXHJcbiAgJC5pbkFycmF5ID0gZnVuY3Rpb24oZWxlbSwgYXJyYXksIGkpe1xyXG4gICAgcmV0dXJuIGVtcHR5QXJyYXkuaW5kZXhPZi5jYWxsKGFycmF5LCBlbGVtLCBpKVxyXG4gIH1cclxuXHJcbiAgJC5jYW1lbENhc2UgPSBjYW1lbGl6ZVxyXG4gICQudHJpbSA9IGZ1bmN0aW9uKHN0cikge1xyXG4gICAgcmV0dXJuIHN0ciA9PSBudWxsID8gXCJcIiA6IFN0cmluZy5wcm90b3R5cGUudHJpbS5jYWxsKHN0cilcclxuICB9XHJcblxyXG4gIC8vIHBsdWdpbiBjb21wYXRpYmlsaXR5XHJcbiAgJC51dWlkID0gMFxyXG4gICQuc3VwcG9ydCA9IHsgfVxyXG4gICQuZXhwciA9IHsgfVxyXG5cclxuICAkLm1hcCA9IGZ1bmN0aW9uKGVsZW1lbnRzLCBjYWxsYmFjayl7XHJcbiAgICB2YXIgdmFsdWUsIHZhbHVlcyA9IFtdLCBpLCBrZXlcclxuICAgIGlmIChsaWtlQXJyYXkoZWxlbWVudHMpKVxyXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgZWxlbWVudHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICB2YWx1ZSA9IGNhbGxiYWNrKGVsZW1lbnRzW2ldLCBpKVxyXG4gICAgICAgIGlmICh2YWx1ZSAhPSBudWxsKSB2YWx1ZXMucHVzaCh2YWx1ZSlcclxuICAgICAgfVxyXG4gICAgZWxzZVxyXG4gICAgICBmb3IgKGtleSBpbiBlbGVtZW50cykge1xyXG4gICAgICAgIHZhbHVlID0gY2FsbGJhY2soZWxlbWVudHNba2V5XSwga2V5KVxyXG4gICAgICAgIGlmICh2YWx1ZSAhPSBudWxsKSB2YWx1ZXMucHVzaCh2YWx1ZSlcclxuICAgICAgfVxyXG4gICAgcmV0dXJuIGZsYXR0ZW4odmFsdWVzKVxyXG4gIH1cclxuXHJcbiAgJC5lYWNoID0gZnVuY3Rpb24oZWxlbWVudHMsIGNhbGxiYWNrKXtcclxuICAgIHZhciBpLCBrZXlcclxuICAgIGlmIChsaWtlQXJyYXkoZWxlbWVudHMpKSB7XHJcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBlbGVtZW50cy5sZW5ndGg7IGkrKylcclxuICAgICAgICBpZiAoY2FsbGJhY2suY2FsbChlbGVtZW50c1tpXSwgaSwgZWxlbWVudHNbaV0pID09PSBmYWxzZSkgcmV0dXJuIGVsZW1lbnRzXHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBmb3IgKGtleSBpbiBlbGVtZW50cylcclxuICAgICAgICBpZiAoY2FsbGJhY2suY2FsbChlbGVtZW50c1trZXldLCBrZXksIGVsZW1lbnRzW2tleV0pID09PSBmYWxzZSkgcmV0dXJuIGVsZW1lbnRzXHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGVsZW1lbnRzXHJcbiAgfVxyXG5cclxuICAkLmdyZXAgPSBmdW5jdGlvbihlbGVtZW50cywgY2FsbGJhY2spe1xyXG4gICAgcmV0dXJuIGZpbHRlci5jYWxsKGVsZW1lbnRzLCBjYWxsYmFjaylcclxuICB9XHJcblxyXG4gIGlmICh3aW5kb3cuSlNPTikgJC5wYXJzZUpTT04gPSBKU09OLnBhcnNlXHJcblxyXG4gIC8vIFBvcHVsYXRlIHRoZSBjbGFzczJ0eXBlIG1hcFxyXG4gICQuZWFjaChcIkJvb2xlYW4gTnVtYmVyIFN0cmluZyBGdW5jdGlvbiBBcnJheSBEYXRlIFJlZ0V4cCBPYmplY3QgRXJyb3JcIi5zcGxpdChcIiBcIiksIGZ1bmN0aW9uKGksIG5hbWUpIHtcclxuICAgIGNsYXNzMnR5cGVbIFwiW29iamVjdCBcIiArIG5hbWUgKyBcIl1cIiBdID0gbmFtZS50b0xvd2VyQ2FzZSgpXHJcbiAgfSlcclxuXHJcbiAgLy8gRGVmaW5lIG1ldGhvZHMgdGhhdCB3aWxsIGJlIGF2YWlsYWJsZSBvbiBhbGxcclxuICAvLyBaZXB0byBjb2xsZWN0aW9uc1xyXG4gICQuZm4gPSB7XHJcbiAgICAvLyBCZWNhdXNlIGEgY29sbGVjdGlvbiBhY3RzIGxpa2UgYW4gYXJyYXlcclxuICAgIC8vIGNvcHkgb3ZlciB0aGVzZSB1c2VmdWwgYXJyYXkgZnVuY3Rpb25zLlxyXG4gICAgZm9yRWFjaDogZW1wdHlBcnJheS5mb3JFYWNoLFxyXG4gICAgcmVkdWNlOiBlbXB0eUFycmF5LnJlZHVjZSxcclxuICAgIHB1c2g6IGVtcHR5QXJyYXkucHVzaCxcclxuICAgIHNvcnQ6IGVtcHR5QXJyYXkuc29ydCxcclxuICAgIGluZGV4T2Y6IGVtcHR5QXJyYXkuaW5kZXhPZixcclxuICAgIGNvbmNhdDogZW1wdHlBcnJheS5jb25jYXQsXHJcblxyXG4gICAgLy8gYG1hcGAgYW5kIGBzbGljZWAgaW4gdGhlIGpRdWVyeSBBUEkgd29yayBkaWZmZXJlbnRseVxyXG4gICAgLy8gZnJvbSB0aGVpciBhcnJheSBjb3VudGVycGFydHNcclxuICAgIG1hcDogZnVuY3Rpb24oZm4pe1xyXG4gICAgICByZXR1cm4gJCgkLm1hcCh0aGlzLCBmdW5jdGlvbihlbCwgaSl7IHJldHVybiBmbi5jYWxsKGVsLCBpLCBlbCkgfSkpXHJcbiAgICB9LFxyXG4gICAgc2xpY2U6IGZ1bmN0aW9uKCl7XHJcbiAgICAgIHJldHVybiAkKHNsaWNlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpXHJcbiAgICB9LFxyXG5cclxuICAgIHJlYWR5OiBmdW5jdGlvbihjYWxsYmFjayl7XHJcbiAgICAgIC8vIG5lZWQgdG8gY2hlY2sgaWYgZG9jdW1lbnQuYm9keSBleGlzdHMgZm9yIElFIGFzIHRoYXQgYnJvd3NlciByZXBvcnRzXHJcbiAgICAgIC8vIGRvY3VtZW50IHJlYWR5IHdoZW4gaXQgaGFzbid0IHlldCBjcmVhdGVkIHRoZSBib2R5IGVsZW1lbnRcclxuICAgICAgaWYgKHJlYWR5UkUudGVzdChkb2N1bWVudC5yZWFkeVN0YXRlKSAmJiBkb2N1bWVudC5ib2R5KSBjYWxsYmFjaygkKVxyXG4gICAgICBlbHNlIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ0RPTUNvbnRlbnRMb2FkZWQnLCBmdW5jdGlvbigpeyBjYWxsYmFjaygkKSB9LCBmYWxzZSlcclxuICAgICAgcmV0dXJuIHRoaXNcclxuICAgIH0sXHJcbiAgICBnZXQ6IGZ1bmN0aW9uKGlkeCl7XHJcbiAgICAgIHJldHVybiBpZHggPT09IHVuZGVmaW5lZCA/IHNsaWNlLmNhbGwodGhpcykgOiB0aGlzW2lkeCA+PSAwID8gaWR4IDogaWR4ICsgdGhpcy5sZW5ndGhdXHJcbiAgICB9LFxyXG4gICAgdG9BcnJheTogZnVuY3Rpb24oKXsgcmV0dXJuIHRoaXMuZ2V0KCkgfSxcclxuICAgIHNpemU6IGZ1bmN0aW9uKCl7XHJcbiAgICAgIHJldHVybiB0aGlzLmxlbmd0aFxyXG4gICAgfSxcclxuICAgIHJlbW92ZTogZnVuY3Rpb24oKXtcclxuICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpe1xyXG4gICAgICAgIGlmICh0aGlzLnBhcmVudE5vZGUgIT0gbnVsbClcclxuICAgICAgICAgIHRoaXMucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzKVxyXG4gICAgICB9KVxyXG4gICAgfSxcclxuICAgIGVhY2g6IGZ1bmN0aW9uKGNhbGxiYWNrKXtcclxuICAgICAgZW1wdHlBcnJheS5ldmVyeS5jYWxsKHRoaXMsIGZ1bmN0aW9uKGVsLCBpZHgpe1xyXG4gICAgICAgIHJldHVybiBjYWxsYmFjay5jYWxsKGVsLCBpZHgsIGVsKSAhPT0gZmFsc2VcclxuICAgICAgfSlcclxuICAgICAgcmV0dXJuIHRoaXNcclxuICAgIH0sXHJcbiAgICBmaWx0ZXI6IGZ1bmN0aW9uKHNlbGVjdG9yKXtcclxuICAgICAgaWYgKGlzRnVuY3Rpb24oc2VsZWN0b3IpKSByZXR1cm4gdGhpcy5ub3QodGhpcy5ub3Qoc2VsZWN0b3IpKVxyXG4gICAgICByZXR1cm4gJChmaWx0ZXIuY2FsbCh0aGlzLCBmdW5jdGlvbihlbGVtZW50KXtcclxuICAgICAgICByZXR1cm4gemVwdG8ubWF0Y2hlcyhlbGVtZW50LCBzZWxlY3RvcilcclxuICAgICAgfSkpXHJcbiAgICB9LFxyXG4gICAgYWRkOiBmdW5jdGlvbihzZWxlY3Rvcixjb250ZXh0KXtcclxuICAgICAgcmV0dXJuICQodW5pcSh0aGlzLmNvbmNhdCgkKHNlbGVjdG9yLGNvbnRleHQpKSkpXHJcbiAgICB9LFxyXG4gICAgaXM6IGZ1bmN0aW9uKHNlbGVjdG9yKXtcclxuICAgICAgcmV0dXJuIHRoaXMubGVuZ3RoID4gMCAmJiB6ZXB0by5tYXRjaGVzKHRoaXNbMF0sIHNlbGVjdG9yKVxyXG4gICAgfSxcclxuICAgIG5vdDogZnVuY3Rpb24oc2VsZWN0b3Ipe1xyXG4gICAgICB2YXIgbm9kZXM9W11cclxuICAgICAgaWYgKGlzRnVuY3Rpb24oc2VsZWN0b3IpICYmIHNlbGVjdG9yLmNhbGwgIT09IHVuZGVmaW5lZClcclxuICAgICAgICB0aGlzLmVhY2goZnVuY3Rpb24oaWR4KXtcclxuICAgICAgICAgIGlmICghc2VsZWN0b3IuY2FsbCh0aGlzLGlkeCkpIG5vZGVzLnB1c2godGhpcylcclxuICAgICAgICB9KVxyXG4gICAgICBlbHNlIHtcclxuICAgICAgICB2YXIgZXhjbHVkZXMgPSB0eXBlb2Ygc2VsZWN0b3IgPT0gJ3N0cmluZycgPyB0aGlzLmZpbHRlcihzZWxlY3RvcikgOlxyXG4gICAgICAgICAgKGxpa2VBcnJheShzZWxlY3RvcikgJiYgaXNGdW5jdGlvbihzZWxlY3Rvci5pdGVtKSkgPyBzbGljZS5jYWxsKHNlbGVjdG9yKSA6ICQoc2VsZWN0b3IpXHJcbiAgICAgICAgdGhpcy5mb3JFYWNoKGZ1bmN0aW9uKGVsKXtcclxuICAgICAgICAgIGlmIChleGNsdWRlcy5pbmRleE9mKGVsKSA8IDApIG5vZGVzLnB1c2goZWwpXHJcbiAgICAgICAgfSlcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gJChub2RlcylcclxuICAgIH0sXHJcbiAgICBoYXM6IGZ1bmN0aW9uKHNlbGVjdG9yKXtcclxuICAgICAgcmV0dXJuIHRoaXMuZmlsdGVyKGZ1bmN0aW9uKCl7XHJcbiAgICAgICAgcmV0dXJuIGlzT2JqZWN0KHNlbGVjdG9yKSA/XHJcbiAgICAgICAgICAkLmNvbnRhaW5zKHRoaXMsIHNlbGVjdG9yKSA6XHJcbiAgICAgICAgICAkKHRoaXMpLmZpbmQoc2VsZWN0b3IpLnNpemUoKVxyXG4gICAgICB9KVxyXG4gICAgfSxcclxuICAgIGVxOiBmdW5jdGlvbihpZHgpe1xyXG4gICAgICByZXR1cm4gaWR4ID09PSAtMSA/IHRoaXMuc2xpY2UoaWR4KSA6IHRoaXMuc2xpY2UoaWR4LCArIGlkeCArIDEpXHJcbiAgICB9LFxyXG4gICAgZmlyc3Q6IGZ1bmN0aW9uKCl7XHJcbiAgICAgIHZhciBlbCA9IHRoaXNbMF1cclxuICAgICAgcmV0dXJuIGVsICYmICFpc09iamVjdChlbCkgPyBlbCA6ICQoZWwpXHJcbiAgICB9LFxyXG4gICAgbGFzdDogZnVuY3Rpb24oKXtcclxuICAgICAgdmFyIGVsID0gdGhpc1t0aGlzLmxlbmd0aCAtIDFdXHJcbiAgICAgIHJldHVybiBlbCAmJiAhaXNPYmplY3QoZWwpID8gZWwgOiAkKGVsKVxyXG4gICAgfSxcclxuICAgIGZpbmQ6IGZ1bmN0aW9uKHNlbGVjdG9yKXtcclxuICAgICAgdmFyIHJlc3VsdCwgJHRoaXMgPSB0aGlzXHJcbiAgICAgIGlmICghc2VsZWN0b3IpIHJlc3VsdCA9IFtdXHJcbiAgICAgIGVsc2UgaWYgKHR5cGVvZiBzZWxlY3RvciA9PSAnb2JqZWN0JylcclxuICAgICAgICByZXN1bHQgPSAkKHNlbGVjdG9yKS5maWx0ZXIoZnVuY3Rpb24oKXtcclxuICAgICAgICAgIHZhciBub2RlID0gdGhpc1xyXG4gICAgICAgICAgcmV0dXJuIGVtcHR5QXJyYXkuc29tZS5jYWxsKCR0aGlzLCBmdW5jdGlvbihwYXJlbnQpe1xyXG4gICAgICAgICAgICByZXR1cm4gJC5jb250YWlucyhwYXJlbnQsIG5vZGUpXHJcbiAgICAgICAgICB9KVxyXG4gICAgICAgIH0pXHJcbiAgICAgIGVsc2UgaWYgKHRoaXMubGVuZ3RoID09IDEpIHJlc3VsdCA9ICQoemVwdG8ucXNhKHRoaXNbMF0sIHNlbGVjdG9yKSlcclxuICAgICAgZWxzZSByZXN1bHQgPSB0aGlzLm1hcChmdW5jdGlvbigpeyByZXR1cm4gemVwdG8ucXNhKHRoaXMsIHNlbGVjdG9yKSB9KVxyXG4gICAgICByZXR1cm4gcmVzdWx0XHJcbiAgICB9LFxyXG4gICAgY2xvc2VzdDogZnVuY3Rpb24oc2VsZWN0b3IsIGNvbnRleHQpe1xyXG4gICAgICB2YXIgbm9kZSA9IHRoaXNbMF0sIGNvbGxlY3Rpb24gPSBmYWxzZVxyXG4gICAgICBpZiAodHlwZW9mIHNlbGVjdG9yID09ICdvYmplY3QnKSBjb2xsZWN0aW9uID0gJChzZWxlY3RvcilcclxuICAgICAgd2hpbGUgKG5vZGUgJiYgIShjb2xsZWN0aW9uID8gY29sbGVjdGlvbi5pbmRleE9mKG5vZGUpID49IDAgOiB6ZXB0by5tYXRjaGVzKG5vZGUsIHNlbGVjdG9yKSkpXHJcbiAgICAgICAgbm9kZSA9IG5vZGUgIT09IGNvbnRleHQgJiYgIWlzRG9jdW1lbnQobm9kZSkgJiYgbm9kZS5wYXJlbnROb2RlXHJcbiAgICAgIHJldHVybiAkKG5vZGUpXHJcbiAgICB9LFxyXG4gICAgcGFyZW50czogZnVuY3Rpb24oc2VsZWN0b3Ipe1xyXG4gICAgICB2YXIgYW5jZXN0b3JzID0gW10sIG5vZGVzID0gdGhpc1xyXG4gICAgICB3aGlsZSAobm9kZXMubGVuZ3RoID4gMClcclxuICAgICAgICBub2RlcyA9ICQubWFwKG5vZGVzLCBmdW5jdGlvbihub2RlKXtcclxuICAgICAgICAgIGlmICgobm9kZSA9IG5vZGUucGFyZW50Tm9kZSkgJiYgIWlzRG9jdW1lbnQobm9kZSkgJiYgYW5jZXN0b3JzLmluZGV4T2Yobm9kZSkgPCAwKSB7XHJcbiAgICAgICAgICAgIGFuY2VzdG9ycy5wdXNoKG5vZGUpXHJcbiAgICAgICAgICAgIHJldHVybiBub2RlXHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSlcclxuICAgICAgcmV0dXJuIGZpbHRlcmVkKGFuY2VzdG9ycywgc2VsZWN0b3IpXHJcbiAgICB9LFxyXG4gICAgcGFyZW50OiBmdW5jdGlvbihzZWxlY3Rvcil7XHJcbiAgICAgIHJldHVybiBmaWx0ZXJlZCh1bmlxKHRoaXMucGx1Y2soJ3BhcmVudE5vZGUnKSksIHNlbGVjdG9yKVxyXG4gICAgfSxcclxuICAgIGNoaWxkcmVuOiBmdW5jdGlvbihzZWxlY3Rvcil7XHJcbiAgICAgIHJldHVybiBmaWx0ZXJlZCh0aGlzLm1hcChmdW5jdGlvbigpeyByZXR1cm4gY2hpbGRyZW4odGhpcykgfSksIHNlbGVjdG9yKVxyXG4gICAgfSxcclxuICAgIGNvbnRlbnRzOiBmdW5jdGlvbigpIHtcclxuICAgICAgcmV0dXJuIHRoaXMubWFwKGZ1bmN0aW9uKCkgeyByZXR1cm4gc2xpY2UuY2FsbCh0aGlzLmNoaWxkTm9kZXMpIH0pXHJcbiAgICB9LFxyXG4gICAgc2libGluZ3M6IGZ1bmN0aW9uKHNlbGVjdG9yKXtcclxuICAgICAgcmV0dXJuIGZpbHRlcmVkKHRoaXMubWFwKGZ1bmN0aW9uKGksIGVsKXtcclxuICAgICAgICByZXR1cm4gZmlsdGVyLmNhbGwoY2hpbGRyZW4oZWwucGFyZW50Tm9kZSksIGZ1bmN0aW9uKGNoaWxkKXsgcmV0dXJuIGNoaWxkIT09ZWwgfSlcclxuICAgICAgfSksIHNlbGVjdG9yKVxyXG4gICAgfSxcclxuICAgIGVtcHR5OiBmdW5jdGlvbigpe1xyXG4gICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCl7IHRoaXMuaW5uZXJIVE1MID0gJycgfSlcclxuICAgIH0sXHJcbiAgICAvLyBgcGx1Y2tgIGlzIGJvcnJvd2VkIGZyb20gUHJvdG90eXBlLmpzXHJcbiAgICBwbHVjazogZnVuY3Rpb24ocHJvcGVydHkpe1xyXG4gICAgICByZXR1cm4gJC5tYXAodGhpcywgZnVuY3Rpb24oZWwpeyByZXR1cm4gZWxbcHJvcGVydHldIH0pXHJcbiAgICB9LFxyXG4gICAgc2hvdzogZnVuY3Rpb24oKXtcclxuICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpe1xyXG4gICAgICAgIHRoaXMuc3R5bGUuZGlzcGxheSA9PSBcIm5vbmVcIiAmJiAodGhpcy5zdHlsZS5kaXNwbGF5ID0gJycpXHJcbiAgICAgICAgaWYgKGdldENvbXB1dGVkU3R5bGUodGhpcywgJycpLmdldFByb3BlcnR5VmFsdWUoXCJkaXNwbGF5XCIpID09IFwibm9uZVwiKVxyXG4gICAgICAgICAgdGhpcy5zdHlsZS5kaXNwbGF5ID0gZGVmYXVsdERpc3BsYXkodGhpcy5ub2RlTmFtZSlcclxuICAgICAgfSlcclxuICAgIH0sXHJcbiAgICByZXBsYWNlV2l0aDogZnVuY3Rpb24obmV3Q29udGVudCl7XHJcbiAgICAgIHJldHVybiB0aGlzLmJlZm9yZShuZXdDb250ZW50KS5yZW1vdmUoKVxyXG4gICAgfSxcclxuICAgIHdyYXA6IGZ1bmN0aW9uKHN0cnVjdHVyZSl7XHJcbiAgICAgIHZhciBmdW5jID0gaXNGdW5jdGlvbihzdHJ1Y3R1cmUpXHJcbiAgICAgIGlmICh0aGlzWzBdICYmICFmdW5jKVxyXG4gICAgICAgIHZhciBkb20gICA9ICQoc3RydWN0dXJlKS5nZXQoMCksXHJcbiAgICAgICAgICAgIGNsb25lID0gZG9tLnBhcmVudE5vZGUgfHwgdGhpcy5sZW5ndGggPiAxXHJcblxyXG4gICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKGluZGV4KXtcclxuICAgICAgICAkKHRoaXMpLndyYXBBbGwoXHJcbiAgICAgICAgICBmdW5jID8gc3RydWN0dXJlLmNhbGwodGhpcywgaW5kZXgpIDpcclxuICAgICAgICAgICAgY2xvbmUgPyBkb20uY2xvbmVOb2RlKHRydWUpIDogZG9tXHJcbiAgICAgICAgKVxyXG4gICAgICB9KVxyXG4gICAgfSxcclxuICAgIHdyYXBBbGw6IGZ1bmN0aW9uKHN0cnVjdHVyZSl7XHJcbiAgICAgIGlmICh0aGlzWzBdKSB7XHJcbiAgICAgICAgJCh0aGlzWzBdKS5iZWZvcmUoc3RydWN0dXJlID0gJChzdHJ1Y3R1cmUpKVxyXG4gICAgICAgIHZhciBjaGlsZHJlblxyXG4gICAgICAgIC8vIGRyaWxsIGRvd24gdG8gdGhlIGlubW9zdCBlbGVtZW50XHJcbiAgICAgICAgd2hpbGUgKChjaGlsZHJlbiA9IHN0cnVjdHVyZS5jaGlsZHJlbigpKS5sZW5ndGgpIHN0cnVjdHVyZSA9IGNoaWxkcmVuLmZpcnN0KClcclxuICAgICAgICAkKHN0cnVjdHVyZSkuYXBwZW5kKHRoaXMpXHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIHRoaXNcclxuICAgIH0sXHJcbiAgICB3cmFwSW5uZXI6IGZ1bmN0aW9uKHN0cnVjdHVyZSl7XHJcbiAgICAgIHZhciBmdW5jID0gaXNGdW5jdGlvbihzdHJ1Y3R1cmUpXHJcbiAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oaW5kZXgpe1xyXG4gICAgICAgIHZhciBzZWxmID0gJCh0aGlzKSwgY29udGVudHMgPSBzZWxmLmNvbnRlbnRzKCksXHJcbiAgICAgICAgICAgIGRvbSAgPSBmdW5jID8gc3RydWN0dXJlLmNhbGwodGhpcywgaW5kZXgpIDogc3RydWN0dXJlXHJcbiAgICAgICAgY29udGVudHMubGVuZ3RoID8gY29udGVudHMud3JhcEFsbChkb20pIDogc2VsZi5hcHBlbmQoZG9tKVxyXG4gICAgICB9KVxyXG4gICAgfSxcclxuICAgIHVud3JhcDogZnVuY3Rpb24oKXtcclxuICAgICAgdGhpcy5wYXJlbnQoKS5lYWNoKGZ1bmN0aW9uKCl7XHJcbiAgICAgICAgJCh0aGlzKS5yZXBsYWNlV2l0aCgkKHRoaXMpLmNoaWxkcmVuKCkpXHJcbiAgICAgIH0pXHJcbiAgICAgIHJldHVybiB0aGlzXHJcbiAgICB9LFxyXG4gICAgY2xvbmU6IGZ1bmN0aW9uKCl7XHJcbiAgICAgIHJldHVybiB0aGlzLm1hcChmdW5jdGlvbigpeyByZXR1cm4gdGhpcy5jbG9uZU5vZGUodHJ1ZSkgfSlcclxuICAgIH0sXHJcbiAgICBoaWRlOiBmdW5jdGlvbigpe1xyXG4gICAgICByZXR1cm4gdGhpcy5jc3MoXCJkaXNwbGF5XCIsIFwibm9uZVwiKVxyXG4gICAgfSxcclxuICAgIHRvZ2dsZTogZnVuY3Rpb24oc2V0dGluZyl7XHJcbiAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKXtcclxuICAgICAgICB2YXIgZWwgPSAkKHRoaXMpXHJcbiAgICAgICAgOyhzZXR0aW5nID09PSB1bmRlZmluZWQgPyBlbC5jc3MoXCJkaXNwbGF5XCIpID09IFwibm9uZVwiIDogc2V0dGluZykgPyBlbC5zaG93KCkgOiBlbC5oaWRlKClcclxuICAgICAgfSlcclxuICAgIH0sXHJcbiAgICBwcmV2OiBmdW5jdGlvbihzZWxlY3Rvcil7IHJldHVybiAkKHRoaXMucGx1Y2soJ3ByZXZpb3VzRWxlbWVudFNpYmxpbmcnKSkuZmlsdGVyKHNlbGVjdG9yIHx8ICcqJykgfSxcclxuICAgIG5leHQ6IGZ1bmN0aW9uKHNlbGVjdG9yKXsgcmV0dXJuICQodGhpcy5wbHVjaygnbmV4dEVsZW1lbnRTaWJsaW5nJykpLmZpbHRlcihzZWxlY3RvciB8fCAnKicpIH0sXHJcbiAgICBodG1sOiBmdW5jdGlvbihodG1sKXtcclxuICAgICAgcmV0dXJuIDAgaW4gYXJndW1lbnRzID9cclxuICAgICAgICB0aGlzLmVhY2goZnVuY3Rpb24oaWR4KXtcclxuICAgICAgICAgIHZhciBvcmlnaW5IdG1sID0gdGhpcy5pbm5lckhUTUxcclxuICAgICAgICAgICQodGhpcykuZW1wdHkoKS5hcHBlbmQoIGZ1bmNBcmcodGhpcywgaHRtbCwgaWR4LCBvcmlnaW5IdG1sKSApXHJcbiAgICAgICAgfSkgOlxyXG4gICAgICAgICgwIGluIHRoaXMgPyB0aGlzWzBdLmlubmVySFRNTCA6IG51bGwpXHJcbiAgICB9LFxyXG4gICAgdGV4dDogZnVuY3Rpb24odGV4dCl7XHJcbiAgICAgIHJldHVybiAwIGluIGFyZ3VtZW50cyA/XHJcbiAgICAgICAgdGhpcy5lYWNoKGZ1bmN0aW9uKGlkeCl7XHJcbiAgICAgICAgICB2YXIgbmV3VGV4dCA9IGZ1bmNBcmcodGhpcywgdGV4dCwgaWR4LCB0aGlzLnRleHRDb250ZW50KVxyXG4gICAgICAgICAgdGhpcy50ZXh0Q29udGVudCA9IG5ld1RleHQgPT0gbnVsbCA/ICcnIDogJycrbmV3VGV4dFxyXG4gICAgICAgIH0pIDpcclxuICAgICAgICAoMCBpbiB0aGlzID8gdGhpc1swXS50ZXh0Q29udGVudCA6IG51bGwpXHJcbiAgICB9LFxyXG4gICAgYXR0cjogZnVuY3Rpb24obmFtZSwgdmFsdWUpe1xyXG4gICAgICB2YXIgcmVzdWx0XHJcbiAgICAgIHJldHVybiAodHlwZW9mIG5hbWUgPT0gJ3N0cmluZycgJiYgISgxIGluIGFyZ3VtZW50cykpID9cclxuICAgICAgICAoIXRoaXMubGVuZ3RoIHx8IHRoaXNbMF0ubm9kZVR5cGUgIT09IDEgPyB1bmRlZmluZWQgOlxyXG4gICAgICAgICAgKCEocmVzdWx0ID0gdGhpc1swXS5nZXRBdHRyaWJ1dGUobmFtZSkpICYmIG5hbWUgaW4gdGhpc1swXSkgPyB0aGlzWzBdW25hbWVdIDogcmVzdWx0XHJcbiAgICAgICAgKSA6XHJcbiAgICAgICAgdGhpcy5lYWNoKGZ1bmN0aW9uKGlkeCl7XHJcbiAgICAgICAgICBpZiAodGhpcy5ub2RlVHlwZSAhPT0gMSkgcmV0dXJuXHJcbiAgICAgICAgICBpZiAoaXNPYmplY3QobmFtZSkpIGZvciAoa2V5IGluIG5hbWUpIHNldEF0dHJpYnV0ZSh0aGlzLCBrZXksIG5hbWVba2V5XSlcclxuICAgICAgICAgIGVsc2Ugc2V0QXR0cmlidXRlKHRoaXMsIG5hbWUsIGZ1bmNBcmcodGhpcywgdmFsdWUsIGlkeCwgdGhpcy5nZXRBdHRyaWJ1dGUobmFtZSkpKVxyXG4gICAgICAgIH0pXHJcbiAgICB9LFxyXG4gICAgcmVtb3ZlQXR0cjogZnVuY3Rpb24obmFtZSl7XHJcbiAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKXsgdGhpcy5ub2RlVHlwZSA9PT0gMSAmJiBzZXRBdHRyaWJ1dGUodGhpcywgbmFtZSkgfSlcclxuICAgIH0sXHJcbiAgICBwcm9wOiBmdW5jdGlvbihuYW1lLCB2YWx1ZSl7XHJcbiAgICAgIG5hbWUgPSBwcm9wTWFwW25hbWVdIHx8IG5hbWVcclxuICAgICAgcmV0dXJuICgxIGluIGFyZ3VtZW50cykgP1xyXG4gICAgICAgIHRoaXMuZWFjaChmdW5jdGlvbihpZHgpe1xyXG4gICAgICAgICAgdGhpc1tuYW1lXSA9IGZ1bmNBcmcodGhpcywgdmFsdWUsIGlkeCwgdGhpc1tuYW1lXSlcclxuICAgICAgICB9KSA6XHJcbiAgICAgICAgKHRoaXNbMF0gJiYgdGhpc1swXVtuYW1lXSlcclxuICAgIH0sXHJcbiAgICBkYXRhOiBmdW5jdGlvbihuYW1lLCB2YWx1ZSl7XHJcbiAgICAgIHZhciBhdHRyTmFtZSA9ICdkYXRhLScgKyBuYW1lLnJlcGxhY2UoY2FwaXRhbFJFLCAnLSQxJykudG9Mb3dlckNhc2UoKVxyXG5cclxuICAgICAgdmFyIGRhdGEgPSAoMSBpbiBhcmd1bWVudHMpID9cclxuICAgICAgICB0aGlzLmF0dHIoYXR0ck5hbWUsIHZhbHVlKSA6XHJcbiAgICAgICAgdGhpcy5hdHRyKGF0dHJOYW1lKVxyXG5cclxuICAgICAgcmV0dXJuIGRhdGEgIT09IG51bGwgPyBkZXNlcmlhbGl6ZVZhbHVlKGRhdGEpIDogdW5kZWZpbmVkXHJcbiAgICB9LFxyXG4gICAgdmFsOiBmdW5jdGlvbih2YWx1ZSl7XHJcbiAgICAgIHJldHVybiAwIGluIGFyZ3VtZW50cyA/XHJcbiAgICAgICAgdGhpcy5lYWNoKGZ1bmN0aW9uKGlkeCl7XHJcbiAgICAgICAgICB0aGlzLnZhbHVlID0gZnVuY0FyZyh0aGlzLCB2YWx1ZSwgaWR4LCB0aGlzLnZhbHVlKVxyXG4gICAgICAgIH0pIDpcclxuICAgICAgICAodGhpc1swXSAmJiAodGhpc1swXS5tdWx0aXBsZSA/XHJcbiAgICAgICAgICAgJCh0aGlzWzBdKS5maW5kKCdvcHRpb24nKS5maWx0ZXIoZnVuY3Rpb24oKXsgcmV0dXJuIHRoaXMuc2VsZWN0ZWQgfSkucGx1Y2soJ3ZhbHVlJykgOlxyXG4gICAgICAgICAgIHRoaXNbMF0udmFsdWUpXHJcbiAgICAgICAgKVxyXG4gICAgfSxcclxuICAgIG9mZnNldDogZnVuY3Rpb24oY29vcmRpbmF0ZXMpe1xyXG4gICAgICBpZiAoY29vcmRpbmF0ZXMpIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oaW5kZXgpe1xyXG4gICAgICAgIHZhciAkdGhpcyA9ICQodGhpcyksXHJcbiAgICAgICAgICAgIGNvb3JkcyA9IGZ1bmNBcmcodGhpcywgY29vcmRpbmF0ZXMsIGluZGV4LCAkdGhpcy5vZmZzZXQoKSksXHJcbiAgICAgICAgICAgIHBhcmVudE9mZnNldCA9ICR0aGlzLm9mZnNldFBhcmVudCgpLm9mZnNldCgpLFxyXG4gICAgICAgICAgICBwcm9wcyA9IHtcclxuICAgICAgICAgICAgICB0b3A6ICBjb29yZHMudG9wICAtIHBhcmVudE9mZnNldC50b3AsXHJcbiAgICAgICAgICAgICAgbGVmdDogY29vcmRzLmxlZnQgLSBwYXJlbnRPZmZzZXQubGVmdFxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICgkdGhpcy5jc3MoJ3Bvc2l0aW9uJykgPT0gJ3N0YXRpYycpIHByb3BzWydwb3NpdGlvbiddID0gJ3JlbGF0aXZlJ1xyXG4gICAgICAgICR0aGlzLmNzcyhwcm9wcylcclxuICAgICAgfSlcclxuICAgICAgaWYgKCF0aGlzLmxlbmd0aCkgcmV0dXJuIG51bGxcclxuICAgICAgdmFyIG9iaiA9IHRoaXNbMF0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KClcclxuICAgICAgcmV0dXJuIHtcclxuICAgICAgICBsZWZ0OiBvYmoubGVmdCArIHdpbmRvdy5wYWdlWE9mZnNldCxcclxuICAgICAgICB0b3A6IG9iai50b3AgKyB3aW5kb3cucGFnZVlPZmZzZXQsXHJcbiAgICAgICAgd2lkdGg6IE1hdGgucm91bmQob2JqLndpZHRoKSxcclxuICAgICAgICBoZWlnaHQ6IE1hdGgucm91bmQob2JqLmhlaWdodClcclxuICAgICAgfVxyXG4gICAgfSxcclxuICAgIGNzczogZnVuY3Rpb24ocHJvcGVydHksIHZhbHVlKXtcclxuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAyKSB7XHJcbiAgICAgICAgdmFyIGVsZW1lbnQgPSB0aGlzWzBdLCBjb21wdXRlZFN0eWxlID0gZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50LCAnJylcclxuICAgICAgICBpZighZWxlbWVudCkgcmV0dXJuXHJcbiAgICAgICAgaWYgKHR5cGVvZiBwcm9wZXJ0eSA9PSAnc3RyaW5nJylcclxuICAgICAgICAgIHJldHVybiBlbGVtZW50LnN0eWxlW2NhbWVsaXplKHByb3BlcnR5KV0gfHwgY29tcHV0ZWRTdHlsZS5nZXRQcm9wZXJ0eVZhbHVlKHByb3BlcnR5KVxyXG4gICAgICAgIGVsc2UgaWYgKGlzQXJyYXkocHJvcGVydHkpKSB7XHJcbiAgICAgICAgICB2YXIgcHJvcHMgPSB7fVxyXG4gICAgICAgICAgJC5lYWNoKHByb3BlcnR5LCBmdW5jdGlvbihfLCBwcm9wKXtcclxuICAgICAgICAgICAgcHJvcHNbcHJvcF0gPSAoZWxlbWVudC5zdHlsZVtjYW1lbGl6ZShwcm9wKV0gfHwgY29tcHV0ZWRTdHlsZS5nZXRQcm9wZXJ0eVZhbHVlKHByb3ApKVxyXG4gICAgICAgICAgfSlcclxuICAgICAgICAgIHJldHVybiBwcm9wc1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgdmFyIGNzcyA9ICcnXHJcbiAgICAgIGlmICh0eXBlKHByb3BlcnR5KSA9PSAnc3RyaW5nJykge1xyXG4gICAgICAgIGlmICghdmFsdWUgJiYgdmFsdWUgIT09IDApXHJcbiAgICAgICAgICB0aGlzLmVhY2goZnVuY3Rpb24oKXsgdGhpcy5zdHlsZS5yZW1vdmVQcm9wZXJ0eShkYXNoZXJpemUocHJvcGVydHkpKSB9KVxyXG4gICAgICAgIGVsc2VcclxuICAgICAgICAgIGNzcyA9IGRhc2hlcml6ZShwcm9wZXJ0eSkgKyBcIjpcIiArIG1heWJlQWRkUHgocHJvcGVydHksIHZhbHVlKVxyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGZvciAoa2V5IGluIHByb3BlcnR5KVxyXG4gICAgICAgICAgaWYgKCFwcm9wZXJ0eVtrZXldICYmIHByb3BlcnR5W2tleV0gIT09IDApXHJcbiAgICAgICAgICAgIHRoaXMuZWFjaChmdW5jdGlvbigpeyB0aGlzLnN0eWxlLnJlbW92ZVByb3BlcnR5KGRhc2hlcml6ZShrZXkpKSB9KVxyXG4gICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICBjc3MgKz0gZGFzaGVyaXplKGtleSkgKyAnOicgKyBtYXliZUFkZFB4KGtleSwgcHJvcGVydHlba2V5XSkgKyAnOydcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpeyB0aGlzLnN0eWxlLmNzc1RleHQgKz0gJzsnICsgY3NzIH0pXHJcbiAgICB9LFxyXG4gICAgaW5kZXg6IGZ1bmN0aW9uKGVsZW1lbnQpe1xyXG4gICAgICByZXR1cm4gZWxlbWVudCA/IHRoaXMuaW5kZXhPZigkKGVsZW1lbnQpWzBdKSA6IHRoaXMucGFyZW50KCkuY2hpbGRyZW4oKS5pbmRleE9mKHRoaXNbMF0pXHJcbiAgICB9LFxyXG4gICAgaGFzQ2xhc3M6IGZ1bmN0aW9uKG5hbWUpe1xyXG4gICAgICBpZiAoIW5hbWUpIHJldHVybiBmYWxzZVxyXG4gICAgICByZXR1cm4gZW1wdHlBcnJheS5zb21lLmNhbGwodGhpcywgZnVuY3Rpb24oZWwpe1xyXG4gICAgICAgIHJldHVybiB0aGlzLnRlc3QoY2xhc3NOYW1lKGVsKSlcclxuICAgICAgfSwgY2xhc3NSRShuYW1lKSlcclxuICAgIH0sXHJcbiAgICBhZGRDbGFzczogZnVuY3Rpb24obmFtZSl7XHJcbiAgICAgIGlmICghbmFtZSkgcmV0dXJuIHRoaXNcclxuICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbihpZHgpe1xyXG4gICAgICAgIGlmICghKCdjbGFzc05hbWUnIGluIHRoaXMpKSByZXR1cm5cclxuICAgICAgICBjbGFzc0xpc3QgPSBbXVxyXG4gICAgICAgIHZhciBjbHMgPSBjbGFzc05hbWUodGhpcyksIG5ld05hbWUgPSBmdW5jQXJnKHRoaXMsIG5hbWUsIGlkeCwgY2xzKVxyXG4gICAgICAgIG5ld05hbWUuc3BsaXQoL1xccysvZykuZm9yRWFjaChmdW5jdGlvbihrbGFzcyl7XHJcbiAgICAgICAgICBpZiAoISQodGhpcykuaGFzQ2xhc3Moa2xhc3MpKSBjbGFzc0xpc3QucHVzaChrbGFzcylcclxuICAgICAgICB9LCB0aGlzKVxyXG4gICAgICAgIGNsYXNzTGlzdC5sZW5ndGggJiYgY2xhc3NOYW1lKHRoaXMsIGNscyArIChjbHMgPyBcIiBcIiA6IFwiXCIpICsgY2xhc3NMaXN0LmpvaW4oXCIgXCIpKVxyXG4gICAgICB9KVxyXG4gICAgfSxcclxuICAgIHJlbW92ZUNsYXNzOiBmdW5jdGlvbihuYW1lKXtcclxuICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbihpZHgpe1xyXG4gICAgICAgIGlmICghKCdjbGFzc05hbWUnIGluIHRoaXMpKSByZXR1cm5cclxuICAgICAgICBpZiAobmFtZSA9PT0gdW5kZWZpbmVkKSByZXR1cm4gY2xhc3NOYW1lKHRoaXMsICcnKVxyXG4gICAgICAgIGNsYXNzTGlzdCA9IGNsYXNzTmFtZSh0aGlzKVxyXG4gICAgICAgIGZ1bmNBcmcodGhpcywgbmFtZSwgaWR4LCBjbGFzc0xpc3QpLnNwbGl0KC9cXHMrL2cpLmZvckVhY2goZnVuY3Rpb24oa2xhc3Mpe1xyXG4gICAgICAgICAgY2xhc3NMaXN0ID0gY2xhc3NMaXN0LnJlcGxhY2UoY2xhc3NSRShrbGFzcyksIFwiIFwiKVxyXG4gICAgICAgIH0pXHJcbiAgICAgICAgY2xhc3NOYW1lKHRoaXMsIGNsYXNzTGlzdC50cmltKCkpXHJcbiAgICAgIH0pXHJcbiAgICB9LFxyXG4gICAgdG9nZ2xlQ2xhc3M6IGZ1bmN0aW9uKG5hbWUsIHdoZW4pe1xyXG4gICAgICBpZiAoIW5hbWUpIHJldHVybiB0aGlzXHJcbiAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oaWR4KXtcclxuICAgICAgICB2YXIgJHRoaXMgPSAkKHRoaXMpLCBuYW1lcyA9IGZ1bmNBcmcodGhpcywgbmFtZSwgaWR4LCBjbGFzc05hbWUodGhpcykpXHJcbiAgICAgICAgbmFtZXMuc3BsaXQoL1xccysvZykuZm9yRWFjaChmdW5jdGlvbihrbGFzcyl7XHJcbiAgICAgICAgICAod2hlbiA9PT0gdW5kZWZpbmVkID8gISR0aGlzLmhhc0NsYXNzKGtsYXNzKSA6IHdoZW4pID9cclxuICAgICAgICAgICAgJHRoaXMuYWRkQ2xhc3Moa2xhc3MpIDogJHRoaXMucmVtb3ZlQ2xhc3Moa2xhc3MpXHJcbiAgICAgICAgfSlcclxuICAgICAgfSlcclxuICAgIH0sXHJcbiAgICBzY3JvbGxUb3A6IGZ1bmN0aW9uKHZhbHVlKXtcclxuICAgICAgaWYgKCF0aGlzLmxlbmd0aCkgcmV0dXJuXHJcbiAgICAgIHZhciBoYXNTY3JvbGxUb3AgPSAnc2Nyb2xsVG9wJyBpbiB0aGlzWzBdXHJcbiAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSByZXR1cm4gaGFzU2Nyb2xsVG9wID8gdGhpc1swXS5zY3JvbGxUb3AgOiB0aGlzWzBdLnBhZ2VZT2Zmc2V0XHJcbiAgICAgIHJldHVybiB0aGlzLmVhY2goaGFzU2Nyb2xsVG9wID9cclxuICAgICAgICBmdW5jdGlvbigpeyB0aGlzLnNjcm9sbFRvcCA9IHZhbHVlIH0gOlxyXG4gICAgICAgIGZ1bmN0aW9uKCl7IHRoaXMuc2Nyb2xsVG8odGhpcy5zY3JvbGxYLCB2YWx1ZSkgfSlcclxuICAgIH0sXHJcbiAgICBzY3JvbGxMZWZ0OiBmdW5jdGlvbih2YWx1ZSl7XHJcbiAgICAgIGlmICghdGhpcy5sZW5ndGgpIHJldHVyblxyXG4gICAgICB2YXIgaGFzU2Nyb2xsTGVmdCA9ICdzY3JvbGxMZWZ0JyBpbiB0aGlzWzBdXHJcbiAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSByZXR1cm4gaGFzU2Nyb2xsTGVmdCA/IHRoaXNbMF0uc2Nyb2xsTGVmdCA6IHRoaXNbMF0ucGFnZVhPZmZzZXRcclxuICAgICAgcmV0dXJuIHRoaXMuZWFjaChoYXNTY3JvbGxMZWZ0ID9cclxuICAgICAgICBmdW5jdGlvbigpeyB0aGlzLnNjcm9sbExlZnQgPSB2YWx1ZSB9IDpcclxuICAgICAgICBmdW5jdGlvbigpeyB0aGlzLnNjcm9sbFRvKHZhbHVlLCB0aGlzLnNjcm9sbFkpIH0pXHJcbiAgICB9LFxyXG4gICAgcG9zaXRpb246IGZ1bmN0aW9uKCkge1xyXG4gICAgICBpZiAoIXRoaXMubGVuZ3RoKSByZXR1cm5cclxuXHJcbiAgICAgIHZhciBlbGVtID0gdGhpc1swXSxcclxuICAgICAgICAvLyBHZXQgKnJlYWwqIG9mZnNldFBhcmVudFxyXG4gICAgICAgIG9mZnNldFBhcmVudCA9IHRoaXMub2Zmc2V0UGFyZW50KCksXHJcbiAgICAgICAgLy8gR2V0IGNvcnJlY3Qgb2Zmc2V0c1xyXG4gICAgICAgIG9mZnNldCAgICAgICA9IHRoaXMub2Zmc2V0KCksXHJcbiAgICAgICAgcGFyZW50T2Zmc2V0ID0gcm9vdE5vZGVSRS50ZXN0KG9mZnNldFBhcmVudFswXS5ub2RlTmFtZSkgPyB7IHRvcDogMCwgbGVmdDogMCB9IDogb2Zmc2V0UGFyZW50Lm9mZnNldCgpXHJcblxyXG4gICAgICAvLyBTdWJ0cmFjdCBlbGVtZW50IG1hcmdpbnNcclxuICAgICAgLy8gbm90ZTogd2hlbiBhbiBlbGVtZW50IGhhcyBtYXJnaW46IGF1dG8gdGhlIG9mZnNldExlZnQgYW5kIG1hcmdpbkxlZnRcclxuICAgICAgLy8gYXJlIHRoZSBzYW1lIGluIFNhZmFyaSBjYXVzaW5nIG9mZnNldC5sZWZ0IHRvIGluY29ycmVjdGx5IGJlIDBcclxuICAgICAgb2Zmc2V0LnRvcCAgLT0gcGFyc2VGbG9hdCggJChlbGVtKS5jc3MoJ21hcmdpbi10b3AnKSApIHx8IDBcclxuICAgICAgb2Zmc2V0LmxlZnQgLT0gcGFyc2VGbG9hdCggJChlbGVtKS5jc3MoJ21hcmdpbi1sZWZ0JykgKSB8fCAwXHJcblxyXG4gICAgICAvLyBBZGQgb2Zmc2V0UGFyZW50IGJvcmRlcnNcclxuICAgICAgcGFyZW50T2Zmc2V0LnRvcCAgKz0gcGFyc2VGbG9hdCggJChvZmZzZXRQYXJlbnRbMF0pLmNzcygnYm9yZGVyLXRvcC13aWR0aCcpICkgfHwgMFxyXG4gICAgICBwYXJlbnRPZmZzZXQubGVmdCArPSBwYXJzZUZsb2F0KCAkKG9mZnNldFBhcmVudFswXSkuY3NzKCdib3JkZXItbGVmdC13aWR0aCcpICkgfHwgMFxyXG5cclxuICAgICAgLy8gU3VidHJhY3QgdGhlIHR3byBvZmZzZXRzXHJcbiAgICAgIHJldHVybiB7XHJcbiAgICAgICAgdG9wOiAgb2Zmc2V0LnRvcCAgLSBwYXJlbnRPZmZzZXQudG9wLFxyXG4gICAgICAgIGxlZnQ6IG9mZnNldC5sZWZ0IC0gcGFyZW50T2Zmc2V0LmxlZnRcclxuICAgICAgfVxyXG4gICAgfSxcclxuICAgIG9mZnNldFBhcmVudDogZnVuY3Rpb24oKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLm1hcChmdW5jdGlvbigpe1xyXG4gICAgICAgIHZhciBwYXJlbnQgPSB0aGlzLm9mZnNldFBhcmVudCB8fCBkb2N1bWVudC5ib2R5XHJcbiAgICAgICAgd2hpbGUgKHBhcmVudCAmJiAhcm9vdE5vZGVSRS50ZXN0KHBhcmVudC5ub2RlTmFtZSkgJiYgJChwYXJlbnQpLmNzcyhcInBvc2l0aW9uXCIpID09IFwic3RhdGljXCIpXHJcbiAgICAgICAgICBwYXJlbnQgPSBwYXJlbnQub2Zmc2V0UGFyZW50XHJcbiAgICAgICAgcmV0dXJuIHBhcmVudFxyXG4gICAgICB9KVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLy8gZm9yIG5vd1xyXG4gICQuZm4uZGV0YWNoID0gJC5mbi5yZW1vdmVcclxuXHJcbiAgLy8gR2VuZXJhdGUgdGhlIGB3aWR0aGAgYW5kIGBoZWlnaHRgIGZ1bmN0aW9uc1xyXG4gIDtbJ3dpZHRoJywgJ2hlaWdodCddLmZvckVhY2goZnVuY3Rpb24oZGltZW5zaW9uKXtcclxuICAgIHZhciBkaW1lbnNpb25Qcm9wZXJ0eSA9XHJcbiAgICAgIGRpbWVuc2lvbi5yZXBsYWNlKC8uLywgZnVuY3Rpb24obSl7IHJldHVybiBtWzBdLnRvVXBwZXJDYXNlKCkgfSlcclxuXHJcbiAgICAkLmZuW2RpbWVuc2lvbl0gPSBmdW5jdGlvbih2YWx1ZSl7XHJcbiAgICAgIHZhciBvZmZzZXQsIGVsID0gdGhpc1swXVxyXG4gICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkgcmV0dXJuIGlzV2luZG93KGVsKSA/IGVsWydpbm5lcicgKyBkaW1lbnNpb25Qcm9wZXJ0eV0gOlxyXG4gICAgICAgIGlzRG9jdW1lbnQoZWwpID8gZWwuZG9jdW1lbnRFbGVtZW50WydzY3JvbGwnICsgZGltZW5zaW9uUHJvcGVydHldIDpcclxuICAgICAgICAob2Zmc2V0ID0gdGhpcy5vZmZzZXQoKSkgJiYgb2Zmc2V0W2RpbWVuc2lvbl1cclxuICAgICAgZWxzZSByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKGlkeCl7XHJcbiAgICAgICAgZWwgPSAkKHRoaXMpXHJcbiAgICAgICAgZWwuY3NzKGRpbWVuc2lvbiwgZnVuY0FyZyh0aGlzLCB2YWx1ZSwgaWR4LCBlbFtkaW1lbnNpb25dKCkpKVxyXG4gICAgICB9KVxyXG4gICAgfVxyXG4gIH0pXHJcblxyXG4gIGZ1bmN0aW9uIHRyYXZlcnNlTm9kZShub2RlLCBmdW4pIHtcclxuICAgIGZ1bihub2RlKVxyXG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IG5vZGUuY2hpbGROb2Rlcy5sZW5ndGg7IGkgPCBsZW47IGkrKylcclxuICAgICAgdHJhdmVyc2VOb2RlKG5vZGUuY2hpbGROb2Rlc1tpXSwgZnVuKVxyXG4gIH1cclxuXHJcbiAgLy8gR2VuZXJhdGUgdGhlIGBhZnRlcmAsIGBwcmVwZW5kYCwgYGJlZm9yZWAsIGBhcHBlbmRgLFxyXG4gIC8vIGBpbnNlcnRBZnRlcmAsIGBpbnNlcnRCZWZvcmVgLCBgYXBwZW5kVG9gLCBhbmQgYHByZXBlbmRUb2AgbWV0aG9kcy5cclxuICBhZGphY2VuY3lPcGVyYXRvcnMuZm9yRWFjaChmdW5jdGlvbihvcGVyYXRvciwgb3BlcmF0b3JJbmRleCkge1xyXG4gICAgdmFyIGluc2lkZSA9IG9wZXJhdG9ySW5kZXggJSAyIC8vPT4gcHJlcGVuZCwgYXBwZW5kXHJcblxyXG4gICAgJC5mbltvcGVyYXRvcl0gPSBmdW5jdGlvbigpe1xyXG4gICAgICAvLyBhcmd1bWVudHMgY2FuIGJlIG5vZGVzLCBhcnJheXMgb2Ygbm9kZXMsIFplcHRvIG9iamVjdHMgYW5kIEhUTUwgc3RyaW5nc1xyXG4gICAgICB2YXIgYXJnVHlwZSwgbm9kZXMgPSAkLm1hcChhcmd1bWVudHMsIGZ1bmN0aW9uKGFyZykge1xyXG4gICAgICAgICAgICBhcmdUeXBlID0gdHlwZShhcmcpXHJcbiAgICAgICAgICAgIHJldHVybiBhcmdUeXBlID09IFwib2JqZWN0XCIgfHwgYXJnVHlwZSA9PSBcImFycmF5XCIgfHwgYXJnID09IG51bGwgP1xyXG4gICAgICAgICAgICAgIGFyZyA6IHplcHRvLmZyYWdtZW50KGFyZylcclxuICAgICAgICAgIH0pLFxyXG4gICAgICAgICAgcGFyZW50LCBjb3B5QnlDbG9uZSA9IHRoaXMubGVuZ3RoID4gMVxyXG4gICAgICBpZiAobm9kZXMubGVuZ3RoIDwgMSkgcmV0dXJuIHRoaXNcclxuXHJcbiAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oXywgdGFyZ2V0KXtcclxuICAgICAgICBwYXJlbnQgPSBpbnNpZGUgPyB0YXJnZXQgOiB0YXJnZXQucGFyZW50Tm9kZVxyXG5cclxuICAgICAgICAvLyBjb252ZXJ0IGFsbCBtZXRob2RzIHRvIGEgXCJiZWZvcmVcIiBvcGVyYXRpb25cclxuICAgICAgICB0YXJnZXQgPSBvcGVyYXRvckluZGV4ID09IDAgPyB0YXJnZXQubmV4dFNpYmxpbmcgOlxyXG4gICAgICAgICAgICAgICAgIG9wZXJhdG9ySW5kZXggPT0gMSA/IHRhcmdldC5maXJzdENoaWxkIDpcclxuICAgICAgICAgICAgICAgICBvcGVyYXRvckluZGV4ID09IDIgPyB0YXJnZXQgOlxyXG4gICAgICAgICAgICAgICAgIG51bGxcclxuXHJcbiAgICAgICAgdmFyIHBhcmVudEluRG9jdW1lbnQgPSAkLmNvbnRhaW5zKGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCwgcGFyZW50KVxyXG5cclxuICAgICAgICBub2Rlcy5mb3JFYWNoKGZ1bmN0aW9uKG5vZGUpe1xyXG4gICAgICAgICAgaWYgKGNvcHlCeUNsb25lKSBub2RlID0gbm9kZS5jbG9uZU5vZGUodHJ1ZSlcclxuICAgICAgICAgIGVsc2UgaWYgKCFwYXJlbnQpIHJldHVybiAkKG5vZGUpLnJlbW92ZSgpXHJcblxyXG4gICAgICAgICAgcGFyZW50Lmluc2VydEJlZm9yZShub2RlLCB0YXJnZXQpXHJcbiAgICAgICAgICBpZiAocGFyZW50SW5Eb2N1bWVudCkgdHJhdmVyc2VOb2RlKG5vZGUsIGZ1bmN0aW9uKGVsKXtcclxuICAgICAgICAgICAgaWYgKGVsLm5vZGVOYW1lICE9IG51bGwgJiYgZWwubm9kZU5hbWUudG9VcHBlckNhc2UoKSA9PT0gJ1NDUklQVCcgJiZcclxuICAgICAgICAgICAgICAgKCFlbC50eXBlIHx8IGVsLnR5cGUgPT09ICd0ZXh0L2phdmFzY3JpcHQnKSAmJiAhZWwuc3JjKVxyXG4gICAgICAgICAgICAgIHdpbmRvd1snZXZhbCddLmNhbGwod2luZG93LCBlbC5pbm5lckhUTUwpXHJcbiAgICAgICAgICB9KVxyXG4gICAgICAgIH0pXHJcbiAgICAgIH0pXHJcbiAgICB9XHJcblxyXG4gICAgLy8gYWZ0ZXIgICAgPT4gaW5zZXJ0QWZ0ZXJcclxuICAgIC8vIHByZXBlbmQgID0+IHByZXBlbmRUb1xyXG4gICAgLy8gYmVmb3JlICAgPT4gaW5zZXJ0QmVmb3JlXHJcbiAgICAvLyBhcHBlbmQgICA9PiBhcHBlbmRUb1xyXG4gICAgJC5mbltpbnNpZGUgPyBvcGVyYXRvcisnVG8nIDogJ2luc2VydCcrKG9wZXJhdG9ySW5kZXggPyAnQmVmb3JlJyA6ICdBZnRlcicpXSA9IGZ1bmN0aW9uKGh0bWwpe1xyXG4gICAgICAkKGh0bWwpW29wZXJhdG9yXSh0aGlzKVxyXG4gICAgICByZXR1cm4gdGhpc1xyXG4gICAgfVxyXG4gIH0pXHJcblxyXG4gIHplcHRvLloucHJvdG90eXBlID0gJC5mblxyXG5cclxuICAvLyBFeHBvcnQgaW50ZXJuYWwgQVBJIGZ1bmN0aW9ucyBpbiB0aGUgYCQuemVwdG9gIG5hbWVzcGFjZVxyXG4gIHplcHRvLnVuaXEgPSB1bmlxXHJcbiAgemVwdG8uZGVzZXJpYWxpemVWYWx1ZSA9IGRlc2VyaWFsaXplVmFsdWVcclxuICAkLnplcHRvID0gemVwdG9cclxuXHJcbiAgcmV0dXJuICRcclxufSkoKVxyXG5cclxud2luZG93LlplcHRvID0gWmVwdG9cclxud2luZG93LiQgPT09IHVuZGVmaW5lZCAmJiAod2luZG93LiQgPSBaZXB0bylcclxuXHJcbjsoZnVuY3Rpb24oJCl7XHJcbiAgdmFyIGpzb25wSUQgPSAwLFxyXG4gICAgICBkb2N1bWVudCA9IHdpbmRvdy5kb2N1bWVudCxcclxuICAgICAga2V5LFxyXG4gICAgICBuYW1lLFxyXG4gICAgICByc2NyaXB0ID0gLzxzY3JpcHRcXGJbXjxdKig/Oig/ITxcXC9zY3JpcHQ+KTxbXjxdKikqPFxcL3NjcmlwdD4vZ2ksXHJcbiAgICAgIHNjcmlwdFR5cGVSRSA9IC9eKD86dGV4dHxhcHBsaWNhdGlvbilcXC9qYXZhc2NyaXB0L2ksXHJcbiAgICAgIHhtbFR5cGVSRSA9IC9eKD86dGV4dHxhcHBsaWNhdGlvbilcXC94bWwvaSxcclxuICAgICAganNvblR5cGUgPSAnYXBwbGljYXRpb24vanNvbicsXHJcbiAgICAgIGh0bWxUeXBlID0gJ3RleHQvaHRtbCcsXHJcbiAgICAgIGJsYW5rUkUgPSAvXlxccyokL1xyXG5cclxuICAvLyB0cmlnZ2VyIGEgY3VzdG9tIGV2ZW50IGFuZCByZXR1cm4gZmFsc2UgaWYgaXQgd2FzIGNhbmNlbGxlZFxyXG4gIGZ1bmN0aW9uIHRyaWdnZXJBbmRSZXR1cm4oY29udGV4dCwgZXZlbnROYW1lLCBkYXRhKSB7XHJcbiAgICB2YXIgZXZlbnQgPSAkLkV2ZW50KGV2ZW50TmFtZSlcclxuICAgICQoY29udGV4dCkudHJpZ2dlcihldmVudCwgZGF0YSlcclxuICAgIHJldHVybiAhZXZlbnQuaXNEZWZhdWx0UHJldmVudGVkKClcclxuICB9XHJcblxyXG4gIC8vIHRyaWdnZXIgYW4gQWpheCBcImdsb2JhbFwiIGV2ZW50XHJcbiAgZnVuY3Rpb24gdHJpZ2dlckdsb2JhbChzZXR0aW5ncywgY29udGV4dCwgZXZlbnROYW1lLCBkYXRhKSB7XHJcbiAgICBpZiAoc2V0dGluZ3MuZ2xvYmFsKSByZXR1cm4gdHJpZ2dlckFuZFJldHVybihjb250ZXh0IHx8IGRvY3VtZW50LCBldmVudE5hbWUsIGRhdGEpXHJcbiAgfVxyXG5cclxuICAvLyBOdW1iZXIgb2YgYWN0aXZlIEFqYXggcmVxdWVzdHNcclxuICAkLmFjdGl2ZSA9IDBcclxuXHJcbiAgZnVuY3Rpb24gYWpheFN0YXJ0KHNldHRpbmdzKSB7XHJcbiAgICBpZiAoc2V0dGluZ3MuZ2xvYmFsICYmICQuYWN0aXZlKysgPT09IDApIHRyaWdnZXJHbG9iYWwoc2V0dGluZ3MsIG51bGwsICdhamF4U3RhcnQnKVxyXG4gIH1cclxuICBmdW5jdGlvbiBhamF4U3RvcChzZXR0aW5ncykge1xyXG4gICAgaWYgKHNldHRpbmdzLmdsb2JhbCAmJiAhKC0tJC5hY3RpdmUpKSB0cmlnZ2VyR2xvYmFsKHNldHRpbmdzLCBudWxsLCAnYWpheFN0b3AnKVxyXG4gIH1cclxuXHJcbiAgLy8gdHJpZ2dlcnMgYW4gZXh0cmEgZ2xvYmFsIGV2ZW50IFwiYWpheEJlZm9yZVNlbmRcIiB0aGF0J3MgbGlrZSBcImFqYXhTZW5kXCIgYnV0IGNhbmNlbGFibGVcclxuICBmdW5jdGlvbiBhamF4QmVmb3JlU2VuZCh4aHIsIHNldHRpbmdzKSB7XHJcbiAgICB2YXIgY29udGV4dCA9IHNldHRpbmdzLmNvbnRleHRcclxuICAgIGlmIChzZXR0aW5ncy5iZWZvcmVTZW5kLmNhbGwoY29udGV4dCwgeGhyLCBzZXR0aW5ncykgPT09IGZhbHNlIHx8XHJcbiAgICAgICAgdHJpZ2dlckdsb2JhbChzZXR0aW5ncywgY29udGV4dCwgJ2FqYXhCZWZvcmVTZW5kJywgW3hociwgc2V0dGluZ3NdKSA9PT0gZmFsc2UpXHJcbiAgICAgIHJldHVybiBmYWxzZVxyXG5cclxuICAgIHRyaWdnZXJHbG9iYWwoc2V0dGluZ3MsIGNvbnRleHQsICdhamF4U2VuZCcsIFt4aHIsIHNldHRpbmdzXSlcclxuICB9XHJcbiAgZnVuY3Rpb24gYWpheFN1Y2Nlc3MoZGF0YSwgeGhyLCBzZXR0aW5ncywgZGVmZXJyZWQpIHtcclxuICAgIHZhciBjb250ZXh0ID0gc2V0dGluZ3MuY29udGV4dCwgc3RhdHVzID0gJ3N1Y2Nlc3MnXHJcbiAgICBzZXR0aW5ncy5zdWNjZXNzLmNhbGwoY29udGV4dCwgZGF0YSwgc3RhdHVzLCB4aHIpXHJcbiAgICBpZiAoZGVmZXJyZWQpIGRlZmVycmVkLnJlc29sdmVXaXRoKGNvbnRleHQsIFtkYXRhLCBzdGF0dXMsIHhocl0pXHJcbiAgICB0cmlnZ2VyR2xvYmFsKHNldHRpbmdzLCBjb250ZXh0LCAnYWpheFN1Y2Nlc3MnLCBbeGhyLCBzZXR0aW5ncywgZGF0YV0pXHJcbiAgICBhamF4Q29tcGxldGUoc3RhdHVzLCB4aHIsIHNldHRpbmdzKVxyXG4gIH1cclxuICAvLyB0eXBlOiBcInRpbWVvdXRcIiwgXCJlcnJvclwiLCBcImFib3J0XCIsIFwicGFyc2VyZXJyb3JcIlxyXG4gIGZ1bmN0aW9uIGFqYXhFcnJvcihlcnJvciwgdHlwZSwgeGhyLCBzZXR0aW5ncywgZGVmZXJyZWQpIHtcclxuICAgIHZhciBjb250ZXh0ID0gc2V0dGluZ3MuY29udGV4dFxyXG4gICAgc2V0dGluZ3MuZXJyb3IuY2FsbChjb250ZXh0LCB4aHIsIHR5cGUsIGVycm9yKVxyXG4gICAgaWYgKGRlZmVycmVkKSBkZWZlcnJlZC5yZWplY3RXaXRoKGNvbnRleHQsIFt4aHIsIHR5cGUsIGVycm9yXSlcclxuICAgIHRyaWdnZXJHbG9iYWwoc2V0dGluZ3MsIGNvbnRleHQsICdhamF4RXJyb3InLCBbeGhyLCBzZXR0aW5ncywgZXJyb3IgfHwgdHlwZV0pXHJcbiAgICBhamF4Q29tcGxldGUodHlwZSwgeGhyLCBzZXR0aW5ncylcclxuICB9XHJcbiAgLy8gc3RhdHVzOiBcInN1Y2Nlc3NcIiwgXCJub3Rtb2RpZmllZFwiLCBcImVycm9yXCIsIFwidGltZW91dFwiLCBcImFib3J0XCIsIFwicGFyc2VyZXJyb3JcIlxyXG4gIGZ1bmN0aW9uIGFqYXhDb21wbGV0ZShzdGF0dXMsIHhociwgc2V0dGluZ3MpIHtcclxuICAgIHZhciBjb250ZXh0ID0gc2V0dGluZ3MuY29udGV4dFxyXG4gICAgc2V0dGluZ3MuY29tcGxldGUuY2FsbChjb250ZXh0LCB4aHIsIHN0YXR1cylcclxuICAgIHRyaWdnZXJHbG9iYWwoc2V0dGluZ3MsIGNvbnRleHQsICdhamF4Q29tcGxldGUnLCBbeGhyLCBzZXR0aW5nc10pXHJcbiAgICBhamF4U3RvcChzZXR0aW5ncylcclxuICB9XHJcblxyXG4gIC8vIEVtcHR5IGZ1bmN0aW9uLCB1c2VkIGFzIGRlZmF1bHQgY2FsbGJhY2tcclxuICBmdW5jdGlvbiBlbXB0eSgpIHt9XHJcblxyXG4gICQuYWpheEpTT05QID0gZnVuY3Rpb24ob3B0aW9ucywgZGVmZXJyZWQpe1xyXG4gICAgaWYgKCEoJ3R5cGUnIGluIG9wdGlvbnMpKSByZXR1cm4gJC5hamF4KG9wdGlvbnMpXHJcblxyXG4gICAgdmFyIF9jYWxsYmFja05hbWUgPSBvcHRpb25zLmpzb25wQ2FsbGJhY2ssXHJcbiAgICAgIGNhbGxiYWNrTmFtZSA9ICgkLmlzRnVuY3Rpb24oX2NhbGxiYWNrTmFtZSkgP1xyXG4gICAgICAgIF9jYWxsYmFja05hbWUoKSA6IF9jYWxsYmFja05hbWUpIHx8ICgnanNvbnAnICsgKCsranNvbnBJRCkpLFxyXG4gICAgICBzY3JpcHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKSxcclxuICAgICAgb3JpZ2luYWxDYWxsYmFjayA9IHdpbmRvd1tjYWxsYmFja05hbWVdLFxyXG4gICAgICByZXNwb25zZURhdGEsXHJcbiAgICAgIGFib3J0ID0gZnVuY3Rpb24oZXJyb3JUeXBlKSB7XHJcbiAgICAgICAgJChzY3JpcHQpLnRyaWdnZXJIYW5kbGVyKCdlcnJvcicsIGVycm9yVHlwZSB8fCAnYWJvcnQnKVxyXG4gICAgICB9LFxyXG4gICAgICB4aHIgPSB7IGFib3J0OiBhYm9ydCB9LCBhYm9ydFRpbWVvdXRcclxuXHJcbiAgICBpZiAoZGVmZXJyZWQpIGRlZmVycmVkLnByb21pc2UoeGhyKVxyXG5cclxuICAgICQoc2NyaXB0KS5vbignbG9hZCBlcnJvcicsIGZ1bmN0aW9uKGUsIGVycm9yVHlwZSl7XHJcbiAgICAgIGNsZWFyVGltZW91dChhYm9ydFRpbWVvdXQpXHJcbiAgICAgICQoc2NyaXB0KS5vZmYoKS5yZW1vdmUoKVxyXG5cclxuICAgICAgaWYgKGUudHlwZSA9PSAnZXJyb3InIHx8ICFyZXNwb25zZURhdGEpIHtcclxuICAgICAgICBhamF4RXJyb3IobnVsbCwgZXJyb3JUeXBlIHx8ICdlcnJvcicsIHhociwgb3B0aW9ucywgZGVmZXJyZWQpXHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgYWpheFN1Y2Nlc3MocmVzcG9uc2VEYXRhWzBdLCB4aHIsIG9wdGlvbnMsIGRlZmVycmVkKVxyXG4gICAgICB9XHJcblxyXG4gICAgICB3aW5kb3dbY2FsbGJhY2tOYW1lXSA9IG9yaWdpbmFsQ2FsbGJhY2tcclxuICAgICAgaWYgKHJlc3BvbnNlRGF0YSAmJiAkLmlzRnVuY3Rpb24ob3JpZ2luYWxDYWxsYmFjaykpXHJcbiAgICAgICAgb3JpZ2luYWxDYWxsYmFjayhyZXNwb25zZURhdGFbMF0pXHJcblxyXG4gICAgICBvcmlnaW5hbENhbGxiYWNrID0gcmVzcG9uc2VEYXRhID0gdW5kZWZpbmVkXHJcbiAgICB9KVxyXG5cclxuICAgIGlmIChhamF4QmVmb3JlU2VuZCh4aHIsIG9wdGlvbnMpID09PSBmYWxzZSkge1xyXG4gICAgICBhYm9ydCgnYWJvcnQnKVxyXG4gICAgICByZXR1cm4geGhyXHJcbiAgICB9XHJcblxyXG4gICAgd2luZG93W2NhbGxiYWNrTmFtZV0gPSBmdW5jdGlvbigpe1xyXG4gICAgICByZXNwb25zZURhdGEgPSBhcmd1bWVudHNcclxuICAgIH1cclxuXHJcbiAgICBzY3JpcHQuc3JjID0gb3B0aW9ucy51cmwucmVwbGFjZSgvXFw/KC4rKT1cXD8vLCAnPyQxPScgKyBjYWxsYmFja05hbWUpXHJcbiAgICBkb2N1bWVudC5oZWFkLmFwcGVuZENoaWxkKHNjcmlwdClcclxuXHJcbiAgICBpZiAob3B0aW9ucy50aW1lb3V0ID4gMCkgYWJvcnRUaW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbigpe1xyXG4gICAgICBhYm9ydCgndGltZW91dCcpXHJcbiAgICB9LCBvcHRpb25zLnRpbWVvdXQpXHJcblxyXG4gICAgcmV0dXJuIHhoclxyXG4gIH1cclxuXHJcbiAgJC5hamF4U2V0dGluZ3MgPSB7XHJcbiAgICAvLyBEZWZhdWx0IHR5cGUgb2YgcmVxdWVzdFxyXG4gICAgdHlwZTogJ0dFVCcsXHJcbiAgICAvLyBDYWxsYmFjayB0aGF0IGlzIGV4ZWN1dGVkIGJlZm9yZSByZXF1ZXN0XHJcbiAgICBiZWZvcmVTZW5kOiBlbXB0eSxcclxuICAgIC8vIENhbGxiYWNrIHRoYXQgaXMgZXhlY3V0ZWQgaWYgdGhlIHJlcXVlc3Qgc3VjY2VlZHNcclxuICAgIHN1Y2Nlc3M6IGVtcHR5LFxyXG4gICAgLy8gQ2FsbGJhY2sgdGhhdCBpcyBleGVjdXRlZCB0aGUgdGhlIHNlcnZlciBkcm9wcyBlcnJvclxyXG4gICAgZXJyb3I6IGVtcHR5LFxyXG4gICAgLy8gQ2FsbGJhY2sgdGhhdCBpcyBleGVjdXRlZCBvbiByZXF1ZXN0IGNvbXBsZXRlIChib3RoOiBlcnJvciBhbmQgc3VjY2VzcylcclxuICAgIGNvbXBsZXRlOiBlbXB0eSxcclxuICAgIC8vIFRoZSBjb250ZXh0IGZvciB0aGUgY2FsbGJhY2tzXHJcbiAgICBjb250ZXh0OiBudWxsLFxyXG4gICAgLy8gV2hldGhlciB0byB0cmlnZ2VyIFwiZ2xvYmFsXCIgQWpheCBldmVudHNcclxuICAgIGdsb2JhbDogdHJ1ZSxcclxuICAgIC8vIFRyYW5zcG9ydFxyXG4gICAgeGhyOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHJldHVybiBuZXcgd2luZG93LlhNTEh0dHBSZXF1ZXN0KClcclxuICAgIH0sXHJcbiAgICAvLyBNSU1FIHR5cGVzIG1hcHBpbmdcclxuICAgIC8vIElJUyByZXR1cm5zIEphdmFzY3JpcHQgYXMgXCJhcHBsaWNhdGlvbi94LWphdmFzY3JpcHRcIlxyXG4gICAgYWNjZXB0czoge1xyXG4gICAgICBzY3JpcHQ6ICd0ZXh0L2phdmFzY3JpcHQsIGFwcGxpY2F0aW9uL2phdmFzY3JpcHQsIGFwcGxpY2F0aW9uL3gtamF2YXNjcmlwdCcsXHJcbiAgICAgIGpzb246ICAganNvblR5cGUsXHJcbiAgICAgIHhtbDogICAgJ2FwcGxpY2F0aW9uL3htbCwgdGV4dC94bWwnLFxyXG4gICAgICBodG1sOiAgIGh0bWxUeXBlLFxyXG4gICAgICB0ZXh0OiAgICd0ZXh0L3BsYWluJ1xyXG4gICAgfSxcclxuICAgIC8vIFdoZXRoZXIgdGhlIHJlcXVlc3QgaXMgdG8gYW5vdGhlciBkb21haW5cclxuICAgIGNyb3NzRG9tYWluOiBmYWxzZSxcclxuICAgIC8vIERlZmF1bHQgdGltZW91dFxyXG4gICAgdGltZW91dDogMCxcclxuICAgIC8vIFdoZXRoZXIgZGF0YSBzaG91bGQgYmUgc2VyaWFsaXplZCB0byBzdHJpbmdcclxuICAgIHByb2Nlc3NEYXRhOiB0cnVlLFxyXG4gICAgLy8gV2hldGhlciB0aGUgYnJvd3NlciBzaG91bGQgYmUgYWxsb3dlZCB0byBjYWNoZSBHRVQgcmVzcG9uc2VzXHJcbiAgICBjYWNoZTogdHJ1ZVxyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gbWltZVRvRGF0YVR5cGUobWltZSkge1xyXG4gICAgaWYgKG1pbWUpIG1pbWUgPSBtaW1lLnNwbGl0KCc7JywgMilbMF1cclxuICAgIHJldHVybiBtaW1lICYmICggbWltZSA9PSBodG1sVHlwZSA/ICdodG1sJyA6XHJcbiAgICAgIG1pbWUgPT0ganNvblR5cGUgPyAnanNvbicgOlxyXG4gICAgICBzY3JpcHRUeXBlUkUudGVzdChtaW1lKSA/ICdzY3JpcHQnIDpcclxuICAgICAgeG1sVHlwZVJFLnRlc3QobWltZSkgJiYgJ3htbCcgKSB8fCAndGV4dCdcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGFwcGVuZFF1ZXJ5KHVybCwgcXVlcnkpIHtcclxuICAgIGlmIChxdWVyeSA9PSAnJykgcmV0dXJuIHVybFxyXG4gICAgcmV0dXJuICh1cmwgKyAnJicgKyBxdWVyeSkucmVwbGFjZSgvWyY/XXsxLDJ9LywgJz8nKVxyXG4gIH1cclxuXHJcbiAgLy8gc2VyaWFsaXplIHBheWxvYWQgYW5kIGFwcGVuZCBpdCB0byB0aGUgVVJMIGZvciBHRVQgcmVxdWVzdHNcclxuICBmdW5jdGlvbiBzZXJpYWxpemVEYXRhKG9wdGlvbnMpIHtcclxuICAgIGlmIChvcHRpb25zLnByb2Nlc3NEYXRhICYmIG9wdGlvbnMuZGF0YSAmJiAkLnR5cGUob3B0aW9ucy5kYXRhKSAhPSBcInN0cmluZ1wiKVxyXG4gICAgICBvcHRpb25zLmRhdGEgPSAkLnBhcmFtKG9wdGlvbnMuZGF0YSwgb3B0aW9ucy50cmFkaXRpb25hbClcclxuICAgIGlmIChvcHRpb25zLmRhdGEgJiYgKCFvcHRpb25zLnR5cGUgfHwgb3B0aW9ucy50eXBlLnRvVXBwZXJDYXNlKCkgPT0gJ0dFVCcpKVxyXG4gICAgICBvcHRpb25zLnVybCA9IGFwcGVuZFF1ZXJ5KG9wdGlvbnMudXJsLCBvcHRpb25zLmRhdGEpLCBvcHRpb25zLmRhdGEgPSB1bmRlZmluZWRcclxuICB9XHJcblxyXG4gICQuYWpheCA9IGZ1bmN0aW9uKG9wdGlvbnMpe1xyXG4gICAgdmFyIHNldHRpbmdzID0gJC5leHRlbmQoe30sIG9wdGlvbnMgfHwge30pLFxyXG4gICAgICAgIGRlZmVycmVkID0gJC5EZWZlcnJlZCAmJiAkLkRlZmVycmVkKClcclxuICAgIGZvciAoa2V5IGluICQuYWpheFNldHRpbmdzKSBpZiAoc2V0dGluZ3Nba2V5XSA9PT0gdW5kZWZpbmVkKSBzZXR0aW5nc1trZXldID0gJC5hamF4U2V0dGluZ3Nba2V5XVxyXG5cclxuICAgIGFqYXhTdGFydChzZXR0aW5ncylcclxuXHJcbiAgICBpZiAoIXNldHRpbmdzLmNyb3NzRG9tYWluKSBzZXR0aW5ncy5jcm9zc0RvbWFpbiA9IC9eKFtcXHctXSs6KT9cXC9cXC8oW15cXC9dKykvLnRlc3Qoc2V0dGluZ3MudXJsKSAmJlxyXG4gICAgICBSZWdFeHAuJDIgIT0gd2luZG93LmxvY2F0aW9uLmhvc3RcclxuXHJcbiAgICBpZiAoIXNldHRpbmdzLnVybCkgc2V0dGluZ3MudXJsID0gd2luZG93LmxvY2F0aW9uLnRvU3RyaW5nKClcclxuICAgIHNlcmlhbGl6ZURhdGEoc2V0dGluZ3MpXHJcblxyXG4gICAgdmFyIGRhdGFUeXBlID0gc2V0dGluZ3MuZGF0YVR5cGUsIGhhc1BsYWNlaG9sZGVyID0gL1xcPy4rPVxcPy8udGVzdChzZXR0aW5ncy51cmwpXHJcbiAgICBpZiAoaGFzUGxhY2Vob2xkZXIpIGRhdGFUeXBlID0gJ2pzb25wJ1xyXG5cclxuICAgIGlmIChzZXR0aW5ncy5jYWNoZSA9PT0gZmFsc2UgfHwgKFxyXG4gICAgICAgICAoIW9wdGlvbnMgfHwgb3B0aW9ucy5jYWNoZSAhPT0gdHJ1ZSkgJiZcclxuICAgICAgICAgKCdzY3JpcHQnID09IGRhdGFUeXBlIHx8ICdqc29ucCcgPT0gZGF0YVR5cGUpXHJcbiAgICAgICAgKSlcclxuICAgICAgc2V0dGluZ3MudXJsID0gYXBwZW5kUXVlcnkoc2V0dGluZ3MudXJsLCAnXz0nICsgRGF0ZS5ub3coKSlcclxuXHJcbiAgICBpZiAoJ2pzb25wJyA9PSBkYXRhVHlwZSkge1xyXG4gICAgICBpZiAoIWhhc1BsYWNlaG9sZGVyKVxyXG4gICAgICAgIHNldHRpbmdzLnVybCA9IGFwcGVuZFF1ZXJ5KHNldHRpbmdzLnVybCxcclxuICAgICAgICAgIHNldHRpbmdzLmpzb25wID8gKHNldHRpbmdzLmpzb25wICsgJz0/JykgOiBzZXR0aW5ncy5qc29ucCA9PT0gZmFsc2UgPyAnJyA6ICdjYWxsYmFjaz0/JylcclxuICAgICAgcmV0dXJuICQuYWpheEpTT05QKHNldHRpbmdzLCBkZWZlcnJlZClcclxuICAgIH1cclxuXHJcbiAgICB2YXIgbWltZSA9IHNldHRpbmdzLmFjY2VwdHNbZGF0YVR5cGVdLFxyXG4gICAgICAgIGhlYWRlcnMgPSB7IH0sXHJcbiAgICAgICAgc2V0SGVhZGVyID0gZnVuY3Rpb24obmFtZSwgdmFsdWUpIHsgaGVhZGVyc1tuYW1lLnRvTG93ZXJDYXNlKCldID0gW25hbWUsIHZhbHVlXSB9LFxyXG4gICAgICAgIHByb3RvY29sID0gL14oW1xcdy1dKzopXFwvXFwvLy50ZXN0KHNldHRpbmdzLnVybCkgPyBSZWdFeHAuJDEgOiB3aW5kb3cubG9jYXRpb24ucHJvdG9jb2wsXHJcbiAgICAgICAgeGhyID0gc2V0dGluZ3MueGhyKCksXHJcbiAgICAgICAgbmF0aXZlU2V0SGVhZGVyID0geGhyLnNldFJlcXVlc3RIZWFkZXIsXHJcbiAgICAgICAgYWJvcnRUaW1lb3V0XHJcblxyXG4gICAgaWYgKGRlZmVycmVkKSBkZWZlcnJlZC5wcm9taXNlKHhocilcclxuXHJcbiAgICBpZiAoIXNldHRpbmdzLmNyb3NzRG9tYWluKSBzZXRIZWFkZXIoJ1gtUmVxdWVzdGVkLVdpdGgnLCAnWE1MSHR0cFJlcXVlc3QnKVxyXG4gICAgc2V0SGVhZGVyKCdBY2NlcHQnLCBtaW1lIHx8ICcqLyonKVxyXG4gICAgaWYgKG1pbWUgPSBzZXR0aW5ncy5taW1lVHlwZSB8fCBtaW1lKSB7XHJcbiAgICAgIGlmIChtaW1lLmluZGV4T2YoJywnKSA+IC0xKSBtaW1lID0gbWltZS5zcGxpdCgnLCcsIDIpWzBdXHJcbiAgICAgIHhoci5vdmVycmlkZU1pbWVUeXBlICYmIHhoci5vdmVycmlkZU1pbWVUeXBlKG1pbWUpXHJcbiAgICB9XHJcbiAgICBpZiAoc2V0dGluZ3MuY29udGVudFR5cGUgfHwgKHNldHRpbmdzLmNvbnRlbnRUeXBlICE9PSBmYWxzZSAmJiBzZXR0aW5ncy5kYXRhICYmIHNldHRpbmdzLnR5cGUudG9VcHBlckNhc2UoKSAhPSAnR0VUJykpXHJcbiAgICAgIHNldEhlYWRlcignQ29udGVudC1UeXBlJywgc2V0dGluZ3MuY29udGVudFR5cGUgfHwgJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZCcpXHJcblxyXG4gICAgaWYgKHNldHRpbmdzLmhlYWRlcnMpIGZvciAobmFtZSBpbiBzZXR0aW5ncy5oZWFkZXJzKSBzZXRIZWFkZXIobmFtZSwgc2V0dGluZ3MuaGVhZGVyc1tuYW1lXSlcclxuICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyID0gc2V0SGVhZGVyXHJcblxyXG4gICAgeGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uKCl7XHJcbiAgICAgIGlmICh4aHIucmVhZHlTdGF0ZSA9PSA0KSB7XHJcbiAgICAgICAgeGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGVtcHR5XHJcbiAgICAgICAgY2xlYXJUaW1lb3V0KGFib3J0VGltZW91dClcclxuICAgICAgICB2YXIgcmVzdWx0LCBlcnJvciA9IGZhbHNlXHJcbiAgICAgICAgaWYgKCh4aHIuc3RhdHVzID49IDIwMCAmJiB4aHIuc3RhdHVzIDwgMzAwKSB8fCB4aHIuc3RhdHVzID09IDMwNCB8fCAoeGhyLnN0YXR1cyA9PSAwICYmIHByb3RvY29sID09ICdmaWxlOicpKSB7XHJcbiAgICAgICAgICBkYXRhVHlwZSA9IGRhdGFUeXBlIHx8IG1pbWVUb0RhdGFUeXBlKHNldHRpbmdzLm1pbWVUeXBlIHx8IHhoci5nZXRSZXNwb25zZUhlYWRlcignY29udGVudC10eXBlJykpXHJcbiAgICAgICAgICByZXN1bHQgPSB4aHIucmVzcG9uc2VUZXh0XHJcblxyXG4gICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgLy8gaHR0cDovL3BlcmZlY3Rpb25raWxscy5jb20vZ2xvYmFsLWV2YWwtd2hhdC1hcmUtdGhlLW9wdGlvbnMvXHJcbiAgICAgICAgICAgIGlmIChkYXRhVHlwZSA9PSAnc2NyaXB0JykgICAgKDEsZXZhbCkocmVzdWx0KVxyXG4gICAgICAgICAgICBlbHNlIGlmIChkYXRhVHlwZSA9PSAneG1sJykgIHJlc3VsdCA9IHhoci5yZXNwb25zZVhNTFxyXG4gICAgICAgICAgICBlbHNlIGlmIChkYXRhVHlwZSA9PSAnanNvbicpIHJlc3VsdCA9IGJsYW5rUkUudGVzdChyZXN1bHQpID8gbnVsbCA6ICQucGFyc2VKU09OKHJlc3VsdClcclxuICAgICAgICAgIH0gY2F0Y2ggKGUpIHsgZXJyb3IgPSBlIH1cclxuXHJcbiAgICAgICAgICBpZiAoZXJyb3IpIGFqYXhFcnJvcihlcnJvciwgJ3BhcnNlcmVycm9yJywgeGhyLCBzZXR0aW5ncywgZGVmZXJyZWQpXHJcbiAgICAgICAgICBlbHNlIGFqYXhTdWNjZXNzKHJlc3VsdCwgeGhyLCBzZXR0aW5ncywgZGVmZXJyZWQpXHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIGFqYXhFcnJvcih4aHIuc3RhdHVzVGV4dCB8fCBudWxsLCB4aHIuc3RhdHVzID8gJ2Vycm9yJyA6ICdhYm9ydCcsIHhociwgc2V0dGluZ3MsIGRlZmVycmVkKVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGlmIChhamF4QmVmb3JlU2VuZCh4aHIsIHNldHRpbmdzKSA9PT0gZmFsc2UpIHtcclxuICAgICAgeGhyLmFib3J0KClcclxuICAgICAgYWpheEVycm9yKG51bGwsICdhYm9ydCcsIHhociwgc2V0dGluZ3MsIGRlZmVycmVkKVxyXG4gICAgICByZXR1cm4geGhyXHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHNldHRpbmdzLnhockZpZWxkcykgZm9yIChuYW1lIGluIHNldHRpbmdzLnhockZpZWxkcykgeGhyW25hbWVdID0gc2V0dGluZ3MueGhyRmllbGRzW25hbWVdXHJcblxyXG4gICAgdmFyIGFzeW5jID0gJ2FzeW5jJyBpbiBzZXR0aW5ncyA/IHNldHRpbmdzLmFzeW5jIDogdHJ1ZVxyXG4gICAgeGhyLm9wZW4oc2V0dGluZ3MudHlwZSwgc2V0dGluZ3MudXJsLCBhc3luYywgc2V0dGluZ3MudXNlcm5hbWUsIHNldHRpbmdzLnBhc3N3b3JkKVxyXG5cclxuICAgIGZvciAobmFtZSBpbiBoZWFkZXJzKSBuYXRpdmVTZXRIZWFkZXIuYXBwbHkoeGhyLCBoZWFkZXJzW25hbWVdKVxyXG5cclxuICAgIGlmIChzZXR0aW5ncy50aW1lb3V0ID4gMCkgYWJvcnRUaW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbigpe1xyXG4gICAgICAgIHhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBlbXB0eVxyXG4gICAgICAgIHhoci5hYm9ydCgpXHJcbiAgICAgICAgYWpheEVycm9yKG51bGwsICd0aW1lb3V0JywgeGhyLCBzZXR0aW5ncywgZGVmZXJyZWQpXHJcbiAgICAgIH0sIHNldHRpbmdzLnRpbWVvdXQpXHJcblxyXG4gICAgLy8gYXZvaWQgc2VuZGluZyBlbXB0eSBzdHJpbmcgKCMzMTkpXHJcbiAgICB4aHIuc2VuZChzZXR0aW5ncy5kYXRhID8gc2V0dGluZ3MuZGF0YSA6IG51bGwpXHJcbiAgICByZXR1cm4geGhyXHJcbiAgfVxyXG5cclxuICAvLyBoYW5kbGUgb3B0aW9uYWwgZGF0YS9zdWNjZXNzIGFyZ3VtZW50c1xyXG4gIGZ1bmN0aW9uIHBhcnNlQXJndW1lbnRzKHVybCwgZGF0YSwgc3VjY2VzcywgZGF0YVR5cGUpIHtcclxuICAgIGlmICgkLmlzRnVuY3Rpb24oZGF0YSkpIGRhdGFUeXBlID0gc3VjY2Vzcywgc3VjY2VzcyA9IGRhdGEsIGRhdGEgPSB1bmRlZmluZWRcclxuICAgIGlmICghJC5pc0Z1bmN0aW9uKHN1Y2Nlc3MpKSBkYXRhVHlwZSA9IHN1Y2Nlc3MsIHN1Y2Nlc3MgPSB1bmRlZmluZWRcclxuICAgIHJldHVybiB7XHJcbiAgICAgIHVybDogdXJsXHJcbiAgICAsIGRhdGE6IGRhdGFcclxuICAgICwgc3VjY2Vzczogc3VjY2Vzc1xyXG4gICAgLCBkYXRhVHlwZTogZGF0YVR5cGVcclxuICAgIH1cclxuICB9XHJcblxyXG4gICQuZ2V0ID0gZnVuY3Rpb24oLyogdXJsLCBkYXRhLCBzdWNjZXNzLCBkYXRhVHlwZSAqLyl7XHJcbiAgICByZXR1cm4gJC5hamF4KHBhcnNlQXJndW1lbnRzLmFwcGx5KG51bGwsIGFyZ3VtZW50cykpXHJcbiAgfVxyXG5cclxuICAkLnBvc3QgPSBmdW5jdGlvbigvKiB1cmwsIGRhdGEsIHN1Y2Nlc3MsIGRhdGFUeXBlICovKXtcclxuICAgIHZhciBvcHRpb25zID0gcGFyc2VBcmd1bWVudHMuYXBwbHkobnVsbCwgYXJndW1lbnRzKVxyXG4gICAgb3B0aW9ucy50eXBlID0gJ1BPU1QnXHJcbiAgICByZXR1cm4gJC5hamF4KG9wdGlvbnMpXHJcbiAgfVxyXG5cclxuICAkLmdldEpTT04gPSBmdW5jdGlvbigvKiB1cmwsIGRhdGEsIHN1Y2Nlc3MgKi8pe1xyXG4gICAgdmFyIG9wdGlvbnMgPSBwYXJzZUFyZ3VtZW50cy5hcHBseShudWxsLCBhcmd1bWVudHMpXHJcbiAgICBvcHRpb25zLmRhdGFUeXBlID0gJ2pzb24nXHJcbiAgICByZXR1cm4gJC5hamF4KG9wdGlvbnMpXHJcbiAgfVxyXG5cclxuICAkLmZuLmxvYWQgPSBmdW5jdGlvbih1cmwsIGRhdGEsIHN1Y2Nlc3Mpe1xyXG4gICAgaWYgKCF0aGlzLmxlbmd0aCkgcmV0dXJuIHRoaXNcclxuICAgIHZhciBzZWxmID0gdGhpcywgcGFydHMgPSB1cmwuc3BsaXQoL1xccy8pLCBzZWxlY3RvcixcclxuICAgICAgICBvcHRpb25zID0gcGFyc2VBcmd1bWVudHModXJsLCBkYXRhLCBzdWNjZXNzKSxcclxuICAgICAgICBjYWxsYmFjayA9IG9wdGlvbnMuc3VjY2Vzc1xyXG4gICAgaWYgKHBhcnRzLmxlbmd0aCA+IDEpIG9wdGlvbnMudXJsID0gcGFydHNbMF0sIHNlbGVjdG9yID0gcGFydHNbMV1cclxuICAgIG9wdGlvbnMuc3VjY2VzcyA9IGZ1bmN0aW9uKHJlc3BvbnNlKXtcclxuICAgICAgc2VsZi5odG1sKHNlbGVjdG9yID9cclxuICAgICAgICAkKCc8ZGl2PicpLmh0bWwocmVzcG9uc2UucmVwbGFjZShyc2NyaXB0LCBcIlwiKSkuZmluZChzZWxlY3RvcilcclxuICAgICAgICA6IHJlc3BvbnNlKVxyXG4gICAgICBjYWxsYmFjayAmJiBjYWxsYmFjay5hcHBseShzZWxmLCBhcmd1bWVudHMpXHJcbiAgICB9XHJcbiAgICAkLmFqYXgob3B0aW9ucylcclxuICAgIHJldHVybiB0aGlzXHJcbiAgfVxyXG5cclxuICB2YXIgZXNjYXBlID0gZW5jb2RlVVJJQ29tcG9uZW50XHJcblxyXG4gIGZ1bmN0aW9uIHNlcmlhbGl6ZShwYXJhbXMsIG9iaiwgdHJhZGl0aW9uYWwsIHNjb3BlKXtcclxuICAgIHZhciB0eXBlLCBhcnJheSA9ICQuaXNBcnJheShvYmopLCBoYXNoID0gJC5pc1BsYWluT2JqZWN0KG9iailcclxuICAgICQuZWFjaChvYmosIGZ1bmN0aW9uKGtleSwgdmFsdWUpIHtcclxuICAgICAgdHlwZSA9ICQudHlwZSh2YWx1ZSlcclxuICAgICAgaWYgKHNjb3BlKSBrZXkgPSB0cmFkaXRpb25hbCA/IHNjb3BlIDpcclxuICAgICAgICBzY29wZSArICdbJyArIChoYXNoIHx8IHR5cGUgPT0gJ29iamVjdCcgfHwgdHlwZSA9PSAnYXJyYXknID8ga2V5IDogJycpICsgJ10nXHJcbiAgICAgIC8vIGhhbmRsZSBkYXRhIGluIHNlcmlhbGl6ZUFycmF5KCkgZm9ybWF0XHJcbiAgICAgIGlmICghc2NvcGUgJiYgYXJyYXkpIHBhcmFtcy5hZGQodmFsdWUubmFtZSwgdmFsdWUudmFsdWUpXHJcbiAgICAgIC8vIHJlY3Vyc2UgaW50byBuZXN0ZWQgb2JqZWN0c1xyXG4gICAgICBlbHNlIGlmICh0eXBlID09IFwiYXJyYXlcIiB8fCAoIXRyYWRpdGlvbmFsICYmIHR5cGUgPT0gXCJvYmplY3RcIikpXHJcbiAgICAgICAgc2VyaWFsaXplKHBhcmFtcywgdmFsdWUsIHRyYWRpdGlvbmFsLCBrZXkpXHJcbiAgICAgIGVsc2UgcGFyYW1zLmFkZChrZXksIHZhbHVlKVxyXG4gICAgfSlcclxuICB9XHJcblxyXG4gICQucGFyYW0gPSBmdW5jdGlvbihvYmosIHRyYWRpdGlvbmFsKXtcclxuICAgIHZhciBwYXJhbXMgPSBbXVxyXG4gICAgcGFyYW1zLmFkZCA9IGZ1bmN0aW9uKGssIHYpeyB0aGlzLnB1c2goZXNjYXBlKGspICsgJz0nICsgZXNjYXBlKHYpKSB9XHJcbiAgICBzZXJpYWxpemUocGFyYW1zLCBvYmosIHRyYWRpdGlvbmFsKVxyXG4gICAgcmV0dXJuIHBhcmFtcy5qb2luKCcmJykucmVwbGFjZSgvJTIwL2csICcrJylcclxuICB9XHJcbn0pKFplcHRvKVxyXG5cclxuOyhmdW5jdGlvbigkKXtcclxuICB2YXIgY2FjaGUgPSBbXSwgdGltZW91dFxyXG5cclxuICAkLmZuLnJlbW92ZSA9IGZ1bmN0aW9uKCl7XHJcbiAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCl7XHJcbiAgICAgIGlmKHRoaXMucGFyZW50Tm9kZSl7XHJcbiAgICAgICAgaWYodGhpcy50YWdOYW1lID09PSAnSU1HJyl7XHJcbiAgICAgICAgICBjYWNoZS5wdXNoKHRoaXMpXHJcbiAgICAgICAgICB0aGlzLnNyYyA9ICdkYXRhOmltYWdlL2dpZjtiYXNlNjQsUjBsR09EbGhBUUFCQUFEL0FDd0FBQUFBQVFBQkFBQUNBRHM9J1xyXG4gICAgICAgICAgaWYgKHRpbWVvdXQpIGNsZWFyVGltZW91dCh0aW1lb3V0KVxyXG4gICAgICAgICAgdGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKXsgY2FjaGUgPSBbXSB9LCA2MDAwMClcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMpXHJcbiAgICAgIH1cclxuICAgIH0pXHJcbiAgfVxyXG59KShaZXB0bylcclxuXHJcbjsoZnVuY3Rpb24oJCl7XHJcbiAgLy8gQ3JlYXRlIGEgY29sbGVjdGlvbiBvZiBjYWxsYmFja3MgdG8gYmUgZmlyZWQgaW4gYSBzZXF1ZW5jZSwgd2l0aCBjb25maWd1cmFibGUgYmVoYXZpb3VyXHJcbiAgLy8gT3B0aW9uIGZsYWdzOlxyXG4gIC8vICAgLSBvbmNlOiBDYWxsYmFja3MgZmlyZWQgYXQgbW9zdCBvbmUgdGltZS5cclxuICAvLyAgIC0gbWVtb3J5OiBSZW1lbWJlciB0aGUgbW9zdCByZWNlbnQgY29udGV4dCBhbmQgYXJndW1lbnRzXHJcbiAgLy8gICAtIHN0b3BPbkZhbHNlOiBDZWFzZSBpdGVyYXRpbmcgb3ZlciBjYWxsYmFjayBsaXN0XHJcbiAgLy8gICAtIHVuaXF1ZTogUGVybWl0IGFkZGluZyBhdCBtb3N0IG9uZSBpbnN0YW5jZSBvZiB0aGUgc2FtZSBjYWxsYmFja1xyXG4gICQuQ2FsbGJhY2tzID0gZnVuY3Rpb24ob3B0aW9ucykge1xyXG4gICAgb3B0aW9ucyA9ICQuZXh0ZW5kKHt9LCBvcHRpb25zKVxyXG5cclxuICAgIHZhciBtZW1vcnksIC8vIExhc3QgZmlyZSB2YWx1ZSAoZm9yIG5vbi1mb3JnZXR0YWJsZSBsaXN0cylcclxuICAgICAgICBmaXJlZCwgIC8vIEZsYWcgdG8ga25vdyBpZiBsaXN0IHdhcyBhbHJlYWR5IGZpcmVkXHJcbiAgICAgICAgZmlyaW5nLCAvLyBGbGFnIHRvIGtub3cgaWYgbGlzdCBpcyBjdXJyZW50bHkgZmlyaW5nXHJcbiAgICAgICAgZmlyaW5nU3RhcnQsIC8vIEZpcnN0IGNhbGxiYWNrIHRvIGZpcmUgKHVzZWQgaW50ZXJuYWxseSBieSBhZGQgYW5kIGZpcmVXaXRoKVxyXG4gICAgICAgIGZpcmluZ0xlbmd0aCwgLy8gRW5kIG9mIHRoZSBsb29wIHdoZW4gZmlyaW5nXHJcbiAgICAgICAgZmlyaW5nSW5kZXgsIC8vIEluZGV4IG9mIGN1cnJlbnRseSBmaXJpbmcgY2FsbGJhY2sgKG1vZGlmaWVkIGJ5IHJlbW92ZSBpZiBuZWVkZWQpXHJcbiAgICAgICAgbGlzdCA9IFtdLCAvLyBBY3R1YWwgY2FsbGJhY2sgbGlzdFxyXG4gICAgICAgIHN0YWNrID0gIW9wdGlvbnMub25jZSAmJiBbXSwgLy8gU3RhY2sgb2YgZmlyZSBjYWxscyBmb3IgcmVwZWF0YWJsZSBsaXN0c1xyXG4gICAgICAgIGZpcmUgPSBmdW5jdGlvbihkYXRhKSB7XHJcbiAgICAgICAgICBtZW1vcnkgPSBvcHRpb25zLm1lbW9yeSAmJiBkYXRhXHJcbiAgICAgICAgICBmaXJlZCA9IHRydWVcclxuICAgICAgICAgIGZpcmluZ0luZGV4ID0gZmlyaW5nU3RhcnQgfHwgMFxyXG4gICAgICAgICAgZmlyaW5nU3RhcnQgPSAwXHJcbiAgICAgICAgICBmaXJpbmdMZW5ndGggPSBsaXN0Lmxlbmd0aFxyXG4gICAgICAgICAgZmlyaW5nID0gdHJ1ZVxyXG4gICAgICAgICAgZm9yICggOyBsaXN0ICYmIGZpcmluZ0luZGV4IDwgZmlyaW5nTGVuZ3RoIDsgKytmaXJpbmdJbmRleCApIHtcclxuICAgICAgICAgICAgaWYgKGxpc3RbZmlyaW5nSW5kZXhdLmFwcGx5KGRhdGFbMF0sIGRhdGFbMV0pID09PSBmYWxzZSAmJiBvcHRpb25zLnN0b3BPbkZhbHNlKSB7XHJcbiAgICAgICAgICAgICAgbWVtb3J5ID0gZmFsc2VcclxuICAgICAgICAgICAgICBicmVha1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBmaXJpbmcgPSBmYWxzZVxyXG4gICAgICAgICAgaWYgKGxpc3QpIHtcclxuICAgICAgICAgICAgaWYgKHN0YWNrKSBzdGFjay5sZW5ndGggJiYgZmlyZShzdGFjay5zaGlmdCgpKVxyXG4gICAgICAgICAgICBlbHNlIGlmIChtZW1vcnkpIGxpc3QubGVuZ3RoID0gMFxyXG4gICAgICAgICAgICBlbHNlIENhbGxiYWNrcy5kaXNhYmxlKClcclxuICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBDYWxsYmFja3MgPSB7XHJcbiAgICAgICAgICBhZGQ6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICBpZiAobGlzdCkge1xyXG4gICAgICAgICAgICAgIHZhciBzdGFydCA9IGxpc3QubGVuZ3RoLFxyXG4gICAgICAgICAgICAgICAgICBhZGQgPSBmdW5jdGlvbihhcmdzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgJC5lYWNoKGFyZ3MsIGZ1bmN0aW9uKF8sIGFyZyl7XHJcbiAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGFyZyA9PT0gXCJmdW5jdGlvblwiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghb3B0aW9ucy51bmlxdWUgfHwgIUNhbGxiYWNrcy5oYXMoYXJnKSkgbGlzdC5wdXNoKGFyZylcclxuICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGFyZyAmJiBhcmcubGVuZ3RoICYmIHR5cGVvZiBhcmcgIT09ICdzdHJpbmcnKSBhZGQoYXJnKVxyXG4gICAgICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICBhZGQoYXJndW1lbnRzKVxyXG4gICAgICAgICAgICAgIGlmIChmaXJpbmcpIGZpcmluZ0xlbmd0aCA9IGxpc3QubGVuZ3RoXHJcbiAgICAgICAgICAgICAgZWxzZSBpZiAobWVtb3J5KSB7XHJcbiAgICAgICAgICAgICAgICBmaXJpbmdTdGFydCA9IHN0YXJ0XHJcbiAgICAgICAgICAgICAgICBmaXJlKG1lbW9yeSlcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXNcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICByZW1vdmU6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICBpZiAobGlzdCkge1xyXG4gICAgICAgICAgICAgICQuZWFjaChhcmd1bWVudHMsIGZ1bmN0aW9uKF8sIGFyZyl7XHJcbiAgICAgICAgICAgICAgICB2YXIgaW5kZXhcclxuICAgICAgICAgICAgICAgIHdoaWxlICgoaW5kZXggPSAkLmluQXJyYXkoYXJnLCBsaXN0LCBpbmRleCkpID4gLTEpIHtcclxuICAgICAgICAgICAgICAgICAgbGlzdC5zcGxpY2UoaW5kZXgsIDEpXHJcbiAgICAgICAgICAgICAgICAgIC8vIEhhbmRsZSBmaXJpbmcgaW5kZXhlc1xyXG4gICAgICAgICAgICAgICAgICBpZiAoZmlyaW5nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGluZGV4IDw9IGZpcmluZ0xlbmd0aCkgLS1maXJpbmdMZW5ndGhcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaW5kZXggPD0gZmlyaW5nSW5kZXgpIC0tZmlyaW5nSW5kZXhcclxuICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXNcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICBoYXM6IGZ1bmN0aW9uKGZuKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAhIShsaXN0ICYmIChmbiA/ICQuaW5BcnJheShmbiwgbGlzdCkgPiAtMSA6IGxpc3QubGVuZ3RoKSlcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICBlbXB0eTogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIGZpcmluZ0xlbmd0aCA9IGxpc3QubGVuZ3RoID0gMFxyXG4gICAgICAgICAgICByZXR1cm4gdGhpc1xyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIGRpc2FibGU6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICBsaXN0ID0gc3RhY2sgPSBtZW1vcnkgPSB1bmRlZmluZWRcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXNcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICBkaXNhYmxlZDogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAhbGlzdFxyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIGxvY2s6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICBzdGFjayA9IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgaWYgKCFtZW1vcnkpIENhbGxiYWNrcy5kaXNhYmxlKClcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXNcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICBsb2NrZWQ6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gIXN0YWNrXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgZmlyZVdpdGg6IGZ1bmN0aW9uKGNvbnRleHQsIGFyZ3MpIHtcclxuICAgICAgICAgICAgaWYgKGxpc3QgJiYgKCFmaXJlZCB8fCBzdGFjaykpIHtcclxuICAgICAgICAgICAgICBhcmdzID0gYXJncyB8fCBbXVxyXG4gICAgICAgICAgICAgIGFyZ3MgPSBbY29udGV4dCwgYXJncy5zbGljZSA/IGFyZ3Muc2xpY2UoKSA6IGFyZ3NdXHJcbiAgICAgICAgICAgICAgaWYgKGZpcmluZykgc3RhY2sucHVzaChhcmdzKVxyXG4gICAgICAgICAgICAgIGVsc2UgZmlyZShhcmdzKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgZmlyZTogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBDYWxsYmFja3MuZmlyZVdpdGgodGhpcywgYXJndW1lbnRzKVxyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIGZpcmVkOiBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgcmV0dXJuICEhZmlyZWRcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgcmV0dXJuIENhbGxiYWNrc1xyXG4gIH1cclxufSkoWmVwdG8pXHJcblxyXG47KGZ1bmN0aW9uKCQpe1xyXG4gIHZhciBkYXRhID0ge30sIGRhdGFBdHRyID0gJC5mbi5kYXRhLCBjYW1lbGl6ZSA9ICQuY2FtZWxDYXNlLFxyXG4gICAgZXhwID0gJC5leHBhbmRvID0gJ1plcHRvJyArICgrbmV3IERhdGUoKSksIGVtcHR5QXJyYXkgPSBbXVxyXG5cclxuICAvLyBHZXQgdmFsdWUgZnJvbSBub2RlOlxyXG4gIC8vIDEuIGZpcnN0IHRyeSBrZXkgYXMgZ2l2ZW4sXHJcbiAgLy8gMi4gdGhlbiB0cnkgY2FtZWxpemVkIGtleSxcclxuICAvLyAzLiBmYWxsIGJhY2sgdG8gcmVhZGluZyBcImRhdGEtKlwiIGF0dHJpYnV0ZS5cclxuICBmdW5jdGlvbiBnZXREYXRhKG5vZGUsIG5hbWUpIHtcclxuICAgIHZhciBpZCA9IG5vZGVbZXhwXSwgc3RvcmUgPSBpZCAmJiBkYXRhW2lkXVxyXG4gICAgaWYgKG5hbWUgPT09IHVuZGVmaW5lZCkgcmV0dXJuIHN0b3JlIHx8IHNldERhdGEobm9kZSlcclxuICAgIGVsc2Uge1xyXG4gICAgICBpZiAoc3RvcmUpIHtcclxuICAgICAgICBpZiAobmFtZSBpbiBzdG9yZSkgcmV0dXJuIHN0b3JlW25hbWVdXHJcbiAgICAgICAgdmFyIGNhbWVsTmFtZSA9IGNhbWVsaXplKG5hbWUpXHJcbiAgICAgICAgaWYgKGNhbWVsTmFtZSBpbiBzdG9yZSkgcmV0dXJuIHN0b3JlW2NhbWVsTmFtZV1cclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gZGF0YUF0dHIuY2FsbCgkKG5vZGUpLCBuYW1lKVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLy8gU3RvcmUgdmFsdWUgdW5kZXIgY2FtZWxpemVkIGtleSBvbiBub2RlXHJcbiAgZnVuY3Rpb24gc2V0RGF0YShub2RlLCBuYW1lLCB2YWx1ZSkge1xyXG4gICAgdmFyIGlkID0gbm9kZVtleHBdIHx8IChub2RlW2V4cF0gPSArKyQudXVpZCksXHJcbiAgICAgIHN0b3JlID0gZGF0YVtpZF0gfHwgKGRhdGFbaWRdID0gYXR0cmlidXRlRGF0YShub2RlKSlcclxuICAgIGlmIChuYW1lICE9PSB1bmRlZmluZWQpIHN0b3JlW2NhbWVsaXplKG5hbWUpXSA9IHZhbHVlXHJcbiAgICByZXR1cm4gc3RvcmVcclxuICB9XHJcblxyXG4gIC8vIFJlYWQgYWxsIFwiZGF0YS0qXCIgYXR0cmlidXRlcyBmcm9tIGEgbm9kZVxyXG4gIGZ1bmN0aW9uIGF0dHJpYnV0ZURhdGEobm9kZSkge1xyXG4gICAgdmFyIHN0b3JlID0ge31cclxuICAgICQuZWFjaChub2RlLmF0dHJpYnV0ZXMgfHwgZW1wdHlBcnJheSwgZnVuY3Rpb24oaSwgYXR0cil7XHJcbiAgICAgIGlmIChhdHRyLm5hbWUuaW5kZXhPZignZGF0YS0nKSA9PSAwKVxyXG4gICAgICAgIHN0b3JlW2NhbWVsaXplKGF0dHIubmFtZS5yZXBsYWNlKCdkYXRhLScsICcnKSldID1cclxuICAgICAgICAgICQuemVwdG8uZGVzZXJpYWxpemVWYWx1ZShhdHRyLnZhbHVlKVxyXG4gICAgfSlcclxuICAgIHJldHVybiBzdG9yZVxyXG4gIH1cclxuXHJcbiAgJC5mbi5kYXRhID0gZnVuY3Rpb24obmFtZSwgdmFsdWUpIHtcclxuICAgIHJldHVybiB2YWx1ZSA9PT0gdW5kZWZpbmVkID9cclxuICAgICAgLy8gc2V0IG11bHRpcGxlIHZhbHVlcyB2aWEgb2JqZWN0XHJcbiAgICAgICQuaXNQbGFpbk9iamVjdChuYW1lKSA/XHJcbiAgICAgICAgdGhpcy5lYWNoKGZ1bmN0aW9uKGksIG5vZGUpe1xyXG4gICAgICAgICAgJC5lYWNoKG5hbWUsIGZ1bmN0aW9uKGtleSwgdmFsdWUpeyBzZXREYXRhKG5vZGUsIGtleSwgdmFsdWUpIH0pXHJcbiAgICAgICAgfSkgOlxyXG4gICAgICAgIC8vIGdldCB2YWx1ZSBmcm9tIGZpcnN0IGVsZW1lbnRcclxuICAgICAgICAoMCBpbiB0aGlzID8gZ2V0RGF0YSh0aGlzWzBdLCBuYW1lKSA6IHVuZGVmaW5lZCkgOlxyXG4gICAgICAvLyBzZXQgdmFsdWUgb24gYWxsIGVsZW1lbnRzXHJcbiAgICAgIHRoaXMuZWFjaChmdW5jdGlvbigpeyBzZXREYXRhKHRoaXMsIG5hbWUsIHZhbHVlKSB9KVxyXG4gIH1cclxuXHJcbiAgJC5mbi5yZW1vdmVEYXRhID0gZnVuY3Rpb24obmFtZXMpIHtcclxuICAgIGlmICh0eXBlb2YgbmFtZXMgPT0gJ3N0cmluZycpIG5hbWVzID0gbmFtZXMuc3BsaXQoL1xccysvKVxyXG4gICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbigpe1xyXG4gICAgICB2YXIgaWQgPSB0aGlzW2V4cF0sIHN0b3JlID0gaWQgJiYgZGF0YVtpZF1cclxuICAgICAgaWYgKHN0b3JlKSAkLmVhY2gobmFtZXMgfHwgc3RvcmUsIGZ1bmN0aW9uKGtleSl7XHJcbiAgICAgICAgZGVsZXRlIHN0b3JlW25hbWVzID8gY2FtZWxpemUodGhpcykgOiBrZXldXHJcbiAgICAgIH0pXHJcbiAgICB9KVxyXG4gIH1cclxuXHJcbiAgLy8gR2VuZXJhdGUgZXh0ZW5kZWQgYHJlbW92ZWAgYW5kIGBlbXB0eWAgZnVuY3Rpb25zXHJcbiAgO1sncmVtb3ZlJywgJ2VtcHR5J10uZm9yRWFjaChmdW5jdGlvbihtZXRob2ROYW1lKXtcclxuICAgIHZhciBvcmlnRm4gPSAkLmZuW21ldGhvZE5hbWVdXHJcbiAgICAkLmZuW21ldGhvZE5hbWVdID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgIHZhciBlbGVtZW50cyA9IHRoaXMuZmluZCgnKicpXHJcbiAgICAgIGlmIChtZXRob2ROYW1lID09PSAncmVtb3ZlJykgZWxlbWVudHMgPSBlbGVtZW50cy5hZGQodGhpcylcclxuICAgICAgZWxlbWVudHMucmVtb3ZlRGF0YSgpXHJcbiAgICAgIHJldHVybiBvcmlnRm4uY2FsbCh0aGlzKVxyXG4gICAgfVxyXG4gIH0pXHJcbn0pKFplcHRvKVxyXG5cclxuOyhmdW5jdGlvbigkKXtcclxuICB2YXIgc2xpY2UgPSBBcnJheS5wcm90b3R5cGUuc2xpY2VcclxuXHJcbiAgZnVuY3Rpb24gRGVmZXJyZWQoZnVuYykge1xyXG4gICAgdmFyIHR1cGxlcyA9IFtcclxuICAgICAgICAgIC8vIGFjdGlvbiwgYWRkIGxpc3RlbmVyLCBsaXN0ZW5lciBsaXN0LCBmaW5hbCBzdGF0ZVxyXG4gICAgICAgICAgWyBcInJlc29sdmVcIiwgXCJkb25lXCIsICQuQ2FsbGJhY2tzKHtvbmNlOjEsIG1lbW9yeToxfSksIFwicmVzb2x2ZWRcIiBdLFxyXG4gICAgICAgICAgWyBcInJlamVjdFwiLCBcImZhaWxcIiwgJC5DYWxsYmFja3Moe29uY2U6MSwgbWVtb3J5OjF9KSwgXCJyZWplY3RlZFwiIF0sXHJcbiAgICAgICAgICBbIFwibm90aWZ5XCIsIFwicHJvZ3Jlc3NcIiwgJC5DYWxsYmFja3Moe21lbW9yeToxfSkgXVxyXG4gICAgICAgIF0sXHJcbiAgICAgICAgc3RhdGUgPSBcInBlbmRpbmdcIixcclxuICAgICAgICBwcm9taXNlID0ge1xyXG4gICAgICAgICAgc3RhdGU6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gc3RhdGVcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICBhbHdheXM6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICBkZWZlcnJlZC5kb25lKGFyZ3VtZW50cykuZmFpbChhcmd1bWVudHMpXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgdGhlbjogZnVuY3Rpb24oLyogZm5Eb25lIFssIGZuRmFpbGVkIFssIGZuUHJvZ3Jlc3NdXSAqLykge1xyXG4gICAgICAgICAgICB2YXIgZm5zID0gYXJndW1lbnRzXHJcbiAgICAgICAgICAgIHJldHVybiBEZWZlcnJlZChmdW5jdGlvbihkZWZlcil7XHJcbiAgICAgICAgICAgICAgJC5lYWNoKHR1cGxlcywgZnVuY3Rpb24oaSwgdHVwbGUpe1xyXG4gICAgICAgICAgICAgICAgdmFyIGZuID0gJC5pc0Z1bmN0aW9uKGZuc1tpXSkgJiYgZm5zW2ldXHJcbiAgICAgICAgICAgICAgICBkZWZlcnJlZFt0dXBsZVsxXV0oZnVuY3Rpb24oKXtcclxuICAgICAgICAgICAgICAgICAgdmFyIHJldHVybmVkID0gZm4gJiYgZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKVxyXG4gICAgICAgICAgICAgICAgICBpZiAocmV0dXJuZWQgJiYgJC5pc0Z1bmN0aW9uKHJldHVybmVkLnByb21pc2UpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuZWQucHJvbWlzZSgpXHJcbiAgICAgICAgICAgICAgICAgICAgICAuZG9uZShkZWZlci5yZXNvbHZlKVxyXG4gICAgICAgICAgICAgICAgICAgICAgLmZhaWwoZGVmZXIucmVqZWN0KVxyXG4gICAgICAgICAgICAgICAgICAgICAgLnByb2dyZXNzKGRlZmVyLm5vdGlmeSlcclxuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgY29udGV4dCA9IHRoaXMgPT09IHByb21pc2UgPyBkZWZlci5wcm9taXNlKCkgOiB0aGlzLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZXMgPSBmbiA/IFtyZXR1cm5lZF0gOiBhcmd1bWVudHNcclxuICAgICAgICAgICAgICAgICAgICBkZWZlclt0dXBsZVswXSArIFwiV2l0aFwiXShjb250ZXh0LCB2YWx1ZXMpXHJcbiAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICBmbnMgPSBudWxsXHJcbiAgICAgICAgICAgIH0pLnByb21pc2UoKVxyXG4gICAgICAgICAgfSxcclxuXHJcbiAgICAgICAgICBwcm9taXNlOiBmdW5jdGlvbihvYmopIHtcclxuICAgICAgICAgICAgcmV0dXJuIG9iaiAhPSBudWxsID8gJC5leHRlbmQoIG9iaiwgcHJvbWlzZSApIDogcHJvbWlzZVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZGVmZXJyZWQgPSB7fVxyXG5cclxuICAgICQuZWFjaCh0dXBsZXMsIGZ1bmN0aW9uKGksIHR1cGxlKXtcclxuICAgICAgdmFyIGxpc3QgPSB0dXBsZVsyXSxcclxuICAgICAgICAgIHN0YXRlU3RyaW5nID0gdHVwbGVbM11cclxuXHJcbiAgICAgIHByb21pc2VbdHVwbGVbMV1dID0gbGlzdC5hZGRcclxuXHJcbiAgICAgIGlmIChzdGF0ZVN0cmluZykge1xyXG4gICAgICAgIGxpc3QuYWRkKGZ1bmN0aW9uKCl7XHJcbiAgICAgICAgICBzdGF0ZSA9IHN0YXRlU3RyaW5nXHJcbiAgICAgICAgfSwgdHVwbGVzW2leMV1bMl0uZGlzYWJsZSwgdHVwbGVzWzJdWzJdLmxvY2spXHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGRlZmVycmVkW3R1cGxlWzBdXSA9IGZ1bmN0aW9uKCl7XHJcbiAgICAgICAgZGVmZXJyZWRbdHVwbGVbMF0gKyBcIldpdGhcIl0odGhpcyA9PT0gZGVmZXJyZWQgPyBwcm9taXNlIDogdGhpcywgYXJndW1lbnRzKVxyXG4gICAgICAgIHJldHVybiB0aGlzXHJcbiAgICAgIH1cclxuICAgICAgZGVmZXJyZWRbdHVwbGVbMF0gKyBcIldpdGhcIl0gPSBsaXN0LmZpcmVXaXRoXHJcbiAgICB9KVxyXG5cclxuICAgIHByb21pc2UucHJvbWlzZShkZWZlcnJlZClcclxuICAgIGlmIChmdW5jKSBmdW5jLmNhbGwoZGVmZXJyZWQsIGRlZmVycmVkKVxyXG4gICAgcmV0dXJuIGRlZmVycmVkXHJcbiAgfVxyXG5cclxuICAkLndoZW4gPSBmdW5jdGlvbihzdWIpIHtcclxuICAgIHZhciByZXNvbHZlVmFsdWVzID0gc2xpY2UuY2FsbChhcmd1bWVudHMpLFxyXG4gICAgICAgIGxlbiA9IHJlc29sdmVWYWx1ZXMubGVuZ3RoLFxyXG4gICAgICAgIGkgPSAwLFxyXG4gICAgICAgIHJlbWFpbiA9IGxlbiAhPT0gMSB8fCAoc3ViICYmICQuaXNGdW5jdGlvbihzdWIucHJvbWlzZSkpID8gbGVuIDogMCxcclxuICAgICAgICBkZWZlcnJlZCA9IHJlbWFpbiA9PT0gMSA/IHN1YiA6IERlZmVycmVkKCksXHJcbiAgICAgICAgcHJvZ3Jlc3NWYWx1ZXMsIHByb2dyZXNzQ29udGV4dHMsIHJlc29sdmVDb250ZXh0cyxcclxuICAgICAgICB1cGRhdGVGbiA9IGZ1bmN0aW9uKGksIGN0eCwgdmFsKXtcclxuICAgICAgICAgIHJldHVybiBmdW5jdGlvbih2YWx1ZSl7XHJcbiAgICAgICAgICAgIGN0eFtpXSA9IHRoaXNcclxuICAgICAgICAgICAgdmFsW2ldID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBzbGljZS5jYWxsKGFyZ3VtZW50cykgOiB2YWx1ZVxyXG4gICAgICAgICAgICBpZiAodmFsID09PSBwcm9ncmVzc1ZhbHVlcykge1xyXG4gICAgICAgICAgICAgIGRlZmVycmVkLm5vdGlmeVdpdGgoY3R4LCB2YWwpXHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoISgtLXJlbWFpbikpIHtcclxuICAgICAgICAgICAgICBkZWZlcnJlZC5yZXNvbHZlV2l0aChjdHgsIHZhbClcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICBpZiAobGVuID4gMSkge1xyXG4gICAgICBwcm9ncmVzc1ZhbHVlcyA9IG5ldyBBcnJheShsZW4pXHJcbiAgICAgIHByb2dyZXNzQ29udGV4dHMgPSBuZXcgQXJyYXkobGVuKVxyXG4gICAgICByZXNvbHZlQ29udGV4dHMgPSBuZXcgQXJyYXkobGVuKVxyXG4gICAgICBmb3IgKCA7IGkgPCBsZW47ICsraSApIHtcclxuICAgICAgICBpZiAocmVzb2x2ZVZhbHVlc1tpXSAmJiAkLmlzRnVuY3Rpb24ocmVzb2x2ZVZhbHVlc1tpXS5wcm9taXNlKSkge1xyXG4gICAgICAgICAgcmVzb2x2ZVZhbHVlc1tpXS5wcm9taXNlKClcclxuICAgICAgICAgICAgLmRvbmUodXBkYXRlRm4oaSwgcmVzb2x2ZUNvbnRleHRzLCByZXNvbHZlVmFsdWVzKSlcclxuICAgICAgICAgICAgLmZhaWwoZGVmZXJyZWQucmVqZWN0KVxyXG4gICAgICAgICAgICAucHJvZ3Jlc3ModXBkYXRlRm4oaSwgcHJvZ3Jlc3NDb250ZXh0cywgcHJvZ3Jlc3NWYWx1ZXMpKVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAtLXJlbWFpblxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKCFyZW1haW4pIGRlZmVycmVkLnJlc29sdmVXaXRoKHJlc29sdmVDb250ZXh0cywgcmVzb2x2ZVZhbHVlcylcclxuICAgIHJldHVybiBkZWZlcnJlZC5wcm9taXNlKClcclxuICB9XHJcblxyXG4gICQuRGVmZXJyZWQgPSBEZWZlcnJlZFxyXG59KShaZXB0bylcclxuXHJcbjsoZnVuY3Rpb24oJCl7XHJcbiAgZnVuY3Rpb24gZGV0ZWN0KHVhKXtcclxuICAgIHZhciBvcyA9IHRoaXMub3MgPSB7fSwgYnJvd3NlciA9IHRoaXMuYnJvd3NlciA9IHt9LFxyXG4gICAgICB3ZWJraXQgPSB1YS5tYXRjaCgvV2ViW2tLXWl0W1xcL117MCwxfShbXFxkLl0rKS8pLFxyXG4gICAgICBhbmRyb2lkID0gdWEubWF0Y2goLyhBbmRyb2lkKTs/W1xcc1xcL10rKFtcXGQuXSspPy8pLFxyXG4gICAgICBvc3ggPSAhIXVhLm1hdGNoKC9cXChNYWNpbnRvc2hcXDsgSW50ZWwgLyksXHJcbiAgICAgIGlwYWQgPSB1YS5tYXRjaCgvKGlQYWQpLipPU1xccyhbXFxkX10rKS8pLFxyXG4gICAgICBpcG9kID0gdWEubWF0Y2goLyhpUG9kKSguKk9TXFxzKFtcXGRfXSspKT8vKSxcclxuICAgICAgaXBob25lID0gIWlwYWQgJiYgdWEubWF0Y2goLyhpUGhvbmVcXHNPUylcXHMoW1xcZF9dKykvKSxcclxuICAgICAgd2Vib3MgPSB1YS5tYXRjaCgvKHdlYk9TfGhwd09TKVtcXHNcXC9dKFtcXGQuXSspLyksXHJcbiAgICAgIHdwID0gdWEubWF0Y2goL1dpbmRvd3MgUGhvbmUgKFtcXGQuXSspLyksXHJcbiAgICAgIHRvdWNocGFkID0gd2Vib3MgJiYgdWEubWF0Y2goL1RvdWNoUGFkLyksXHJcbiAgICAgIGtpbmRsZSA9IHVhLm1hdGNoKC9LaW5kbGVcXC8oW1xcZC5dKykvKSxcclxuICAgICAgc2lsayA9IHVhLm1hdGNoKC9TaWxrXFwvKFtcXGQuX10rKS8pLFxyXG4gICAgICBibGFja2JlcnJ5ID0gdWEubWF0Y2goLyhCbGFja0JlcnJ5KS4qVmVyc2lvblxcLyhbXFxkLl0rKS8pLFxyXG4gICAgICBiYjEwID0gdWEubWF0Y2goLyhCQjEwKS4qVmVyc2lvblxcLyhbXFxkLl0rKS8pLFxyXG4gICAgICByaW10YWJsZXRvcyA9IHVhLm1hdGNoKC8oUklNXFxzVGFibGV0XFxzT1MpXFxzKFtcXGQuXSspLyksXHJcbiAgICAgIHBsYXlib29rID0gdWEubWF0Y2goL1BsYXlCb29rLyksXHJcbiAgICAgIGNocm9tZSA9IHVhLm1hdGNoKC9DaHJvbWVcXC8oW1xcZC5dKykvKSB8fCB1YS5tYXRjaCgvQ3JpT1NcXC8oW1xcZC5dKykvKSxcclxuICAgICAgZmlyZWZveCA9IHVhLm1hdGNoKC9GaXJlZm94XFwvKFtcXGQuXSspLyksXHJcbiAgICAgIGllID0gdWEubWF0Y2goL01TSUVcXHMoW1xcZC5dKykvKSB8fCB1YS5tYXRjaCgvVHJpZGVudFxcL1tcXGRdKD89W15cXD9dKykuKnJ2OihbMC05Ll0uKS8pLFxyXG4gICAgICB3ZWJ2aWV3ID0gIWNocm9tZSAmJiB1YS5tYXRjaCgvKGlQaG9uZXxpUG9kfGlQYWQpLipBcHBsZVdlYktpdCg/IS4qU2FmYXJpKS8pLFxyXG4gICAgICBzYWZhcmkgPSB3ZWJ2aWV3IHx8IHVhLm1hdGNoKC9WZXJzaW9uXFwvKFtcXGQuXSspKFteU10oU2FmYXJpKXxbXk1dKihNb2JpbGUpW15TXSooU2FmYXJpKSkvKVxyXG5cclxuICAgIC8vIFRvZG86IGNsZWFuIHRoaXMgdXAgd2l0aCBhIGJldHRlciBPUy9icm93c2VyIHNlcGVyYXRpb246XHJcbiAgICAvLyAtIGRpc2Nlcm4gKG1vcmUpIGJldHdlZW4gbXVsdGlwbGUgYnJvd3NlcnMgb24gYW5kcm9pZFxyXG4gICAgLy8gLSBkZWNpZGUgaWYga2luZGxlIGZpcmUgaW4gc2lsayBtb2RlIGlzIGFuZHJvaWQgb3Igbm90XHJcbiAgICAvLyAtIEZpcmVmb3ggb24gQW5kcm9pZCBkb2Vzbid0IHNwZWNpZnkgdGhlIEFuZHJvaWQgdmVyc2lvblxyXG4gICAgLy8gLSBwb3NzaWJseSBkZXZpZGUgaW4gb3MsIGRldmljZSBhbmQgYnJvd3NlciBoYXNoZXNcclxuXHJcbiAgICBpZiAoYnJvd3Nlci53ZWJraXQgPSAhIXdlYmtpdCkgYnJvd3Nlci52ZXJzaW9uID0gd2Via2l0WzFdXHJcblxyXG4gICAgaWYgKGFuZHJvaWQpIG9zLmFuZHJvaWQgPSB0cnVlLCBvcy52ZXJzaW9uID0gYW5kcm9pZFsyXVxyXG4gICAgaWYgKGlwaG9uZSAmJiAhaXBvZCkgb3MuaW9zID0gb3MuaXBob25lID0gdHJ1ZSwgb3MudmVyc2lvbiA9IGlwaG9uZVsyXS5yZXBsYWNlKC9fL2csICcuJylcclxuICAgIGlmIChpcGFkKSBvcy5pb3MgPSBvcy5pcGFkID0gdHJ1ZSwgb3MudmVyc2lvbiA9IGlwYWRbMl0ucmVwbGFjZSgvXy9nLCAnLicpXHJcbiAgICBpZiAoaXBvZCkgb3MuaW9zID0gb3MuaXBvZCA9IHRydWUsIG9zLnZlcnNpb24gPSBpcG9kWzNdID8gaXBvZFszXS5yZXBsYWNlKC9fL2csICcuJykgOiBudWxsXHJcbiAgICBpZiAod3ApIG9zLndwID0gdHJ1ZSwgb3MudmVyc2lvbiA9IHdwWzFdXHJcbiAgICBpZiAod2Vib3MpIG9zLndlYm9zID0gdHJ1ZSwgb3MudmVyc2lvbiA9IHdlYm9zWzJdXHJcbiAgICBpZiAodG91Y2hwYWQpIG9zLnRvdWNocGFkID0gdHJ1ZVxyXG4gICAgaWYgKGJsYWNrYmVycnkpIG9zLmJsYWNrYmVycnkgPSB0cnVlLCBvcy52ZXJzaW9uID0gYmxhY2tiZXJyeVsyXVxyXG4gICAgaWYgKGJiMTApIG9zLmJiMTAgPSB0cnVlLCBvcy52ZXJzaW9uID0gYmIxMFsyXVxyXG4gICAgaWYgKHJpbXRhYmxldG9zKSBvcy5yaW10YWJsZXRvcyA9IHRydWUsIG9zLnZlcnNpb24gPSByaW10YWJsZXRvc1syXVxyXG4gICAgaWYgKHBsYXlib29rKSBicm93c2VyLnBsYXlib29rID0gdHJ1ZVxyXG4gICAgaWYgKGtpbmRsZSkgb3Mua2luZGxlID0gdHJ1ZSwgb3MudmVyc2lvbiA9IGtpbmRsZVsxXVxyXG4gICAgaWYgKHNpbGspIGJyb3dzZXIuc2lsayA9IHRydWUsIGJyb3dzZXIudmVyc2lvbiA9IHNpbGtbMV1cclxuICAgIGlmICghc2lsayAmJiBvcy5hbmRyb2lkICYmIHVhLm1hdGNoKC9LaW5kbGUgRmlyZS8pKSBicm93c2VyLnNpbGsgPSB0cnVlXHJcbiAgICBpZiAoY2hyb21lKSBicm93c2VyLmNocm9tZSA9IHRydWUsIGJyb3dzZXIudmVyc2lvbiA9IGNocm9tZVsxXVxyXG4gICAgaWYgKGZpcmVmb3gpIGJyb3dzZXIuZmlyZWZveCA9IHRydWUsIGJyb3dzZXIudmVyc2lvbiA9IGZpcmVmb3hbMV1cclxuICAgIGlmIChpZSkgYnJvd3Nlci5pZSA9IHRydWUsIGJyb3dzZXIudmVyc2lvbiA9IGllWzFdXHJcbiAgICBpZiAoc2FmYXJpICYmIChvc3ggfHwgb3MuaW9zKSkge2Jyb3dzZXIuc2FmYXJpID0gdHJ1ZTsgaWYgKG9zeCkgYnJvd3Nlci52ZXJzaW9uID0gc2FmYXJpWzFdfVxyXG4gICAgaWYgKHdlYnZpZXcpIGJyb3dzZXIud2VidmlldyA9IHRydWVcclxuXHJcbiAgICBvcy50YWJsZXQgPSAhIShpcGFkIHx8IHBsYXlib29rIHx8IChhbmRyb2lkICYmICF1YS5tYXRjaCgvTW9iaWxlLykpIHx8XHJcbiAgICAgIChmaXJlZm94ICYmIHVhLm1hdGNoKC9UYWJsZXQvKSkgfHwgKGllICYmICF1YS5tYXRjaCgvUGhvbmUvKSAmJiB1YS5tYXRjaCgvVG91Y2gvKSkpXHJcbiAgICBvcy5waG9uZSAgPSAhISghb3MudGFibGV0ICYmICFvcy5pcG9kICYmIChhbmRyb2lkIHx8IGlwaG9uZSB8fCB3ZWJvcyB8fCBibGFja2JlcnJ5IHx8IGJiMTAgfHxcclxuICAgICAgKGNocm9tZSAmJiB1YS5tYXRjaCgvQW5kcm9pZC8pKSB8fCAoY2hyb21lICYmIHVhLm1hdGNoKC9DcmlPU1xcLyhbXFxkLl0rKS8pKSB8fFxyXG4gICAgICAoZmlyZWZveCAmJiB1YS5tYXRjaCgvTW9iaWxlLykpIHx8IChpZSAmJiB1YS5tYXRjaCgvVG91Y2gvKSkpKVxyXG4gIH1cclxuXHJcbiAgZGV0ZWN0LmNhbGwoJCwgbmF2aWdhdG9yLnVzZXJBZ2VudClcclxuICAvLyBtYWtlIGF2YWlsYWJsZSB0byB1bml0IHRlc3RzXHJcbiAgJC5fX2RldGVjdCA9IGRldGVjdFxyXG5cclxufSkoWmVwdG8pXHJcblxyXG47KGZ1bmN0aW9uKCQpe1xyXG4gIHZhciBfemlkID0gMSwgdW5kZWZpbmVkLFxyXG4gICAgICBzbGljZSA9IEFycmF5LnByb3RvdHlwZS5zbGljZSxcclxuICAgICAgaXNGdW5jdGlvbiA9ICQuaXNGdW5jdGlvbixcclxuICAgICAgaXNTdHJpbmcgPSBmdW5jdGlvbihvYmopeyByZXR1cm4gdHlwZW9mIG9iaiA9PSAnc3RyaW5nJyB9LFxyXG4gICAgICBoYW5kbGVycyA9IHt9LFxyXG4gICAgICBzcGVjaWFsRXZlbnRzPXt9LFxyXG4gICAgICBmb2N1c2luU3VwcG9ydGVkID0gJ29uZm9jdXNpbicgaW4gd2luZG93LFxyXG4gICAgICBmb2N1cyA9IHsgZm9jdXM6ICdmb2N1c2luJywgYmx1cjogJ2ZvY3Vzb3V0JyB9LFxyXG4gICAgICBob3ZlciA9IHsgbW91c2VlbnRlcjogJ21vdXNlb3ZlcicsIG1vdXNlbGVhdmU6ICdtb3VzZW91dCcgfVxyXG5cclxuICBzcGVjaWFsRXZlbnRzLmNsaWNrID0gc3BlY2lhbEV2ZW50cy5tb3VzZWRvd24gPSBzcGVjaWFsRXZlbnRzLm1vdXNldXAgPSBzcGVjaWFsRXZlbnRzLm1vdXNlbW92ZSA9ICdNb3VzZUV2ZW50cydcclxuXHJcbiAgZnVuY3Rpb24gemlkKGVsZW1lbnQpIHtcclxuICAgIHJldHVybiBlbGVtZW50Ll96aWQgfHwgKGVsZW1lbnQuX3ppZCA9IF96aWQrKylcclxuICB9XHJcbiAgZnVuY3Rpb24gZmluZEhhbmRsZXJzKGVsZW1lbnQsIGV2ZW50LCBmbiwgc2VsZWN0b3IpIHtcclxuICAgIGV2ZW50ID0gcGFyc2UoZXZlbnQpXHJcbiAgICBpZiAoZXZlbnQubnMpIHZhciBtYXRjaGVyID0gbWF0Y2hlckZvcihldmVudC5ucylcclxuICAgIHJldHVybiAoaGFuZGxlcnNbemlkKGVsZW1lbnQpXSB8fCBbXSkuZmlsdGVyKGZ1bmN0aW9uKGhhbmRsZXIpIHtcclxuICAgICAgcmV0dXJuIGhhbmRsZXJcclxuICAgICAgICAmJiAoIWV2ZW50LmUgIHx8IGhhbmRsZXIuZSA9PSBldmVudC5lKVxyXG4gICAgICAgICYmICghZXZlbnQubnMgfHwgbWF0Y2hlci50ZXN0KGhhbmRsZXIubnMpKVxyXG4gICAgICAgICYmICghZm4gICAgICAgfHwgemlkKGhhbmRsZXIuZm4pID09PSB6aWQoZm4pKVxyXG4gICAgICAgICYmICghc2VsZWN0b3IgfHwgaGFuZGxlci5zZWwgPT0gc2VsZWN0b3IpXHJcbiAgICB9KVxyXG4gIH1cclxuICBmdW5jdGlvbiBwYXJzZShldmVudCkge1xyXG4gICAgdmFyIHBhcnRzID0gKCcnICsgZXZlbnQpLnNwbGl0KCcuJylcclxuICAgIHJldHVybiB7ZTogcGFydHNbMF0sIG5zOiBwYXJ0cy5zbGljZSgxKS5zb3J0KCkuam9pbignICcpfVxyXG4gIH1cclxuICBmdW5jdGlvbiBtYXRjaGVyRm9yKG5zKSB7XHJcbiAgICByZXR1cm4gbmV3IFJlZ0V4cCgnKD86XnwgKScgKyBucy5yZXBsYWNlKCcgJywgJyAuKiA/JykgKyAnKD86IHwkKScpXHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBldmVudENhcHR1cmUoaGFuZGxlciwgY2FwdHVyZVNldHRpbmcpIHtcclxuICAgIHJldHVybiBoYW5kbGVyLmRlbCAmJlxyXG4gICAgICAoIWZvY3VzaW5TdXBwb3J0ZWQgJiYgKGhhbmRsZXIuZSBpbiBmb2N1cykpIHx8XHJcbiAgICAgICEhY2FwdHVyZVNldHRpbmdcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIHJlYWxFdmVudCh0eXBlKSB7XHJcbiAgICByZXR1cm4gaG92ZXJbdHlwZV0gfHwgKGZvY3VzaW5TdXBwb3J0ZWQgJiYgZm9jdXNbdHlwZV0pIHx8IHR5cGVcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGFkZChlbGVtZW50LCBldmVudHMsIGZuLCBkYXRhLCBzZWxlY3RvciwgZGVsZWdhdG9yLCBjYXB0dXJlKXtcclxuICAgIHZhciBpZCA9IHppZChlbGVtZW50KSwgc2V0ID0gKGhhbmRsZXJzW2lkXSB8fCAoaGFuZGxlcnNbaWRdID0gW10pKVxyXG4gICAgZXZlbnRzLnNwbGl0KC9cXHMvKS5mb3JFYWNoKGZ1bmN0aW9uKGV2ZW50KXtcclxuICAgICAgaWYgKGV2ZW50ID09ICdyZWFkeScpIHJldHVybiAkKGRvY3VtZW50KS5yZWFkeShmbilcclxuICAgICAgdmFyIGhhbmRsZXIgICA9IHBhcnNlKGV2ZW50KVxyXG4gICAgICBoYW5kbGVyLmZuICAgID0gZm5cclxuICAgICAgaGFuZGxlci5zZWwgICA9IHNlbGVjdG9yXHJcbiAgICAgIC8vIGVtdWxhdGUgbW91c2VlbnRlciwgbW91c2VsZWF2ZVxyXG4gICAgICBpZiAoaGFuZGxlci5lIGluIGhvdmVyKSBmbiA9IGZ1bmN0aW9uKGUpe1xyXG4gICAgICAgIHZhciByZWxhdGVkID0gZS5yZWxhdGVkVGFyZ2V0XHJcbiAgICAgICAgaWYgKCFyZWxhdGVkIHx8IChyZWxhdGVkICE9PSB0aGlzICYmICEkLmNvbnRhaW5zKHRoaXMsIHJlbGF0ZWQpKSlcclxuICAgICAgICAgIHJldHVybiBoYW5kbGVyLmZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcclxuICAgICAgfVxyXG4gICAgICBoYW5kbGVyLmRlbCAgID0gZGVsZWdhdG9yXHJcbiAgICAgIHZhciBjYWxsYmFjayAgPSBkZWxlZ2F0b3IgfHwgZm5cclxuICAgICAgaGFuZGxlci5wcm94eSA9IGZ1bmN0aW9uKGUpe1xyXG4gICAgICAgIGUgPSBjb21wYXRpYmxlKGUpXHJcbiAgICAgICAgaWYgKGUuaXNJbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWQoKSkgcmV0dXJuXHJcbiAgICAgICAgZS5kYXRhID0gZGF0YVxyXG4gICAgICAgIHZhciByZXN1bHQgPSBjYWxsYmFjay5hcHBseShlbGVtZW50LCBlLl9hcmdzID09IHVuZGVmaW5lZCA/IFtlXSA6IFtlXS5jb25jYXQoZS5fYXJncykpXHJcbiAgICAgICAgaWYgKHJlc3VsdCA9PT0gZmFsc2UpIGUucHJldmVudERlZmF1bHQoKSwgZS5zdG9wUHJvcGFnYXRpb24oKVxyXG4gICAgICAgIHJldHVybiByZXN1bHRcclxuICAgICAgfVxyXG4gICAgICBoYW5kbGVyLmkgPSBzZXQubGVuZ3RoXHJcbiAgICAgIHNldC5wdXNoKGhhbmRsZXIpXHJcbiAgICAgIGlmICgnYWRkRXZlbnRMaXN0ZW5lcicgaW4gZWxlbWVudClcclxuICAgICAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIocmVhbEV2ZW50KGhhbmRsZXIuZSksIGhhbmRsZXIucHJveHksIGV2ZW50Q2FwdHVyZShoYW5kbGVyLCBjYXB0dXJlKSlcclxuICAgIH0pXHJcbiAgfVxyXG4gIGZ1bmN0aW9uIHJlbW92ZShlbGVtZW50LCBldmVudHMsIGZuLCBzZWxlY3RvciwgY2FwdHVyZSl7XHJcbiAgICB2YXIgaWQgPSB6aWQoZWxlbWVudClcclxuICAgIDsoZXZlbnRzIHx8ICcnKS5zcGxpdCgvXFxzLykuZm9yRWFjaChmdW5jdGlvbihldmVudCl7XHJcbiAgICAgIGZpbmRIYW5kbGVycyhlbGVtZW50LCBldmVudCwgZm4sIHNlbGVjdG9yKS5mb3JFYWNoKGZ1bmN0aW9uKGhhbmRsZXIpe1xyXG4gICAgICAgIGRlbGV0ZSBoYW5kbGVyc1tpZF1baGFuZGxlci5pXVxyXG4gICAgICBpZiAoJ3JlbW92ZUV2ZW50TGlzdGVuZXInIGluIGVsZW1lbnQpXHJcbiAgICAgICAgZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKHJlYWxFdmVudChoYW5kbGVyLmUpLCBoYW5kbGVyLnByb3h5LCBldmVudENhcHR1cmUoaGFuZGxlciwgY2FwdHVyZSkpXHJcbiAgICAgIH0pXHJcbiAgICB9KVxyXG4gIH1cclxuXHJcbiAgJC5ldmVudCA9IHsgYWRkOiBhZGQsIHJlbW92ZTogcmVtb3ZlIH1cclxuXHJcbiAgJC5wcm94eSA9IGZ1bmN0aW9uKGZuLCBjb250ZXh0KSB7XHJcbiAgICB2YXIgYXJncyA9ICgyIGluIGFyZ3VtZW50cykgJiYgc2xpY2UuY2FsbChhcmd1bWVudHMsIDIpXHJcbiAgICBpZiAoaXNGdW5jdGlvbihmbikpIHtcclxuICAgICAgdmFyIHByb3h5Rm4gPSBmdW5jdGlvbigpeyByZXR1cm4gZm4uYXBwbHkoY29udGV4dCwgYXJncyA/IGFyZ3MuY29uY2F0KHNsaWNlLmNhbGwoYXJndW1lbnRzKSkgOiBhcmd1bWVudHMpIH1cclxuICAgICAgcHJveHlGbi5femlkID0gemlkKGZuKVxyXG4gICAgICByZXR1cm4gcHJveHlGblxyXG4gICAgfSBlbHNlIGlmIChpc1N0cmluZyhjb250ZXh0KSkge1xyXG4gICAgICBpZiAoYXJncykge1xyXG4gICAgICAgIGFyZ3MudW5zaGlmdChmbltjb250ZXh0XSwgZm4pXHJcbiAgICAgICAgcmV0dXJuICQucHJveHkuYXBwbHkobnVsbCwgYXJncylcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICByZXR1cm4gJC5wcm94eShmbltjb250ZXh0XSwgZm4pXHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJleHBlY3RlZCBmdW5jdGlvblwiKVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgJC5mbi5iaW5kID0gZnVuY3Rpb24oZXZlbnQsIGRhdGEsIGNhbGxiYWNrKXtcclxuICAgIHJldHVybiB0aGlzLm9uKGV2ZW50LCBkYXRhLCBjYWxsYmFjaylcclxuICB9XHJcbiAgJC5mbi51bmJpbmQgPSBmdW5jdGlvbihldmVudCwgY2FsbGJhY2spe1xyXG4gICAgcmV0dXJuIHRoaXMub2ZmKGV2ZW50LCBjYWxsYmFjaylcclxuICB9XHJcbiAgJC5mbi5vbmUgPSBmdW5jdGlvbihldmVudCwgc2VsZWN0b3IsIGRhdGEsIGNhbGxiYWNrKXtcclxuICAgIHJldHVybiB0aGlzLm9uKGV2ZW50LCBzZWxlY3RvciwgZGF0YSwgY2FsbGJhY2ssIDEpXHJcbiAgfVxyXG5cclxuICB2YXIgcmV0dXJuVHJ1ZSA9IGZ1bmN0aW9uKCl7cmV0dXJuIHRydWV9LFxyXG4gICAgICByZXR1cm5GYWxzZSA9IGZ1bmN0aW9uKCl7cmV0dXJuIGZhbHNlfSxcclxuICAgICAgaWdub3JlUHJvcGVydGllcyA9IC9eKFtBLVpdfHJldHVyblZhbHVlJHxsYXllcltYWV0kKS8sXHJcbiAgICAgIGV2ZW50TWV0aG9kcyA9IHtcclxuICAgICAgICBwcmV2ZW50RGVmYXVsdDogJ2lzRGVmYXVsdFByZXZlbnRlZCcsXHJcbiAgICAgICAgc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uOiAnaXNJbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWQnLFxyXG4gICAgICAgIHN0b3BQcm9wYWdhdGlvbjogJ2lzUHJvcGFnYXRpb25TdG9wcGVkJ1xyXG4gICAgICB9XHJcblxyXG4gIGZ1bmN0aW9uIGNvbXBhdGlibGUoZXZlbnQsIHNvdXJjZSkge1xyXG4gICAgaWYgKHNvdXJjZSB8fCAhZXZlbnQuaXNEZWZhdWx0UHJldmVudGVkKSB7XHJcbiAgICAgIHNvdXJjZSB8fCAoc291cmNlID0gZXZlbnQpXHJcblxyXG4gICAgICAkLmVhY2goZXZlbnRNZXRob2RzLCBmdW5jdGlvbihuYW1lLCBwcmVkaWNhdGUpIHtcclxuICAgICAgICB2YXIgc291cmNlTWV0aG9kID0gc291cmNlW25hbWVdXHJcbiAgICAgICAgZXZlbnRbbmFtZV0gPSBmdW5jdGlvbigpe1xyXG4gICAgICAgICAgdGhpc1twcmVkaWNhdGVdID0gcmV0dXJuVHJ1ZVxyXG4gICAgICAgICAgcmV0dXJuIHNvdXJjZU1ldGhvZCAmJiBzb3VyY2VNZXRob2QuYXBwbHkoc291cmNlLCBhcmd1bWVudHMpXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGV2ZW50W3ByZWRpY2F0ZV0gPSByZXR1cm5GYWxzZVxyXG4gICAgICB9KVxyXG5cclxuICAgICAgaWYgKHNvdXJjZS5kZWZhdWx0UHJldmVudGVkICE9PSB1bmRlZmluZWQgPyBzb3VyY2UuZGVmYXVsdFByZXZlbnRlZCA6XHJcbiAgICAgICAgICAncmV0dXJuVmFsdWUnIGluIHNvdXJjZSA/IHNvdXJjZS5yZXR1cm5WYWx1ZSA9PT0gZmFsc2UgOlxyXG4gICAgICAgICAgc291cmNlLmdldFByZXZlbnREZWZhdWx0ICYmIHNvdXJjZS5nZXRQcmV2ZW50RGVmYXVsdCgpKVxyXG4gICAgICAgIGV2ZW50LmlzRGVmYXVsdFByZXZlbnRlZCA9IHJldHVyblRydWVcclxuICAgIH1cclxuICAgIHJldHVybiBldmVudFxyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gY3JlYXRlUHJveHkoZXZlbnQpIHtcclxuICAgIHZhciBrZXksIHByb3h5ID0geyBvcmlnaW5hbEV2ZW50OiBldmVudCB9XHJcbiAgICBmb3IgKGtleSBpbiBldmVudClcclxuICAgICAgaWYgKCFpZ25vcmVQcm9wZXJ0aWVzLnRlc3Qoa2V5KSAmJiBldmVudFtrZXldICE9PSB1bmRlZmluZWQpIHByb3h5W2tleV0gPSBldmVudFtrZXldXHJcblxyXG4gICAgcmV0dXJuIGNvbXBhdGlibGUocHJveHksIGV2ZW50KVxyXG4gIH1cclxuXHJcbiAgJC5mbi5kZWxlZ2F0ZSA9IGZ1bmN0aW9uKHNlbGVjdG9yLCBldmVudCwgY2FsbGJhY2spe1xyXG4gICAgcmV0dXJuIHRoaXMub24oZXZlbnQsIHNlbGVjdG9yLCBjYWxsYmFjaylcclxuICB9XHJcbiAgJC5mbi51bmRlbGVnYXRlID0gZnVuY3Rpb24oc2VsZWN0b3IsIGV2ZW50LCBjYWxsYmFjayl7XHJcbiAgICByZXR1cm4gdGhpcy5vZmYoZXZlbnQsIHNlbGVjdG9yLCBjYWxsYmFjaylcclxuICB9XHJcblxyXG4gICQuZm4ubGl2ZSA9IGZ1bmN0aW9uKGV2ZW50LCBjYWxsYmFjayl7XHJcbiAgICAkKGRvY3VtZW50LmJvZHkpLmRlbGVnYXRlKHRoaXMuc2VsZWN0b3IsIGV2ZW50LCBjYWxsYmFjaylcclxuICAgIHJldHVybiB0aGlzXHJcbiAgfVxyXG4gICQuZm4uZGllID0gZnVuY3Rpb24oZXZlbnQsIGNhbGxiYWNrKXtcclxuICAgICQoZG9jdW1lbnQuYm9keSkudW5kZWxlZ2F0ZSh0aGlzLnNlbGVjdG9yLCBldmVudCwgY2FsbGJhY2spXHJcbiAgICByZXR1cm4gdGhpc1xyXG4gIH1cclxuXHJcbiAgJC5mbi5vbiA9IGZ1bmN0aW9uKGV2ZW50LCBzZWxlY3RvciwgZGF0YSwgY2FsbGJhY2ssIG9uZSl7XHJcbiAgICB2YXIgYXV0b1JlbW92ZSwgZGVsZWdhdG9yLCAkdGhpcyA9IHRoaXNcclxuICAgIGlmIChldmVudCAmJiAhaXNTdHJpbmcoZXZlbnQpKSB7XHJcbiAgICAgICQuZWFjaChldmVudCwgZnVuY3Rpb24odHlwZSwgZm4pe1xyXG4gICAgICAgICR0aGlzLm9uKHR5cGUsIHNlbGVjdG9yLCBkYXRhLCBmbiwgb25lKVxyXG4gICAgICB9KVxyXG4gICAgICByZXR1cm4gJHRoaXNcclxuICAgIH1cclxuXHJcbiAgICBpZiAoIWlzU3RyaW5nKHNlbGVjdG9yKSAmJiAhaXNGdW5jdGlvbihjYWxsYmFjaykgJiYgY2FsbGJhY2sgIT09IGZhbHNlKVxyXG4gICAgICBjYWxsYmFjayA9IGRhdGEsIGRhdGEgPSBzZWxlY3Rvciwgc2VsZWN0b3IgPSB1bmRlZmluZWRcclxuICAgIGlmIChpc0Z1bmN0aW9uKGRhdGEpIHx8IGRhdGEgPT09IGZhbHNlKVxyXG4gICAgICBjYWxsYmFjayA9IGRhdGEsIGRhdGEgPSB1bmRlZmluZWRcclxuXHJcbiAgICBpZiAoY2FsbGJhY2sgPT09IGZhbHNlKSBjYWxsYmFjayA9IHJldHVybkZhbHNlXHJcblxyXG4gICAgcmV0dXJuICR0aGlzLmVhY2goZnVuY3Rpb24oXywgZWxlbWVudCl7XHJcbiAgICAgIGlmIChvbmUpIGF1dG9SZW1vdmUgPSBmdW5jdGlvbihlKXtcclxuICAgICAgICByZW1vdmUoZWxlbWVudCwgZS50eXBlLCBjYWxsYmFjaylcclxuICAgICAgICByZXR1cm4gY2FsbGJhY2suYXBwbHkodGhpcywgYXJndW1lbnRzKVxyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoc2VsZWN0b3IpIGRlbGVnYXRvciA9IGZ1bmN0aW9uKGUpe1xyXG4gICAgICAgIHZhciBldnQsIG1hdGNoID0gJChlLnRhcmdldCkuY2xvc2VzdChzZWxlY3RvciwgZWxlbWVudCkuZ2V0KDApXHJcbiAgICAgICAgaWYgKG1hdGNoICYmIG1hdGNoICE9PSBlbGVtZW50KSB7XHJcbiAgICAgICAgICBldnQgPSAkLmV4dGVuZChjcmVhdGVQcm94eShlKSwge2N1cnJlbnRUYXJnZXQ6IG1hdGNoLCBsaXZlRmlyZWQ6IGVsZW1lbnR9KVxyXG4gICAgICAgICAgcmV0dXJuIChhdXRvUmVtb3ZlIHx8IGNhbGxiYWNrKS5hcHBseShtYXRjaCwgW2V2dF0uY29uY2F0KHNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKSkpXHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICBhZGQoZWxlbWVudCwgZXZlbnQsIGNhbGxiYWNrLCBkYXRhLCBzZWxlY3RvciwgZGVsZWdhdG9yIHx8IGF1dG9SZW1vdmUpXHJcbiAgICB9KVxyXG4gIH1cclxuICAkLmZuLm9mZiA9IGZ1bmN0aW9uKGV2ZW50LCBzZWxlY3RvciwgY2FsbGJhY2spe1xyXG4gICAgdmFyICR0aGlzID0gdGhpc1xyXG4gICAgaWYgKGV2ZW50ICYmICFpc1N0cmluZyhldmVudCkpIHtcclxuICAgICAgJC5lYWNoKGV2ZW50LCBmdW5jdGlvbih0eXBlLCBmbil7XHJcbiAgICAgICAgJHRoaXMub2ZmKHR5cGUsIHNlbGVjdG9yLCBmbilcclxuICAgICAgfSlcclxuICAgICAgcmV0dXJuICR0aGlzXHJcbiAgICB9XHJcblxyXG4gICAgaWYgKCFpc1N0cmluZyhzZWxlY3RvcikgJiYgIWlzRnVuY3Rpb24oY2FsbGJhY2spICYmIGNhbGxiYWNrICE9PSBmYWxzZSlcclxuICAgICAgY2FsbGJhY2sgPSBzZWxlY3Rvciwgc2VsZWN0b3IgPSB1bmRlZmluZWRcclxuXHJcbiAgICBpZiAoY2FsbGJhY2sgPT09IGZhbHNlKSBjYWxsYmFjayA9IHJldHVybkZhbHNlXHJcblxyXG4gICAgcmV0dXJuICR0aGlzLmVhY2goZnVuY3Rpb24oKXtcclxuICAgICAgcmVtb3ZlKHRoaXMsIGV2ZW50LCBjYWxsYmFjaywgc2VsZWN0b3IpXHJcbiAgICB9KVxyXG4gIH1cclxuXHJcbiAgJC5mbi50cmlnZ2VyID0gZnVuY3Rpb24oZXZlbnQsIGFyZ3Mpe1xyXG4gICAgZXZlbnQgPSAoaXNTdHJpbmcoZXZlbnQpIHx8ICQuaXNQbGFpbk9iamVjdChldmVudCkpID8gJC5FdmVudChldmVudCkgOiBjb21wYXRpYmxlKGV2ZW50KVxyXG4gICAgZXZlbnQuX2FyZ3MgPSBhcmdzXHJcbiAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCl7XHJcbiAgICAgIC8vIGl0ZW1zIGluIHRoZSBjb2xsZWN0aW9uIG1pZ2h0IG5vdCBiZSBET00gZWxlbWVudHNcclxuICAgICAgaWYoJ2Rpc3BhdGNoRXZlbnQnIGluIHRoaXMpIHRoaXMuZGlzcGF0Y2hFdmVudChldmVudClcclxuICAgICAgZWxzZSAkKHRoaXMpLnRyaWdnZXJIYW5kbGVyKGV2ZW50LCBhcmdzKVxyXG4gICAgfSlcclxuICB9XHJcblxyXG4gIC8vIHRyaWdnZXJzIGV2ZW50IGhhbmRsZXJzIG9uIGN1cnJlbnQgZWxlbWVudCBqdXN0IGFzIGlmIGFuIGV2ZW50IG9jY3VycmVkLFxyXG4gIC8vIGRvZXNuJ3QgdHJpZ2dlciBhbiBhY3R1YWwgZXZlbnQsIGRvZXNuJ3QgYnViYmxlXHJcbiAgJC5mbi50cmlnZ2VySGFuZGxlciA9IGZ1bmN0aW9uKGV2ZW50LCBhcmdzKXtcclxuICAgIHZhciBlLCByZXN1bHRcclxuICAgIHRoaXMuZWFjaChmdW5jdGlvbihpLCBlbGVtZW50KXtcclxuICAgICAgZSA9IGNyZWF0ZVByb3h5KGlzU3RyaW5nKGV2ZW50KSA/ICQuRXZlbnQoZXZlbnQpIDogZXZlbnQpXHJcbiAgICAgIGUuX2FyZ3MgPSBhcmdzXHJcbiAgICAgIGUudGFyZ2V0ID0gZWxlbWVudFxyXG4gICAgICAkLmVhY2goZmluZEhhbmRsZXJzKGVsZW1lbnQsIGV2ZW50LnR5cGUgfHwgZXZlbnQpLCBmdW5jdGlvbihpLCBoYW5kbGVyKXtcclxuICAgICAgICByZXN1bHQgPSBoYW5kbGVyLnByb3h5KGUpXHJcbiAgICAgICAgaWYgKGUuaXNJbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWQoKSkgcmV0dXJuIGZhbHNlXHJcbiAgICAgIH0pXHJcbiAgICB9KVxyXG4gICAgcmV0dXJuIHJlc3VsdFxyXG4gIH1cclxuXHJcbiAgLy8gc2hvcnRjdXQgbWV0aG9kcyBmb3IgYC5iaW5kKGV2ZW50LCBmbilgIGZvciBlYWNoIGV2ZW50IHR5cGVcclxuICA7KCdmb2N1c2luIGZvY3Vzb3V0IGxvYWQgcmVzaXplIHNjcm9sbCB1bmxvYWQgY2xpY2sgZGJsY2xpY2sgJytcclxuICAnbW91c2Vkb3duIG1vdXNldXAgbW91c2Vtb3ZlIG1vdXNlb3ZlciBtb3VzZW91dCBtb3VzZWVudGVyIG1vdXNlbGVhdmUgJytcclxuICAnY2hhbmdlIHNlbGVjdCBrZXlkb3duIGtleXByZXNzIGtleXVwIGVycm9yJykuc3BsaXQoJyAnKS5mb3JFYWNoKGZ1bmN0aW9uKGV2ZW50KSB7XHJcbiAgICAkLmZuW2V2ZW50XSA9IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XHJcbiAgICAgIHJldHVybiBjYWxsYmFjayA/XHJcbiAgICAgICAgdGhpcy5iaW5kKGV2ZW50LCBjYWxsYmFjaykgOlxyXG4gICAgICAgIHRoaXMudHJpZ2dlcihldmVudClcclxuICAgIH1cclxuICB9KVxyXG5cclxuICA7Wydmb2N1cycsICdibHVyJ10uZm9yRWFjaChmdW5jdGlvbihuYW1lKSB7XHJcbiAgICAkLmZuW25hbWVdID0gZnVuY3Rpb24oY2FsbGJhY2spIHtcclxuICAgICAgaWYgKGNhbGxiYWNrKSB0aGlzLmJpbmQobmFtZSwgY2FsbGJhY2spXHJcbiAgICAgIGVsc2UgdGhpcy5lYWNoKGZ1bmN0aW9uKCl7XHJcbiAgICAgICAgdHJ5IHsgdGhpc1tuYW1lXSgpIH1cclxuICAgICAgICBjYXRjaChlKSB7fVxyXG4gICAgICB9KVxyXG4gICAgICByZXR1cm4gdGhpc1xyXG4gICAgfVxyXG4gIH0pXHJcblxyXG4gICQuRXZlbnQgPSBmdW5jdGlvbih0eXBlLCBwcm9wcykge1xyXG4gICAgaWYgKCFpc1N0cmluZyh0eXBlKSkgcHJvcHMgPSB0eXBlLCB0eXBlID0gcHJvcHMudHlwZVxyXG4gICAgdmFyIGV2ZW50ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoc3BlY2lhbEV2ZW50c1t0eXBlXSB8fCAnRXZlbnRzJyksIGJ1YmJsZXMgPSB0cnVlXHJcbiAgICBpZiAocHJvcHMpIGZvciAodmFyIG5hbWUgaW4gcHJvcHMpIChuYW1lID09ICdidWJibGVzJykgPyAoYnViYmxlcyA9ICEhcHJvcHNbbmFtZV0pIDogKGV2ZW50W25hbWVdID0gcHJvcHNbbmFtZV0pXHJcbiAgICBldmVudC5pbml0RXZlbnQodHlwZSwgYnViYmxlcywgdHJ1ZSlcclxuICAgIHJldHVybiBjb21wYXRpYmxlKGV2ZW50KVxyXG4gIH1cclxuXHJcbn0pKFplcHRvKVxyXG5cclxuOyhmdW5jdGlvbigkKXtcclxuICAkLmZuLnNlcmlhbGl6ZUFycmF5ID0gZnVuY3Rpb24oKSB7XHJcbiAgICB2YXIgZWwsIHR5cGUsIHJlc3VsdCA9IFtdXHJcbiAgICAkKFtdLnNsaWNlLmNhbGwodGhpcy5nZXQoMCkuZWxlbWVudHMpKS5lYWNoKGZ1bmN0aW9uKCl7XHJcbiAgICAgIGVsID0gJCh0aGlzKVxyXG4gICAgICB0eXBlID0gZWwuYXR0cigndHlwZScpXHJcbiAgICAgIGlmICh0aGlzLm5hbWUgJiYgdGhpcy5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpICE9ICdmaWVsZHNldCcgJiZcclxuICAgICAgICAhdGhpcy5kaXNhYmxlZCAmJiB0eXBlICE9ICdzdWJtaXQnICYmIHR5cGUgIT0gJ3Jlc2V0JyAmJiB0eXBlICE9ICdidXR0b24nICYmXHJcbiAgICAgICAgKCh0eXBlICE9ICdyYWRpbycgJiYgdHlwZSAhPSAnY2hlY2tib3gnKSB8fCB0aGlzLmNoZWNrZWQpKVxyXG4gICAgICAgIHJlc3VsdC5wdXNoKHtcclxuICAgICAgICAgIG5hbWU6IGVsLmF0dHIoJ25hbWUnKSxcclxuICAgICAgICAgIHZhbHVlOiBlbC52YWwoKVxyXG4gICAgICAgIH0pXHJcbiAgICB9KVxyXG4gICAgcmV0dXJuIHJlc3VsdFxyXG4gIH1cclxuXHJcbiAgJC5mbi5zZXJpYWxpemUgPSBmdW5jdGlvbigpe1xyXG4gICAgdmFyIHJlc3VsdCA9IFtdXHJcbiAgICB0aGlzLnNlcmlhbGl6ZUFycmF5KCkuZm9yRWFjaChmdW5jdGlvbihlbG0pe1xyXG4gICAgICByZXN1bHQucHVzaChlbmNvZGVVUklDb21wb25lbnQoZWxtLm5hbWUpICsgJz0nICsgZW5jb2RlVVJJQ29tcG9uZW50KGVsbS52YWx1ZSkpXHJcbiAgICB9KVxyXG4gICAgcmV0dXJuIHJlc3VsdC5qb2luKCcmJylcclxuICB9XHJcblxyXG4gICQuZm4uc3VibWl0ID0gZnVuY3Rpb24oY2FsbGJhY2spIHtcclxuICAgIGlmIChjYWxsYmFjaykgdGhpcy5iaW5kKCdzdWJtaXQnLCBjYWxsYmFjaylcclxuICAgIGVsc2UgaWYgKHRoaXMubGVuZ3RoKSB7XHJcbiAgICAgIHZhciBldmVudCA9ICQuRXZlbnQoJ3N1Ym1pdCcpXHJcbiAgICAgIHRoaXMuZXEoMCkudHJpZ2dlcihldmVudClcclxuICAgICAgaWYgKCFldmVudC5pc0RlZmF1bHRQcmV2ZW50ZWQoKSkgdGhpcy5nZXQoMCkuc3VibWl0KClcclxuICAgIH1cclxuICAgIHJldHVybiB0aGlzXHJcbiAgfVxyXG5cclxufSkoWmVwdG8pXHJcblxyXG47KGZ1bmN0aW9uKCQsIHVuZGVmaW5lZCl7XHJcbiAgdmFyIGRvY3VtZW50ID0gd2luZG93LmRvY3VtZW50LCBkb2NFbGVtID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LFxyXG4gICAgb3JpZ1Nob3cgPSAkLmZuLnNob3csIG9yaWdIaWRlID0gJC5mbi5oaWRlLCBvcmlnVG9nZ2xlID0gJC5mbi50b2dnbGVcclxuXHJcbiAgZnVuY3Rpb24gYW5pbShlbCwgc3BlZWQsIG9wYWNpdHksIHNjYWxlLCBjYWxsYmFjaykge1xyXG4gICAgaWYgKHR5cGVvZiBzcGVlZCA9PSAnZnVuY3Rpb24nICYmICFjYWxsYmFjaykgY2FsbGJhY2sgPSBzcGVlZCwgc3BlZWQgPSB1bmRlZmluZWRcclxuICAgIHZhciBwcm9wcyA9IHsgb3BhY2l0eTogb3BhY2l0eSB9XHJcbiAgICBpZiAoc2NhbGUpIHtcclxuICAgICAgcHJvcHMuc2NhbGUgPSBzY2FsZVxyXG4gICAgICBlbC5jc3MoJC5meC5jc3NQcmVmaXggKyAndHJhbnNmb3JtLW9yaWdpbicsICcwIDAnKVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGVsLmFuaW1hdGUocHJvcHMsIHNwZWVkLCBudWxsLCBjYWxsYmFjaylcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGhpZGUoZWwsIHNwZWVkLCBzY2FsZSwgY2FsbGJhY2spIHtcclxuICAgIHJldHVybiBhbmltKGVsLCBzcGVlZCwgMCwgc2NhbGUsIGZ1bmN0aW9uKCl7XHJcbiAgICAgIG9yaWdIaWRlLmNhbGwoJCh0aGlzKSlcclxuICAgICAgY2FsbGJhY2sgJiYgY2FsbGJhY2suY2FsbCh0aGlzKVxyXG4gICAgfSlcclxuICB9XHJcblxyXG4gICQuZm4uc2hvdyA9IGZ1bmN0aW9uKHNwZWVkLCBjYWxsYmFjaykge1xyXG4gICAgb3JpZ1Nob3cuY2FsbCh0aGlzKVxyXG4gICAgaWYgKHNwZWVkID09PSB1bmRlZmluZWQpIHNwZWVkID0gMFxyXG4gICAgZWxzZSB0aGlzLmNzcygnb3BhY2l0eScsIDApXHJcbiAgICByZXR1cm4gYW5pbSh0aGlzLCBzcGVlZCwgMSwgJzEsMScsIGNhbGxiYWNrKVxyXG4gIH1cclxuXHJcbiAgJC5mbi5oaWRlID0gZnVuY3Rpb24oc3BlZWQsIGNhbGxiYWNrKSB7XHJcbiAgICBpZiAoc3BlZWQgPT09IHVuZGVmaW5lZCkgcmV0dXJuIG9yaWdIaWRlLmNhbGwodGhpcylcclxuICAgIGVsc2UgcmV0dXJuIGhpZGUodGhpcywgc3BlZWQsICcwLDAnLCBjYWxsYmFjaylcclxuICB9XHJcblxyXG4gICQuZm4udG9nZ2xlID0gZnVuY3Rpb24oc3BlZWQsIGNhbGxiYWNrKSB7XHJcbiAgICBpZiAoc3BlZWQgPT09IHVuZGVmaW5lZCB8fCB0eXBlb2Ygc3BlZWQgPT0gJ2Jvb2xlYW4nKVxyXG4gICAgICByZXR1cm4gb3JpZ1RvZ2dsZS5jYWxsKHRoaXMsIHNwZWVkKVxyXG4gICAgZWxzZSByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uKCl7XHJcbiAgICAgIHZhciBlbCA9ICQodGhpcylcclxuICAgICAgZWxbZWwuY3NzKCdkaXNwbGF5JykgPT0gJ25vbmUnID8gJ3Nob3cnIDogJ2hpZGUnXShzcGVlZCwgY2FsbGJhY2spXHJcbiAgICB9KVxyXG4gIH1cclxuXHJcbiAgJC5mbi5mYWRlVG8gPSBmdW5jdGlvbihzcGVlZCwgb3BhY2l0eSwgY2FsbGJhY2spIHtcclxuICAgIHJldHVybiBhbmltKHRoaXMsIHNwZWVkLCBvcGFjaXR5LCBudWxsLCBjYWxsYmFjaylcclxuICB9XHJcblxyXG4gICQuZm4uZmFkZUluID0gZnVuY3Rpb24oc3BlZWQsIGNhbGxiYWNrKSB7XHJcbiAgICB2YXIgdGFyZ2V0ID0gdGhpcy5jc3MoJ29wYWNpdHknKVxyXG4gICAgaWYgKHRhcmdldCA+IDApIHRoaXMuY3NzKCdvcGFjaXR5JywgMClcclxuICAgIGVsc2UgdGFyZ2V0ID0gMVxyXG4gICAgcmV0dXJuIG9yaWdTaG93LmNhbGwodGhpcykuZmFkZVRvKHNwZWVkLCB0YXJnZXQsIGNhbGxiYWNrKVxyXG4gIH1cclxuXHJcbiAgJC5mbi5mYWRlT3V0ID0gZnVuY3Rpb24oc3BlZWQsIGNhbGxiYWNrKSB7XHJcbiAgICByZXR1cm4gaGlkZSh0aGlzLCBzcGVlZCwgbnVsbCwgY2FsbGJhY2spXHJcbiAgfVxyXG5cclxuICAkLmZuLmZhZGVUb2dnbGUgPSBmdW5jdGlvbihzcGVlZCwgY2FsbGJhY2spIHtcclxuICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oKXtcclxuICAgICAgdmFyIGVsID0gJCh0aGlzKVxyXG4gICAgICBlbFtcclxuICAgICAgICAoZWwuY3NzKCdvcGFjaXR5JykgPT0gMCB8fCBlbC5jc3MoJ2Rpc3BsYXknKSA9PSAnbm9uZScpID8gJ2ZhZGVJbicgOiAnZmFkZU91dCdcclxuICAgICAgXShzcGVlZCwgY2FsbGJhY2spXHJcbiAgICB9KVxyXG4gIH1cclxuXHJcbn0pKFplcHRvKVxyXG5cclxuOyhmdW5jdGlvbigkLCB1bmRlZmluZWQpe1xyXG4gIHZhciBwcmVmaXggPSAnJywgZXZlbnRQcmVmaXgsIGVuZEV2ZW50TmFtZSwgZW5kQW5pbWF0aW9uTmFtZSxcclxuICAgIHZlbmRvcnMgPSB7IFdlYmtpdDogJ3dlYmtpdCcsIE1vejogJycsIE86ICdvJyB9LFxyXG4gICAgZG9jdW1lbnQgPSB3aW5kb3cuZG9jdW1lbnQsIHRlc3RFbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpLFxyXG4gICAgc3VwcG9ydGVkVHJhbnNmb3JtcyA9IC9eKCh0cmFuc2xhdGV8cm90YXRlfHNjYWxlKShYfFl8WnwzZCk/fG1hdHJpeCgzZCk/fHBlcnNwZWN0aXZlfHNrZXcoWHxZKT8pJC9pLFxyXG4gICAgdHJhbnNmb3JtLFxyXG4gICAgdHJhbnNpdGlvblByb3BlcnR5LCB0cmFuc2l0aW9uRHVyYXRpb24sIHRyYW5zaXRpb25UaW1pbmcsIHRyYW5zaXRpb25EZWxheSxcclxuICAgIGFuaW1hdGlvbk5hbWUsIGFuaW1hdGlvbkR1cmF0aW9uLCBhbmltYXRpb25UaW1pbmcsIGFuaW1hdGlvbkRlbGF5LFxyXG4gICAgY3NzUmVzZXQgPSB7fVxyXG5cclxuICBmdW5jdGlvbiBkYXNoZXJpemUoc3RyKSB7IHJldHVybiBzdHIucmVwbGFjZSgvKFthLXpdKShbQS1aXSkvLCAnJDEtJDInKS50b0xvd2VyQ2FzZSgpIH1cclxuICBmdW5jdGlvbiBub3JtYWxpemVFdmVudChuYW1lKSB7IHJldHVybiBldmVudFByZWZpeCA/IGV2ZW50UHJlZml4ICsgbmFtZSA6IG5hbWUudG9Mb3dlckNhc2UoKSB9XHJcblxyXG4gICQuZWFjaCh2ZW5kb3JzLCBmdW5jdGlvbih2ZW5kb3IsIGV2ZW50KXtcclxuICAgIGlmICh0ZXN0RWwuc3R5bGVbdmVuZG9yICsgJ1RyYW5zaXRpb25Qcm9wZXJ0eSddICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgcHJlZml4ID0gJy0nICsgdmVuZG9yLnRvTG93ZXJDYXNlKCkgKyAnLSdcclxuICAgICAgZXZlbnRQcmVmaXggPSBldmVudFxyXG4gICAgICByZXR1cm4gZmFsc2VcclxuICAgIH1cclxuICB9KVxyXG5cclxuICB0cmFuc2Zvcm0gPSBwcmVmaXggKyAndHJhbnNmb3JtJ1xyXG4gIGNzc1Jlc2V0W3RyYW5zaXRpb25Qcm9wZXJ0eSA9IHByZWZpeCArICd0cmFuc2l0aW9uLXByb3BlcnR5J10gPVxyXG4gIGNzc1Jlc2V0W3RyYW5zaXRpb25EdXJhdGlvbiA9IHByZWZpeCArICd0cmFuc2l0aW9uLWR1cmF0aW9uJ10gPVxyXG4gIGNzc1Jlc2V0W3RyYW5zaXRpb25EZWxheSAgICA9IHByZWZpeCArICd0cmFuc2l0aW9uLWRlbGF5J10gPVxyXG4gIGNzc1Jlc2V0W3RyYW5zaXRpb25UaW1pbmcgICA9IHByZWZpeCArICd0cmFuc2l0aW9uLXRpbWluZy1mdW5jdGlvbiddID1cclxuICBjc3NSZXNldFthbmltYXRpb25OYW1lICAgICAgPSBwcmVmaXggKyAnYW5pbWF0aW9uLW5hbWUnXSA9XHJcbiAgY3NzUmVzZXRbYW5pbWF0aW9uRHVyYXRpb24gID0gcHJlZml4ICsgJ2FuaW1hdGlvbi1kdXJhdGlvbiddID1cclxuICBjc3NSZXNldFthbmltYXRpb25EZWxheSAgICAgPSBwcmVmaXggKyAnYW5pbWF0aW9uLWRlbGF5J10gPVxyXG4gIGNzc1Jlc2V0W2FuaW1hdGlvblRpbWluZyAgICA9IHByZWZpeCArICdhbmltYXRpb24tdGltaW5nLWZ1bmN0aW9uJ10gPSAnJ1xyXG5cclxuICAkLmZ4ID0ge1xyXG4gICAgb2ZmOiAoZXZlbnRQcmVmaXggPT09IHVuZGVmaW5lZCAmJiB0ZXN0RWwuc3R5bGUudHJhbnNpdGlvblByb3BlcnR5ID09PSB1bmRlZmluZWQpLFxyXG4gICAgc3BlZWRzOiB7IF9kZWZhdWx0OiA0MDAsIGZhc3Q6IDIwMCwgc2xvdzogNjAwIH0sXHJcbiAgICBjc3NQcmVmaXg6IHByZWZpeCxcclxuICAgIHRyYW5zaXRpb25FbmQ6IG5vcm1hbGl6ZUV2ZW50KCdUcmFuc2l0aW9uRW5kJyksXHJcbiAgICBhbmltYXRpb25FbmQ6IG5vcm1hbGl6ZUV2ZW50KCdBbmltYXRpb25FbmQnKVxyXG4gIH1cclxuXHJcbiAgJC5mbi5hbmltYXRlID0gZnVuY3Rpb24ocHJvcGVydGllcywgZHVyYXRpb24sIGVhc2UsIGNhbGxiYWNrLCBkZWxheSl7XHJcbiAgICBpZiAoJC5pc0Z1bmN0aW9uKGR1cmF0aW9uKSlcclxuICAgICAgY2FsbGJhY2sgPSBkdXJhdGlvbiwgZWFzZSA9IHVuZGVmaW5lZCwgZHVyYXRpb24gPSB1bmRlZmluZWRcclxuICAgIGlmICgkLmlzRnVuY3Rpb24oZWFzZSkpXHJcbiAgICAgIGNhbGxiYWNrID0gZWFzZSwgZWFzZSA9IHVuZGVmaW5lZFxyXG4gICAgaWYgKCQuaXNQbGFpbk9iamVjdChkdXJhdGlvbikpXHJcbiAgICAgIGVhc2UgPSBkdXJhdGlvbi5lYXNpbmcsIGNhbGxiYWNrID0gZHVyYXRpb24uY29tcGxldGUsIGRlbGF5ID0gZHVyYXRpb24uZGVsYXksIGR1cmF0aW9uID0gZHVyYXRpb24uZHVyYXRpb25cclxuICAgIGlmIChkdXJhdGlvbikgZHVyYXRpb24gPSAodHlwZW9mIGR1cmF0aW9uID09ICdudW1iZXInID8gZHVyYXRpb24gOlxyXG4gICAgICAgICAgICAgICAgICAgICgkLmZ4LnNwZWVkc1tkdXJhdGlvbl0gfHwgJC5meC5zcGVlZHMuX2RlZmF1bHQpKSAvIDEwMDBcclxuICAgIGlmIChkZWxheSkgZGVsYXkgPSBwYXJzZUZsb2F0KGRlbGF5KSAvIDEwMDBcclxuICAgIHJldHVybiB0aGlzLmFuaW0ocHJvcGVydGllcywgZHVyYXRpb24sIGVhc2UsIGNhbGxiYWNrLCBkZWxheSlcclxuICB9XHJcblxyXG4gICQuZm4uYW5pbSA9IGZ1bmN0aW9uKHByb3BlcnRpZXMsIGR1cmF0aW9uLCBlYXNlLCBjYWxsYmFjaywgZGVsYXkpe1xyXG4gICAgdmFyIGtleSwgY3NzVmFsdWVzID0ge30sIGNzc1Byb3BlcnRpZXMsIHRyYW5zZm9ybXMgPSAnJyxcclxuICAgICAgICB0aGF0ID0gdGhpcywgd3JhcHBlZENhbGxiYWNrLCBlbmRFdmVudCA9ICQuZngudHJhbnNpdGlvbkVuZCxcclxuICAgICAgICBmaXJlZCA9IGZhbHNlXHJcblxyXG4gICAgaWYgKGR1cmF0aW9uID09PSB1bmRlZmluZWQpIGR1cmF0aW9uID0gJC5meC5zcGVlZHMuX2RlZmF1bHQgLyAxMDAwXHJcbiAgICBpZiAoZGVsYXkgPT09IHVuZGVmaW5lZCkgZGVsYXkgPSAwXHJcbiAgICBpZiAoJC5meC5vZmYpIGR1cmF0aW9uID0gMFxyXG5cclxuICAgIGlmICh0eXBlb2YgcHJvcGVydGllcyA9PSAnc3RyaW5nJykge1xyXG4gICAgICAvLyBrZXlmcmFtZSBhbmltYXRpb25cclxuICAgICAgY3NzVmFsdWVzW2FuaW1hdGlvbk5hbWVdID0gcHJvcGVydGllc1xyXG4gICAgICBjc3NWYWx1ZXNbYW5pbWF0aW9uRHVyYXRpb25dID0gZHVyYXRpb24gKyAncydcclxuICAgICAgY3NzVmFsdWVzW2FuaW1hdGlvbkRlbGF5XSA9IGRlbGF5ICsgJ3MnXHJcbiAgICAgIGNzc1ZhbHVlc1thbmltYXRpb25UaW1pbmddID0gKGVhc2UgfHwgJ2xpbmVhcicpXHJcbiAgICAgIGVuZEV2ZW50ID0gJC5meC5hbmltYXRpb25FbmRcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGNzc1Byb3BlcnRpZXMgPSBbXVxyXG4gICAgICAvLyBDU1MgdHJhbnNpdGlvbnNcclxuICAgICAgZm9yIChrZXkgaW4gcHJvcGVydGllcylcclxuICAgICAgICBpZiAoc3VwcG9ydGVkVHJhbnNmb3Jtcy50ZXN0KGtleSkpIHRyYW5zZm9ybXMgKz0ga2V5ICsgJygnICsgcHJvcGVydGllc1trZXldICsgJykgJ1xyXG4gICAgICAgIGVsc2UgY3NzVmFsdWVzW2tleV0gPSBwcm9wZXJ0aWVzW2tleV0sIGNzc1Byb3BlcnRpZXMucHVzaChkYXNoZXJpemUoa2V5KSlcclxuXHJcbiAgICAgIGlmICh0cmFuc2Zvcm1zKSBjc3NWYWx1ZXNbdHJhbnNmb3JtXSA9IHRyYW5zZm9ybXMsIGNzc1Byb3BlcnRpZXMucHVzaCh0cmFuc2Zvcm0pXHJcbiAgICAgIGlmIChkdXJhdGlvbiA+IDAgJiYgdHlwZW9mIHByb3BlcnRpZXMgPT09ICdvYmplY3QnKSB7XHJcbiAgICAgICAgY3NzVmFsdWVzW3RyYW5zaXRpb25Qcm9wZXJ0eV0gPSBjc3NQcm9wZXJ0aWVzLmpvaW4oJywgJylcclxuICAgICAgICBjc3NWYWx1ZXNbdHJhbnNpdGlvbkR1cmF0aW9uXSA9IGR1cmF0aW9uICsgJ3MnXHJcbiAgICAgICAgY3NzVmFsdWVzW3RyYW5zaXRpb25EZWxheV0gPSBkZWxheSArICdzJ1xyXG4gICAgICAgIGNzc1ZhbHVlc1t0cmFuc2l0aW9uVGltaW5nXSA9IChlYXNlIHx8ICdsaW5lYXInKVxyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgd3JhcHBlZENhbGxiYWNrID0gZnVuY3Rpb24oZXZlbnQpe1xyXG4gICAgICBpZiAodHlwZW9mIGV2ZW50ICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgIGlmIChldmVudC50YXJnZXQgIT09IGV2ZW50LmN1cnJlbnRUYXJnZXQpIHJldHVybiAvLyBtYWtlcyBzdXJlIHRoZSBldmVudCBkaWRuJ3QgYnViYmxlIGZyb20gXCJiZWxvd1wiXHJcbiAgICAgICAgJChldmVudC50YXJnZXQpLnVuYmluZChlbmRFdmVudCwgd3JhcHBlZENhbGxiYWNrKVxyXG4gICAgICB9IGVsc2VcclxuICAgICAgICAkKHRoaXMpLnVuYmluZChlbmRFdmVudCwgd3JhcHBlZENhbGxiYWNrKSAvLyB0cmlnZ2VyZWQgYnkgc2V0VGltZW91dFxyXG5cclxuICAgICAgZmlyZWQgPSB0cnVlXHJcbiAgICAgICQodGhpcykuY3NzKGNzc1Jlc2V0KVxyXG4gICAgICBjYWxsYmFjayAmJiBjYWxsYmFjay5jYWxsKHRoaXMpXHJcbiAgICB9XHJcbiAgICBpZiAoZHVyYXRpb24gPiAwKXtcclxuICAgICAgdGhpcy5iaW5kKGVuZEV2ZW50LCB3cmFwcGVkQ2FsbGJhY2spXHJcbiAgICAgIC8vIHRyYW5zaXRpb25FbmQgaXMgbm90IGFsd2F5cyBmaXJpbmcgb24gb2xkZXIgQW5kcm9pZCBwaG9uZXNcclxuICAgICAgLy8gc28gbWFrZSBzdXJlIGl0IGdldHMgZmlyZWRcclxuICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpe1xyXG4gICAgICAgIGlmIChmaXJlZCkgcmV0dXJuXHJcbiAgICAgICAgd3JhcHBlZENhbGxiYWNrLmNhbGwodGhhdClcclxuICAgICAgfSwgKGR1cmF0aW9uICogMTAwMCkgKyAyNSlcclxuICAgIH1cclxuXHJcbiAgICAvLyB0cmlnZ2VyIHBhZ2UgcmVmbG93IHNvIG5ldyBlbGVtZW50cyBjYW4gYW5pbWF0ZVxyXG4gICAgdGhpcy5zaXplKCkgJiYgdGhpcy5nZXQoMCkuY2xpZW50TGVmdFxyXG5cclxuICAgIHRoaXMuY3NzKGNzc1ZhbHVlcylcclxuXHJcbiAgICBpZiAoZHVyYXRpb24gPD0gMCkgc2V0VGltZW91dChmdW5jdGlvbigpIHtcclxuICAgICAgdGhhdC5lYWNoKGZ1bmN0aW9uKCl7IHdyYXBwZWRDYWxsYmFjay5jYWxsKHRoaXMpIH0pXHJcbiAgICB9LCAwKVxyXG5cclxuICAgIHJldHVybiB0aGlzXHJcbiAgfVxyXG5cclxuICB0ZXN0RWwgPSBudWxsXHJcbn0pKFplcHRvKVxyXG5cclxuOyhmdW5jdGlvbigkKXtcclxuICBpZiAoJC5vcy5pb3MpIHtcclxuICAgIHZhciBnZXN0dXJlID0ge30sIGdlc3R1cmVUaW1lb3V0XHJcblxyXG4gICAgZnVuY3Rpb24gcGFyZW50SWZUZXh0KG5vZGUpe1xyXG4gICAgICByZXR1cm4gJ3RhZ05hbWUnIGluIG5vZGUgPyBub2RlIDogbm9kZS5wYXJlbnROb2RlXHJcbiAgICB9XHJcblxyXG4gICAgJChkb2N1bWVudCkuYmluZCgnZ2VzdHVyZXN0YXJ0JywgZnVuY3Rpb24oZSl7XHJcbiAgICAgIHZhciBub3cgPSBEYXRlLm5vdygpLCBkZWx0YSA9IG5vdyAtIChnZXN0dXJlLmxhc3QgfHwgbm93KVxyXG4gICAgICBnZXN0dXJlLnRhcmdldCA9IHBhcmVudElmVGV4dChlLnRhcmdldClcclxuICAgICAgZ2VzdHVyZVRpbWVvdXQgJiYgY2xlYXJUaW1lb3V0KGdlc3R1cmVUaW1lb3V0KVxyXG4gICAgICBnZXN0dXJlLmUxID0gZS5zY2FsZVxyXG4gICAgICBnZXN0dXJlLmxhc3QgPSBub3dcclxuICAgIH0pLmJpbmQoJ2dlc3R1cmVjaGFuZ2UnLCBmdW5jdGlvbihlKXtcclxuICAgICAgZ2VzdHVyZS5lMiA9IGUuc2NhbGVcclxuICAgIH0pLmJpbmQoJ2dlc3R1cmVlbmQnLCBmdW5jdGlvbihlKXtcclxuICAgICAgaWYgKGdlc3R1cmUuZTIgPiAwKSB7XHJcbiAgICAgICAgTWF0aC5hYnMoZ2VzdHVyZS5lMSAtIGdlc3R1cmUuZTIpICE9IDAgJiYgJChnZXN0dXJlLnRhcmdldCkudHJpZ2dlcigncGluY2gnKSAmJlxyXG4gICAgICAgICAgJChnZXN0dXJlLnRhcmdldCkudHJpZ2dlcigncGluY2gnICsgKGdlc3R1cmUuZTEgLSBnZXN0dXJlLmUyID4gMCA/ICdJbicgOiAnT3V0JykpXHJcbiAgICAgICAgZ2VzdHVyZS5lMSA9IGdlc3R1cmUuZTIgPSBnZXN0dXJlLmxhc3QgPSAwXHJcbiAgICAgIH0gZWxzZSBpZiAoJ2xhc3QnIGluIGdlc3R1cmUpIHtcclxuICAgICAgICBnZXN0dXJlID0ge31cclxuICAgICAgfVxyXG4gICAgfSlcclxuXHJcbiAgICA7WydwaW5jaCcsICdwaW5jaEluJywgJ3BpbmNoT3V0J10uZm9yRWFjaChmdW5jdGlvbihtKXtcclxuICAgICAgJC5mblttXSA9IGZ1bmN0aW9uKGNhbGxiYWNrKXsgcmV0dXJuIHRoaXMuYmluZChtLCBjYWxsYmFjaykgfVxyXG4gICAgfSlcclxuICB9XHJcbn0pKFplcHRvKVxyXG5cclxuOyhmdW5jdGlvbigkKXtcclxuICAvLyBfX3Byb3RvX18gZG9lc24ndCBleGlzdCBvbiBJRTwxMSwgc28gcmVkZWZpbmVcclxuICAvLyB0aGUgWiBmdW5jdGlvbiB0byB1c2Ugb2JqZWN0IGV4dGVuc2lvbiBpbnN0ZWFkXHJcbiAgaWYgKCEoJ19fcHJvdG9fXycgaW4ge30pKSB7XHJcbiAgICAkLmV4dGVuZCgkLnplcHRvLCB7XHJcbiAgICAgIFo6IGZ1bmN0aW9uKGRvbSwgc2VsZWN0b3Ipe1xyXG4gICAgICAgIGRvbSA9IGRvbSB8fCBbXVxyXG4gICAgICAgICQuZXh0ZW5kKGRvbSwgJC5mbilcclxuICAgICAgICBkb20uc2VsZWN0b3IgPSBzZWxlY3RvciB8fCAnJ1xyXG4gICAgICAgIGRvbS5fX1ogPSB0cnVlXHJcbiAgICAgICAgcmV0dXJuIGRvbVxyXG4gICAgICB9LFxyXG4gICAgICAvLyB0aGlzIGlzIGEga2x1ZGdlIGJ1dCB3b3Jrc1xyXG4gICAgICBpc1o6IGZ1bmN0aW9uKG9iamVjdCl7XHJcbiAgICAgICAgcmV0dXJuICQudHlwZShvYmplY3QpID09PSAnYXJyYXknICYmICdfX1onIGluIG9iamVjdFxyXG4gICAgICB9XHJcbiAgICB9KVxyXG4gIH1cclxuXHJcbiAgLy8gZ2V0Q29tcHV0ZWRTdHlsZSBzaG91bGRuJ3QgZnJlYWsgb3V0IHdoZW4gY2FsbGVkXHJcbiAgLy8gd2l0aG91dCBhIHZhbGlkIGVsZW1lbnQgYXMgYXJndW1lbnRcclxuICB0cnkge1xyXG4gICAgZ2V0Q29tcHV0ZWRTdHlsZSh1bmRlZmluZWQpXHJcbiAgfSBjYXRjaChlKSB7XHJcbiAgICB2YXIgbmF0aXZlR2V0Q29tcHV0ZWRTdHlsZSA9IGdldENvbXB1dGVkU3R5bGU7XHJcbiAgICB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSA9IGZ1bmN0aW9uKGVsZW1lbnQpe1xyXG4gICAgICB0cnkge1xyXG4gICAgICAgIHJldHVybiBuYXRpdmVHZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpXHJcbiAgICAgIH0gY2F0Y2goZSkge1xyXG4gICAgICAgIHJldHVybiBudWxsXHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcbn0pKFplcHRvKVxyXG5cclxuOyhmdW5jdGlvbigkKXtcclxuICB2YXIgemVwdG8gPSAkLnplcHRvLCBvbGRRc2EgPSB6ZXB0by5xc2EsIG9sZE1hdGNoZXMgPSB6ZXB0by5tYXRjaGVzXHJcblxyXG4gIGZ1bmN0aW9uIHZpc2libGUoZWxlbSl7XHJcbiAgICBlbGVtID0gJChlbGVtKVxyXG4gICAgcmV0dXJuICEhKGVsZW0ud2lkdGgoKSB8fCBlbGVtLmhlaWdodCgpKSAmJiBlbGVtLmNzcyhcImRpc3BsYXlcIikgIT09IFwibm9uZVwiXHJcbiAgfVxyXG5cclxuICAvLyBJbXBsZW1lbnRzIGEgc3Vic2V0IGZyb206XHJcbiAgLy8gaHR0cDovL2FwaS5qcXVlcnkuY29tL2NhdGVnb3J5L3NlbGVjdG9ycy9qcXVlcnktc2VsZWN0b3ItZXh0ZW5zaW9ucy9cclxuICAvL1xyXG4gIC8vIEVhY2ggZmlsdGVyIGZ1bmN0aW9uIHJlY2VpdmVzIHRoZSBjdXJyZW50IGluZGV4LCBhbGwgbm9kZXMgaW4gdGhlXHJcbiAgLy8gY29uc2lkZXJlZCBzZXQsIGFuZCBhIHZhbHVlIGlmIHRoZXJlIHdlcmUgcGFyZW50aGVzZXMuIFRoZSB2YWx1ZVxyXG4gIC8vIG9mIGB0aGlzYCBpcyB0aGUgbm9kZSBjdXJyZW50bHkgYmVpbmcgY29uc2lkZXJlZC4gVGhlIGZ1bmN0aW9uIHJldHVybnMgdGhlXHJcbiAgLy8gcmVzdWx0aW5nIG5vZGUocyksIG51bGwsIG9yIHVuZGVmaW5lZC5cclxuICAvL1xyXG4gIC8vIENvbXBsZXggc2VsZWN0b3JzIGFyZSBub3Qgc3VwcG9ydGVkOlxyXG4gIC8vICAgbGk6aGFzKGxhYmVsOmNvbnRhaW5zKFwiZm9vXCIpKSArIGxpOmhhcyhsYWJlbDpjb250YWlucyhcImJhclwiKSlcclxuICAvLyAgIHVsLmlubmVyOmZpcnN0ID4gbGlcclxuICB2YXIgZmlsdGVycyA9ICQuZXhwclsnOiddID0ge1xyXG4gICAgdmlzaWJsZTogIGZ1bmN0aW9uKCl7IGlmICh2aXNpYmxlKHRoaXMpKSByZXR1cm4gdGhpcyB9LFxyXG4gICAgaGlkZGVuOiAgIGZ1bmN0aW9uKCl7IGlmICghdmlzaWJsZSh0aGlzKSkgcmV0dXJuIHRoaXMgfSxcclxuICAgIHNlbGVjdGVkOiBmdW5jdGlvbigpeyBpZiAodGhpcy5zZWxlY3RlZCkgcmV0dXJuIHRoaXMgfSxcclxuICAgIGNoZWNrZWQ6ICBmdW5jdGlvbigpeyBpZiAodGhpcy5jaGVja2VkKSByZXR1cm4gdGhpcyB9LFxyXG4gICAgcGFyZW50OiAgIGZ1bmN0aW9uKCl7IHJldHVybiB0aGlzLnBhcmVudE5vZGUgfSxcclxuICAgIGZpcnN0OiAgICBmdW5jdGlvbihpZHgpeyBpZiAoaWR4ID09PSAwKSByZXR1cm4gdGhpcyB9LFxyXG4gICAgbGFzdDogICAgIGZ1bmN0aW9uKGlkeCwgbm9kZXMpeyBpZiAoaWR4ID09PSBub2Rlcy5sZW5ndGggLSAxKSByZXR1cm4gdGhpcyB9LFxyXG4gICAgZXE6ICAgICAgIGZ1bmN0aW9uKGlkeCwgXywgdmFsdWUpeyBpZiAoaWR4ID09PSB2YWx1ZSkgcmV0dXJuIHRoaXMgfSxcclxuICAgIGNvbnRhaW5zOiBmdW5jdGlvbihpZHgsIF8sIHRleHQpeyBpZiAoJCh0aGlzKS50ZXh0KCkuaW5kZXhPZih0ZXh0KSA+IC0xKSByZXR1cm4gdGhpcyB9LFxyXG4gICAgaGFzOiAgICAgIGZ1bmN0aW9uKGlkeCwgXywgc2VsKXsgaWYgKHplcHRvLnFzYSh0aGlzLCBzZWwpLmxlbmd0aCkgcmV0dXJuIHRoaXMgfVxyXG4gIH1cclxuXHJcbiAgdmFyIGZpbHRlclJlID0gbmV3IFJlZ0V4cCgnKC4qKTooXFxcXHcrKSg/OlxcXFwoKFteKV0rKVxcXFwpKT8kXFxcXHMqJyksXHJcbiAgICAgIGNoaWxkUmUgID0gL15cXHMqPi8sXHJcbiAgICAgIGNsYXNzVGFnID0gJ1plcHRvJyArICgrbmV3IERhdGUoKSlcclxuXHJcbiAgZnVuY3Rpb24gcHJvY2VzcyhzZWwsIGZuKSB7XHJcbiAgICAvLyBxdW90ZSB0aGUgaGFzaCBpbiBgYVtocmVmXj0jXWAgZXhwcmVzc2lvblxyXG4gICAgc2VsID0gc2VsLnJlcGxhY2UoLz0jXFxdL2csICc9XCIjXCJdJylcclxuICAgIHZhciBmaWx0ZXIsIGFyZywgbWF0Y2ggPSBmaWx0ZXJSZS5leGVjKHNlbClcclxuICAgIGlmIChtYXRjaCAmJiBtYXRjaFsyXSBpbiBmaWx0ZXJzKSB7XHJcbiAgICAgIGZpbHRlciA9IGZpbHRlcnNbbWF0Y2hbMl1dLCBhcmcgPSBtYXRjaFszXVxyXG4gICAgICBzZWwgPSBtYXRjaFsxXVxyXG4gICAgICBpZiAoYXJnKSB7XHJcbiAgICAgICAgdmFyIG51bSA9IE51bWJlcihhcmcpXHJcbiAgICAgICAgaWYgKGlzTmFOKG51bSkpIGFyZyA9IGFyZy5yZXBsYWNlKC9eW1wiJ118W1wiJ10kL2csICcnKVxyXG4gICAgICAgIGVsc2UgYXJnID0gbnVtXHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBmbihzZWwsIGZpbHRlciwgYXJnKVxyXG4gIH1cclxuXHJcbiAgemVwdG8ucXNhID0gZnVuY3Rpb24obm9kZSwgc2VsZWN0b3IpIHtcclxuICAgIHJldHVybiBwcm9jZXNzKHNlbGVjdG9yLCBmdW5jdGlvbihzZWwsIGZpbHRlciwgYXJnKXtcclxuICAgICAgdHJ5IHtcclxuICAgICAgICB2YXIgdGFnZ2VkUGFyZW50XHJcbiAgICAgICAgaWYgKCFzZWwgJiYgZmlsdGVyKSBzZWwgPSAnKidcclxuICAgICAgICBlbHNlIGlmIChjaGlsZFJlLnRlc3Qoc2VsKSlcclxuICAgICAgICAgIC8vIHN1cHBvcnQgXCI+ICpcIiBjaGlsZCBxdWVyaWVzIGJ5IHRhZ2dpbmcgdGhlIHBhcmVudCBub2RlIHdpdGggYVxyXG4gICAgICAgICAgLy8gdW5pcXVlIGNsYXNzIGFuZCBwcmVwZW5kaW5nIHRoYXQgY2xhc3NuYW1lIG9udG8gdGhlIHNlbGVjdG9yXHJcbiAgICAgICAgICB0YWdnZWRQYXJlbnQgPSAkKG5vZGUpLmFkZENsYXNzKGNsYXNzVGFnKSwgc2VsID0gJy4nK2NsYXNzVGFnKycgJytzZWxcclxuXHJcbiAgICAgICAgdmFyIG5vZGVzID0gb2xkUXNhKG5vZGUsIHNlbClcclxuICAgICAgfSBjYXRjaChlKSB7XHJcbiAgICAgICAgY29uc29sZS5lcnJvcignZXJyb3IgcGVyZm9ybWluZyBzZWxlY3RvcjogJW8nLCBzZWxlY3RvcilcclxuICAgICAgICB0aHJvdyBlXHJcbiAgICAgIH0gZmluYWxseSB7XHJcbiAgICAgICAgaWYgKHRhZ2dlZFBhcmVudCkgdGFnZ2VkUGFyZW50LnJlbW92ZUNsYXNzKGNsYXNzVGFnKVxyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiAhZmlsdGVyID8gbm9kZXMgOlxyXG4gICAgICAgIHplcHRvLnVuaXEoJC5tYXAobm9kZXMsIGZ1bmN0aW9uKG4sIGkpeyByZXR1cm4gZmlsdGVyLmNhbGwobiwgaSwgbm9kZXMsIGFyZykgfSkpXHJcbiAgICB9KVxyXG4gIH1cclxuXHJcbiAgemVwdG8ubWF0Y2hlcyA9IGZ1bmN0aW9uKG5vZGUsIHNlbGVjdG9yKXtcclxuICAgIHJldHVybiBwcm9jZXNzKHNlbGVjdG9yLCBmdW5jdGlvbihzZWwsIGZpbHRlciwgYXJnKXtcclxuICAgICAgcmV0dXJuICghc2VsIHx8IG9sZE1hdGNoZXMobm9kZSwgc2VsKSkgJiZcclxuICAgICAgICAoIWZpbHRlciB8fCBmaWx0ZXIuY2FsbChub2RlLCBudWxsLCBhcmcpID09PSBub2RlKVxyXG4gICAgfSlcclxuICB9XHJcbn0pKFplcHRvKVxyXG5cclxuOyhmdW5jdGlvbigkKXtcclxuICAkLmZuLmVuZCA9IGZ1bmN0aW9uKCl7XHJcbiAgICByZXR1cm4gdGhpcy5wcmV2T2JqZWN0IHx8ICQoKVxyXG4gIH1cclxuXHJcbiAgJC5mbi5hbmRTZWxmID0gZnVuY3Rpb24oKXtcclxuICAgIHJldHVybiB0aGlzLmFkZCh0aGlzLnByZXZPYmplY3QgfHwgJCgpKVxyXG4gIH1cclxuXHJcbiAgJ2ZpbHRlcixhZGQsbm90LGVxLGZpcnN0LGxhc3QsZmluZCxjbG9zZXN0LHBhcmVudHMscGFyZW50LGNoaWxkcmVuLHNpYmxpbmdzJy5zcGxpdCgnLCcpLmZvckVhY2goZnVuY3Rpb24ocHJvcGVydHkpe1xyXG4gICAgdmFyIGZuID0gJC5mbltwcm9wZXJ0eV1cclxuICAgICQuZm5bcHJvcGVydHldID0gZnVuY3Rpb24oKXtcclxuICAgICAgdmFyIHJldCA9IGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcclxuICAgICAgcmV0LnByZXZPYmplY3QgPSB0aGlzXHJcbiAgICAgIHJldHVybiByZXRcclxuICAgIH1cclxuICB9KVxyXG59KShaZXB0bylcclxuXHJcbjsoZnVuY3Rpb24oJCl7XHJcbiAgdmFyIHRvdWNoID0ge30sXHJcbiAgICB0b3VjaFRpbWVvdXQsIHRhcFRpbWVvdXQsIHN3aXBlVGltZW91dCwgbG9uZ1RhcFRpbWVvdXQsXHJcbiAgICBsb25nVGFwRGVsYXkgPSA3NTAsXHJcbiAgICBnZXN0dXJlXHJcblxyXG4gIGZ1bmN0aW9uIHN3aXBlRGlyZWN0aW9uKHgxLCB4MiwgeTEsIHkyKSB7XHJcbiAgICByZXR1cm4gTWF0aC5hYnMoeDEgLSB4MikgPj1cclxuICAgICAgTWF0aC5hYnMoeTEgLSB5MikgPyAoeDEgLSB4MiA+IDAgPyAnTGVmdCcgOiAnUmlnaHQnKSA6ICh5MSAtIHkyID4gMCA/ICdVcCcgOiAnRG93bicpXHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBsb25nVGFwKCkge1xyXG4gICAgbG9uZ1RhcFRpbWVvdXQgPSBudWxsXHJcbiAgICBpZiAodG91Y2gubGFzdCkge1xyXG4gICAgICB0b3VjaC5lbC50cmlnZ2VyKCdsb25nVGFwJylcclxuICAgICAgdG91Y2ggPSB7fVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gY2FuY2VsTG9uZ1RhcCgpIHtcclxuICAgIGlmIChsb25nVGFwVGltZW91dCkgY2xlYXJUaW1lb3V0KGxvbmdUYXBUaW1lb3V0KVxyXG4gICAgbG9uZ1RhcFRpbWVvdXQgPSBudWxsXHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBjYW5jZWxBbGwoKSB7XHJcbiAgICBpZiAodG91Y2hUaW1lb3V0KSBjbGVhclRpbWVvdXQodG91Y2hUaW1lb3V0KVxyXG4gICAgaWYgKHRhcFRpbWVvdXQpIGNsZWFyVGltZW91dCh0YXBUaW1lb3V0KVxyXG4gICAgaWYgKHN3aXBlVGltZW91dCkgY2xlYXJUaW1lb3V0KHN3aXBlVGltZW91dClcclxuICAgIGlmIChsb25nVGFwVGltZW91dCkgY2xlYXJUaW1lb3V0KGxvbmdUYXBUaW1lb3V0KVxyXG4gICAgdG91Y2hUaW1lb3V0ID0gdGFwVGltZW91dCA9IHN3aXBlVGltZW91dCA9IGxvbmdUYXBUaW1lb3V0ID0gbnVsbFxyXG4gICAgdG91Y2ggPSB7fVxyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gaXNQcmltYXJ5VG91Y2goZXZlbnQpe1xyXG4gICAgcmV0dXJuIChldmVudC5wb2ludGVyVHlwZSA9PSAndG91Y2gnIHx8XHJcbiAgICAgIGV2ZW50LnBvaW50ZXJUeXBlID09IGV2ZW50Lk1TUE9JTlRFUl9UWVBFX1RPVUNIKVxyXG4gICAgICAmJiBldmVudC5pc1ByaW1hcnlcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGlzUG9pbnRlckV2ZW50VHlwZShlLCB0eXBlKXtcclxuICAgIHJldHVybiAoZS50eXBlID09ICdwb2ludGVyJyt0eXBlIHx8XHJcbiAgICAgIGUudHlwZS50b0xvd2VyQ2FzZSgpID09ICdtc3BvaW50ZXInK3R5cGUpXHJcbiAgfVxyXG5cclxuICAkKGRvY3VtZW50KS5yZWFkeShmdW5jdGlvbigpe1xyXG4gICAgdmFyIG5vdywgZGVsdGEsIGRlbHRhWCA9IDAsIGRlbHRhWSA9IDAsIGZpcnN0VG91Y2gsIF9pc1BvaW50ZXJUeXBlXHJcblxyXG4gICAgaWYgKCdNU0dlc3R1cmUnIGluIHdpbmRvdykge1xyXG4gICAgICBnZXN0dXJlID0gbmV3IE1TR2VzdHVyZSgpXHJcbiAgICAgIGdlc3R1cmUudGFyZ2V0ID0gZG9jdW1lbnQuYm9keVxyXG4gICAgfVxyXG5cclxuICAgICQoZG9jdW1lbnQpXHJcbiAgICAgIC5iaW5kKCdNU0dlc3R1cmVFbmQnLCBmdW5jdGlvbihlKXtcclxuICAgICAgICB2YXIgc3dpcGVEaXJlY3Rpb25Gcm9tVmVsb2NpdHkgPVxyXG4gICAgICAgICAgZS52ZWxvY2l0eVggPiAxID8gJ1JpZ2h0JyA6IGUudmVsb2NpdHlYIDwgLTEgPyAnTGVmdCcgOiBlLnZlbG9jaXR5WSA+IDEgPyAnRG93bicgOiBlLnZlbG9jaXR5WSA8IC0xID8gJ1VwJyA6IG51bGw7XHJcbiAgICAgICAgaWYgKHN3aXBlRGlyZWN0aW9uRnJvbVZlbG9jaXR5KSB7XHJcbiAgICAgICAgICB0b3VjaC5lbC50cmlnZ2VyKCdzd2lwZScpXHJcbiAgICAgICAgICB0b3VjaC5lbC50cmlnZ2VyKCdzd2lwZScrIHN3aXBlRGlyZWN0aW9uRnJvbVZlbG9jaXR5KVxyXG4gICAgICAgIH1cclxuICAgICAgfSlcclxuICAgICAgLm9uKCd0b3VjaHN0YXJ0IE1TUG9pbnRlckRvd24gcG9pbnRlcmRvd24nLCBmdW5jdGlvbihlKXtcclxuICAgICAgICBpZigoX2lzUG9pbnRlclR5cGUgPSBpc1BvaW50ZXJFdmVudFR5cGUoZSwgJ2Rvd24nKSkgJiZcclxuICAgICAgICAgICFpc1ByaW1hcnlUb3VjaChlKSkgcmV0dXJuXHJcbiAgICAgICAgZmlyc3RUb3VjaCA9IF9pc1BvaW50ZXJUeXBlID8gZSA6IGUudG91Y2hlc1swXVxyXG4gICAgICAgIGlmIChlLnRvdWNoZXMgJiYgZS50b3VjaGVzLmxlbmd0aCA9PT0gMSAmJiB0b3VjaC54Mikge1xyXG4gICAgICAgICAgLy8gQ2xlYXIgb3V0IHRvdWNoIG1vdmVtZW50IGRhdGEgaWYgd2UgaGF2ZSBpdCBzdGlja2luZyBhcm91bmRcclxuICAgICAgICAgIC8vIFRoaXMgY2FuIG9jY3VyIGlmIHRvdWNoY2FuY2VsIGRvZXNuJ3QgZmlyZSBkdWUgdG8gcHJldmVudERlZmF1bHQsIGV0Yy5cclxuICAgICAgICAgIHRvdWNoLngyID0gdW5kZWZpbmVkXHJcbiAgICAgICAgICB0b3VjaC55MiA9IHVuZGVmaW5lZFxyXG4gICAgICAgIH1cclxuICAgICAgICBub3cgPSBEYXRlLm5vdygpXHJcbiAgICAgICAgZGVsdGEgPSBub3cgLSAodG91Y2gubGFzdCB8fCBub3cpXHJcbiAgICAgICAgdG91Y2guZWwgPSAkKCd0YWdOYW1lJyBpbiBmaXJzdFRvdWNoLnRhcmdldCA/XHJcbiAgICAgICAgICBmaXJzdFRvdWNoLnRhcmdldCA6IGZpcnN0VG91Y2gudGFyZ2V0LnBhcmVudE5vZGUpXHJcbiAgICAgICAgdG91Y2hUaW1lb3V0ICYmIGNsZWFyVGltZW91dCh0b3VjaFRpbWVvdXQpXHJcbiAgICAgICAgdG91Y2gueDEgPSBmaXJzdFRvdWNoLnBhZ2VYXHJcbiAgICAgICAgdG91Y2gueTEgPSBmaXJzdFRvdWNoLnBhZ2VZXHJcbiAgICAgICAgaWYgKGRlbHRhID4gMCAmJiBkZWx0YSA8PSAyNTApIHRvdWNoLmlzRG91YmxlVGFwID0gdHJ1ZVxyXG4gICAgICAgIHRvdWNoLmxhc3QgPSBub3dcclxuICAgICAgICBsb25nVGFwVGltZW91dCA9IHNldFRpbWVvdXQobG9uZ1RhcCwgbG9uZ1RhcERlbGF5KVxyXG4gICAgICAgIC8vIGFkZHMgdGhlIGN1cnJlbnQgdG91Y2ggY29udGFjdCBmb3IgSUUgZ2VzdHVyZSByZWNvZ25pdGlvblxyXG4gICAgICAgIGlmIChnZXN0dXJlICYmIF9pc1BvaW50ZXJUeXBlKSBnZXN0dXJlLmFkZFBvaW50ZXIoZS5wb2ludGVySWQpO1xyXG4gICAgICB9KVxyXG4gICAgICAub24oJ3RvdWNobW92ZSBNU1BvaW50ZXJNb3ZlIHBvaW50ZXJtb3ZlJywgZnVuY3Rpb24oZSl7XHJcbiAgICAgICAgaWYoKF9pc1BvaW50ZXJUeXBlID0gaXNQb2ludGVyRXZlbnRUeXBlKGUsICdtb3ZlJykpICYmXHJcbiAgICAgICAgICAhaXNQcmltYXJ5VG91Y2goZSkpIHJldHVyblxyXG4gICAgICAgIGZpcnN0VG91Y2ggPSBfaXNQb2ludGVyVHlwZSA/IGUgOiBlLnRvdWNoZXNbMF1cclxuICAgICAgICBjYW5jZWxMb25nVGFwKClcclxuICAgICAgICB0b3VjaC54MiA9IGZpcnN0VG91Y2gucGFnZVhcclxuICAgICAgICB0b3VjaC55MiA9IGZpcnN0VG91Y2gucGFnZVlcclxuXHJcbiAgICAgICAgZGVsdGFYICs9IE1hdGguYWJzKHRvdWNoLngxIC0gdG91Y2gueDIpXHJcbiAgICAgICAgZGVsdGFZICs9IE1hdGguYWJzKHRvdWNoLnkxIC0gdG91Y2gueTIpXHJcbiAgICAgIH0pXHJcbiAgICAgIC5vbigndG91Y2hlbmQgTVNQb2ludGVyVXAgcG9pbnRlcnVwJywgZnVuY3Rpb24oZSl7XHJcbiAgICAgICAgaWYoKF9pc1BvaW50ZXJUeXBlID0gaXNQb2ludGVyRXZlbnRUeXBlKGUsICd1cCcpKSAmJlxyXG4gICAgICAgICAgIWlzUHJpbWFyeVRvdWNoKGUpKSByZXR1cm5cclxuICAgICAgICBjYW5jZWxMb25nVGFwKClcclxuXHJcbiAgICAgICAgLy8gc3dpcGVcclxuICAgICAgICBpZiAoKHRvdWNoLngyICYmIE1hdGguYWJzKHRvdWNoLngxIC0gdG91Y2gueDIpID4gMzApIHx8XHJcbiAgICAgICAgICAgICh0b3VjaC55MiAmJiBNYXRoLmFicyh0b3VjaC55MSAtIHRvdWNoLnkyKSA+IDMwKSlcclxuXHJcbiAgICAgICAgICBzd2lwZVRpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICB0b3VjaC5lbC50cmlnZ2VyKCdzd2lwZScpXHJcbiAgICAgICAgICAgIHRvdWNoLmVsLnRyaWdnZXIoJ3N3aXBlJyArIChzd2lwZURpcmVjdGlvbih0b3VjaC54MSwgdG91Y2gueDIsIHRvdWNoLnkxLCB0b3VjaC55MikpKVxyXG4gICAgICAgICAgICB0b3VjaCA9IHt9XHJcbiAgICAgICAgICB9LCAwKVxyXG5cclxuICAgICAgICAvLyBub3JtYWwgdGFwXHJcbiAgICAgICAgZWxzZSBpZiAoJ2xhc3QnIGluIHRvdWNoKVxyXG4gICAgICAgICAgLy8gZG9uJ3QgZmlyZSB0YXAgd2hlbiBkZWx0YSBwb3NpdGlvbiBjaGFuZ2VkIGJ5IG1vcmUgdGhhbiAzMCBwaXhlbHMsXHJcbiAgICAgICAgICAvLyBmb3IgaW5zdGFuY2Ugd2hlbiBtb3ZpbmcgdG8gYSBwb2ludCBhbmQgYmFjayB0byBvcmlnaW5cclxuICAgICAgICAgIGlmIChkZWx0YVggPCAzMCAmJiBkZWx0YVkgPCAzMCkge1xyXG4gICAgICAgICAgICAvLyBkZWxheSBieSBvbmUgdGljayBzbyB3ZSBjYW4gY2FuY2VsIHRoZSAndGFwJyBldmVudCBpZiAnc2Nyb2xsJyBmaXJlc1xyXG4gICAgICAgICAgICAvLyAoJ3RhcCcgZmlyZXMgYmVmb3JlICdzY3JvbGwnKVxyXG4gICAgICAgICAgICB0YXBUaW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcclxuXHJcbiAgICAgICAgICAgICAgLy8gdHJpZ2dlciB1bml2ZXJzYWwgJ3RhcCcgd2l0aCB0aGUgb3B0aW9uIHRvIGNhbmNlbFRvdWNoKClcclxuICAgICAgICAgICAgICAvLyAoY2FuY2VsVG91Y2ggY2FuY2VscyBwcm9jZXNzaW5nIG9mIHNpbmdsZSB2cyBkb3VibGUgdGFwcyBmb3IgZmFzdGVyICd0YXAnIHJlc3BvbnNlKVxyXG4gICAgICAgICAgICAgIHZhciBldmVudCA9ICQuRXZlbnQoJ3RhcCcpXHJcbiAgICAgICAgICAgICAgZXZlbnQuY2FuY2VsVG91Y2ggPSBjYW5jZWxBbGxcclxuICAgICAgICAgICAgICB0b3VjaC5lbC50cmlnZ2VyKGV2ZW50KVxyXG5cclxuICAgICAgICAgICAgICAvLyB0cmlnZ2VyIGRvdWJsZSB0YXAgaW1tZWRpYXRlbHlcclxuICAgICAgICAgICAgICBpZiAodG91Y2guaXNEb3VibGVUYXApIHtcclxuICAgICAgICAgICAgICAgIGlmICh0b3VjaC5lbCkgdG91Y2guZWwudHJpZ2dlcignZG91YmxlVGFwJylcclxuICAgICAgICAgICAgICAgIHRvdWNoID0ge31cclxuICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgIC8vIHRyaWdnZXIgc2luZ2xlIHRhcCBhZnRlciAyNTBtcyBvZiBpbmFjdGl2aXR5XHJcbiAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0b3VjaFRpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7XHJcbiAgICAgICAgICAgICAgICAgIHRvdWNoVGltZW91dCA9IG51bGxcclxuICAgICAgICAgICAgICAgICAgaWYgKHRvdWNoLmVsKSB0b3VjaC5lbC50cmlnZ2VyKCdzaW5nbGVUYXAnKVxyXG4gICAgICAgICAgICAgICAgICB0b3VjaCA9IHt9XHJcbiAgICAgICAgICAgICAgICB9LCAyNTApXHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9LCAwKVxyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdG91Y2ggPSB7fVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgZGVsdGFYID0gZGVsdGFZID0gMFxyXG5cclxuICAgICAgfSlcclxuICAgICAgLy8gd2hlbiB0aGUgYnJvd3NlciB3aW5kb3cgbG9zZXMgZm9jdXMsXHJcbiAgICAgIC8vIGZvciBleGFtcGxlIHdoZW4gYSBtb2RhbCBkaWFsb2cgaXMgc2hvd24sXHJcbiAgICAgIC8vIGNhbmNlbCBhbGwgb25nb2luZyBldmVudHNcclxuICAgICAgLm9uKCd0b3VjaGNhbmNlbCBNU1BvaW50ZXJDYW5jZWwgcG9pbnRlcmNhbmNlbCcsIGNhbmNlbEFsbClcclxuXHJcbiAgICAvLyBzY3JvbGxpbmcgdGhlIHdpbmRvdyBpbmRpY2F0ZXMgaW50ZW50aW9uIG9mIHRoZSB1c2VyXHJcbiAgICAvLyB0byBzY3JvbGwsIG5vdCB0YXAgb3Igc3dpcGUsIHNvIGNhbmNlbCBhbGwgb25nb2luZyBldmVudHNcclxuICAgICQod2luZG93KS5vbignc2Nyb2xsJywgY2FuY2VsQWxsKVxyXG4gIH0pXHJcblxyXG4gIDtbJ3N3aXBlJywgJ3N3aXBlTGVmdCcsICdzd2lwZVJpZ2h0JywgJ3N3aXBlVXAnLCAnc3dpcGVEb3duJyxcclxuICAgICdkb3VibGVUYXAnLCAndGFwJywgJ3NpbmdsZVRhcCcsICdsb25nVGFwJ10uZm9yRWFjaChmdW5jdGlvbihldmVudE5hbWUpe1xyXG4gICAgJC5mbltldmVudE5hbWVdID0gZnVuY3Rpb24oY2FsbGJhY2speyByZXR1cm4gdGhpcy5vbihldmVudE5hbWUsIGNhbGxiYWNrKSB9XHJcbiAgfSlcclxufSkoWmVwdG8pXHJcblxyXG5cclxuIShmdW5jdGlvbihmYWN0b3J5KXtcclxuICBpZih0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nKXtcclxuICAgIGRlZmluZShmYWN0b3J5KTtcclxuICB9XHJcbn0pKGZ1bmN0aW9uKHJlcXVpcmUsIGV4cG9ydHMsIG1vZHVsZSl7XHJcbiAgbW9kdWxlLmV4cG9ydHMgPSBaZXB0bztcclxufSk7XHJcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL0U6L2dpdF9wcm8vZXhwcmVzcy13ZWJwYWNrLXZ1ZS9zcmMvdXRpbC96ZXB0by5qcyJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ },
/* 27 */
/***/ function(module, exports, __webpack_require__) {

	eval("var __vue_exports__, __vue_options__\nvar __vue_styles__ = {}\n\n/* styles */\n__webpack_require__(28)\n\n/* script */\n__vue_exports__ = __webpack_require__(32)\n\n/* template */\nvar __vue_template__ = __webpack_require__(33)\n__vue_options__ = __vue_exports__ = __vue_exports__ || {}\nif (\n  typeof __vue_exports__.default === \"object\" ||\n  typeof __vue_exports__.default === \"function\"\n) {\nif (Object.keys(__vue_exports__).some(function (key) { return key !== \"default\" && key !== \"__esModule\" })) {console.error(\"named exports are not supported in *.vue files.\")}\n__vue_options__ = __vue_exports__ = __vue_exports__.default\n}\nif (typeof __vue_options__ === \"function\") {\n  __vue_options__ = __vue_options__.options\n}\n__vue_options__.__file = \"E:\\\\git_pro\\\\express-webpack-vue\\\\src\\\\components\\\\mobile\\\\DownloadBar\\\\index.vue\"\n__vue_options__.render = __vue_template__.render\n__vue_options__.staticRenderFns = __vue_template__.staticRenderFns\n__vue_options__._scopeId = \"data-v-66d4396d\"\n\n/* hot reload */\nif (false) {(function () {\n  var hotAPI = require(\"vue-loader/node_modules/vue-hot-reload-api\")\n  hotAPI.install(require(\"vue\"), false)\n  if (!hotAPI.compatible) return\n  module.hot.accept()\n  if (!module.hot.data) {\n    hotAPI.createRecord(\"data-v-66d4396d\", __vue_options__)\n  } else {\n    hotAPI.reload(\"data-v-66d4396d\", __vue_options__)\n  }\n})()}\nif (__vue_options__.functional) {console.error(\"[vue-loader] index.vue: functional components are not supported and should be defined in plain js files using render functions.\")}\n\nmodule.exports = __vue_exports__\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9tb2JpbGUvRG93bmxvYWRCYXIvaW5kZXgudnVlPzVkZTciXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0QsbURBQW1ELElBQUk7QUFDN0c7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsWUFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsaUNBQWlDOztBQUVqQyIsImZpbGUiOiIyNy5qcyIsInNvdXJjZXNDb250ZW50IjpbInZhciBfX3Z1ZV9leHBvcnRzX18sIF9fdnVlX29wdGlvbnNfX1xudmFyIF9fdnVlX3N0eWxlc19fID0ge31cblxuLyogc3R5bGVzICovXG5yZXF1aXJlKFwiISF2dWUtbG9hZGVyL25vZGVfbW9kdWxlcy92dWUtc3R5bGUtbG9hZGVyIWNzcy1sb2FkZXI/c291cmNlTWFwIXZ1ZS1sb2FkZXIvbGliL3N0eWxlLXJld3JpdGVyP2lkPWRhdGEtdi02NmQ0Mzk2ZCZzY29wZWQ9dHJ1ZSFzYXNzLWxvYWRlciEuL2luZGV4LnNjc3NcIilcblxuLyogc2NyaXB0ICovXG5fX3Z1ZV9leHBvcnRzX18gPSByZXF1aXJlKFwiISFiYWJlbC1sb2FkZXIhdnVlLWxvYWRlci9saWIvc2VsZWN0b3I/dHlwZT1zY3JpcHQmaW5kZXg9MCEuL2luZGV4LnZ1ZVwiKVxuXG4vKiB0ZW1wbGF0ZSAqL1xudmFyIF9fdnVlX3RlbXBsYXRlX18gPSByZXF1aXJlKFwiISF2dWUtbG9hZGVyL2xpYi90ZW1wbGF0ZS1jb21waWxlcj9pZD1kYXRhLXYtNjZkNDM5NmQhdnVlLWxvYWRlci9saWIvdGVtcGxhdGUtbG9hZGVyP3JhdyZlbmdpbmU9amFkZSEuL2luZGV4LmphZGVcIilcbl9fdnVlX29wdGlvbnNfXyA9IF9fdnVlX2V4cG9ydHNfXyA9IF9fdnVlX2V4cG9ydHNfXyB8fCB7fVxuaWYgKFxuICB0eXBlb2YgX192dWVfZXhwb3J0c19fLmRlZmF1bHQgPT09IFwib2JqZWN0XCIgfHxcbiAgdHlwZW9mIF9fdnVlX2V4cG9ydHNfXy5kZWZhdWx0ID09PSBcImZ1bmN0aW9uXCJcbikge1xuaWYgKE9iamVjdC5rZXlzKF9fdnVlX2V4cG9ydHNfXykuc29tZShmdW5jdGlvbiAoa2V5KSB7IHJldHVybiBrZXkgIT09IFwiZGVmYXVsdFwiICYmIGtleSAhPT0gXCJfX2VzTW9kdWxlXCIgfSkpIHtjb25zb2xlLmVycm9yKFwibmFtZWQgZXhwb3J0cyBhcmUgbm90IHN1cHBvcnRlZCBpbiAqLnZ1ZSBmaWxlcy5cIil9XG5fX3Z1ZV9vcHRpb25zX18gPSBfX3Z1ZV9leHBvcnRzX18gPSBfX3Z1ZV9leHBvcnRzX18uZGVmYXVsdFxufVxuaWYgKHR5cGVvZiBfX3Z1ZV9vcHRpb25zX18gPT09IFwiZnVuY3Rpb25cIikge1xuICBfX3Z1ZV9vcHRpb25zX18gPSBfX3Z1ZV9vcHRpb25zX18ub3B0aW9uc1xufVxuX192dWVfb3B0aW9uc19fLl9fZmlsZSA9IFwiRTpcXFxcZ2l0X3Byb1xcXFxleHByZXNzLXdlYnBhY2stdnVlXFxcXHNyY1xcXFxjb21wb25lbnRzXFxcXG1vYmlsZVxcXFxEb3dubG9hZEJhclxcXFxpbmRleC52dWVcIlxuX192dWVfb3B0aW9uc19fLnJlbmRlciA9IF9fdnVlX3RlbXBsYXRlX18ucmVuZGVyXG5fX3Z1ZV9vcHRpb25zX18uc3RhdGljUmVuZGVyRm5zID0gX192dWVfdGVtcGxhdGVfXy5zdGF0aWNSZW5kZXJGbnNcbl9fdnVlX29wdGlvbnNfXy5fc2NvcGVJZCA9IFwiZGF0YS12LTY2ZDQzOTZkXCJcblxuLyogaG90IHJlbG9hZCAqL1xuaWYgKG1vZHVsZS5ob3QpIHsoZnVuY3Rpb24gKCkge1xuICB2YXIgaG90QVBJID0gcmVxdWlyZShcInZ1ZS1sb2FkZXIvbm9kZV9tb2R1bGVzL3Z1ZS1ob3QtcmVsb2FkLWFwaVwiKVxuICBob3RBUEkuaW5zdGFsbChyZXF1aXJlKFwidnVlXCIpLCBmYWxzZSlcbiAgaWYgKCFob3RBUEkuY29tcGF0aWJsZSkgcmV0dXJuXG4gIG1vZHVsZS5ob3QuYWNjZXB0KClcbiAgaWYgKCFtb2R1bGUuaG90LmRhdGEpIHtcbiAgICBob3RBUEkuY3JlYXRlUmVjb3JkKFwiZGF0YS12LTY2ZDQzOTZkXCIsIF9fdnVlX29wdGlvbnNfXylcbiAgfSBlbHNlIHtcbiAgICBob3RBUEkucmVsb2FkKFwiZGF0YS12LTY2ZDQzOTZkXCIsIF9fdnVlX29wdGlvbnNfXylcbiAgfVxufSkoKX1cbmlmIChfX3Z1ZV9vcHRpb25zX18uZnVuY3Rpb25hbCkge2NvbnNvbGUuZXJyb3IoXCJbdnVlLWxvYWRlcl0gaW5kZXgudnVlOiBmdW5jdGlvbmFsIGNvbXBvbmVudHMgYXJlIG5vdCBzdXBwb3J0ZWQgYW5kIHNob3VsZCBiZSBkZWZpbmVkIGluIHBsYWluIGpzIGZpbGVzIHVzaW5nIHJlbmRlciBmdW5jdGlvbnMuXCIpfVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9fdnVlX2V4cG9ydHNfX1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvY29tcG9uZW50cy9tb2JpbGUvRG93bmxvYWRCYXIvaW5kZXgudnVlXG4vLyBtb2R1bGUgaWQgPSAyN1xuLy8gbW9kdWxlIGNodW5rcyA9IDEiXSwic291cmNlUm9vdCI6IiJ9");

/***/ },
/* 28 */
/***/ function(module, exports, __webpack_require__) {

	eval("// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = __webpack_require__(29);\nif(typeof content === 'string') content = [[module.id, content, '']];\n// add the styles to the DOM\nvar update = __webpack_require__(7)(content, {});\nif(content.locals) module.exports = content.locals;\n// Hot Module Replacement\nif(false) {\n\t// When the styles change, update the <style> tags\n\tif(!content.locals) {\n\t\tmodule.hot.accept(\"!!./../../../../node_modules/.0.25.0@css-loader/index.js?sourceMap!./../../../../node_modules/.9.9.5@vue-loader/lib/style-rewriter.js?id=data-v-66d4396d&scoped=true!./../../../../node_modules/.4.0.2@sass-loader/index.js!./index.scss\", function() {\n\t\t\tvar newContent = require(\"!!./../../../../node_modules/.0.25.0@css-loader/index.js?sourceMap!./../../../../node_modules/.9.9.5@vue-loader/lib/style-rewriter.js?id=data-v-66d4396d&scoped=true!./../../../../node_modules/.4.0.2@sass-loader/index.js!./index.scss\");\n\t\t\tif(typeof newContent === 'string') newContent = [[module.id, newContent, '']];\n\t\t\tupdate(newContent);\n\t\t});\n\t}\n\t// When the module is disposed, remove the <style> tags\n\tmodule.hot.dispose(function() { update(); });\n}//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9tb2JpbGUvRG93bmxvYWRCYXIvaW5kZXguc2Nzcz9hMzYyIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQW9HO0FBQ3BHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsZ0NBQWdDLFVBQVUsRUFBRTtBQUM1QyIsImZpbGUiOiIyOC5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIHN0eWxlLWxvYWRlcjogQWRkcyBzb21lIGNzcyB0byB0aGUgRE9NIGJ5IGFkZGluZyBhIDxzdHlsZT4gdGFnXG5cbi8vIGxvYWQgdGhlIHN0eWxlc1xudmFyIGNvbnRlbnQgPSByZXF1aXJlKFwiISEuLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy8uMC4yNS4wQGNzcy1sb2FkZXIvaW5kZXguanM/c291cmNlTWFwIS4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy45LjkuNUB2dWUtbG9hZGVyL2xpYi9zdHlsZS1yZXdyaXRlci5qcz9pZD1kYXRhLXYtNjZkNDM5NmQmc2NvcGVkPXRydWUhLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvLjQuMC4yQHNhc3MtbG9hZGVyL2luZGV4LmpzIS4vaW5kZXguc2Nzc1wiKTtcbmlmKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykgY29udGVudCA9IFtbbW9kdWxlLmlkLCBjb250ZW50LCAnJ11dO1xuLy8gYWRkIHRoZSBzdHlsZXMgdG8gdGhlIERPTVxudmFyIHVwZGF0ZSA9IHJlcXVpcmUoXCIhLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvLjEuMC4wQHZ1ZS1zdHlsZS1sb2FkZXIvYWRkU3R5bGVzLmpzXCIpKGNvbnRlbnQsIHt9KTtcbmlmKGNvbnRlbnQubG9jYWxzKSBtb2R1bGUuZXhwb3J0cyA9IGNvbnRlbnQubG9jYWxzO1xuLy8gSG90IE1vZHVsZSBSZXBsYWNlbWVudFxuaWYobW9kdWxlLmhvdCkge1xuXHQvLyBXaGVuIHRoZSBzdHlsZXMgY2hhbmdlLCB1cGRhdGUgdGhlIDxzdHlsZT4gdGFnc1xuXHRpZighY29udGVudC5sb2NhbHMpIHtcblx0XHRtb2R1bGUuaG90LmFjY2VwdChcIiEhLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvLjAuMjUuMEBjc3MtbG9hZGVyL2luZGV4LmpzP3NvdXJjZU1hcCEuLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy8uOS45LjVAdnVlLWxvYWRlci9saWIvc3R5bGUtcmV3cml0ZXIuanM/aWQ9ZGF0YS12LTY2ZDQzOTZkJnNjb3BlZD10cnVlIS4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy40LjAuMkBzYXNzLWxvYWRlci9pbmRleC5qcyEuL2luZGV4LnNjc3NcIiwgZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgbmV3Q29udGVudCA9IHJlcXVpcmUoXCIhIS4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy4wLjI1LjBAY3NzLWxvYWRlci9pbmRleC5qcz9zb3VyY2VNYXAhLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvLjkuOS41QHZ1ZS1sb2FkZXIvbGliL3N0eWxlLXJld3JpdGVyLmpzP2lkPWRhdGEtdi02NmQ0Mzk2ZCZzY29wZWQ9dHJ1ZSEuLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy8uNC4wLjJAc2Fzcy1sb2FkZXIvaW5kZXguanMhLi9pbmRleC5zY3NzXCIpO1xuXHRcdFx0aWYodHlwZW9mIG5ld0NvbnRlbnQgPT09ICdzdHJpbmcnKSBuZXdDb250ZW50ID0gW1ttb2R1bGUuaWQsIG5ld0NvbnRlbnQsICcnXV07XG5cdFx0XHR1cGRhdGUobmV3Q29udGVudCk7XG5cdFx0fSk7XG5cdH1cblx0Ly8gV2hlbiB0aGUgbW9kdWxlIGlzIGRpc3Bvc2VkLCByZW1vdmUgdGhlIDxzdHlsZT4gdGFnc1xuXHRtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24oKSB7IHVwZGF0ZSgpOyB9KTtcbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vLjEuMC4wQHZ1ZS1zdHlsZS1sb2FkZXIhLi9+Ly4wLjI1LjBAY3NzLWxvYWRlcj9zb3VyY2VNYXAhLi9+Ly45LjkuNUB2dWUtbG9hZGVyL2xpYi9zdHlsZS1yZXdyaXRlci5qcz9pZD1kYXRhLXYtNjZkNDM5NmQmc2NvcGVkPXRydWUhLi9+Ly40LjAuMkBzYXNzLWxvYWRlciEuL3NyYy9jb21wb25lbnRzL21vYmlsZS9Eb3dubG9hZEJhci9pbmRleC5zY3NzXG4vLyBtb2R1bGUgaWQgPSAyOFxuLy8gbW9kdWxlIGNodW5rcyA9IDEiXSwic291cmNlUm9vdCI6IiJ9");

/***/ },
/* 29 */
/***/ function(module, exports, __webpack_require__) {

	eval("exports = module.exports = __webpack_require__(6)();\n// imports\n\n\n// module\nexports.push([module.id, \"\\n.download-bar[data-v-66d4396d] {\\n  width: 100%;\\n  height: 1.4rem;\\n  background: #000;\\n  position: fixed;\\n  left: 0;\\n  bottom: 0;\\n  display: -webkit-box;\\n  overflow: hidden;\\n  -webkit-box-align: center;\\n  z-index: 5;\\n}\\n.download-bar .logo[data-v-66d4396d] {\\n    width: .94rem;\\n    height: .94rem;\\n    margin-left: .2rem;\\n    background: url(\" + __webpack_require__(30) + \") no-repeat;\\n    background-size: 100%;\\n}\\n.download-bar .ip-name[data-v-66d4396d] {\\n    font-size: .38rem;\\n    font-weight: 700;\\n    margin-left: .2rem;\\n    line-height: .47rem;\\n    color: #fff;\\n}\\n.download-bar .content[data-v-66d4396d] {\\n    line-height: .47rem;\\n    color: #ffaf1a;\\n    margin-left: .22rem;\\n    font-size: .38rem;\\n    font-weight: 700;\\n    padding-left: .22rem;\\n    border-left: 1px solid #fff;\\n    -webkit-box-flex: 1;\\n}\\n.download-bar .btn[data-v-66d4396d] {\\n    width: 2.52rem;\\n    height: 1.4rem;\\n    background: url(\" + __webpack_require__(31) + \") no-repeat;\\n    background-size: 100%;\\n    display: block;\\n}\\n.download-guide[data-v-66d4396d] {\\n  width: 100%;\\n  height: 100%;\\n  position: fixed;\\n  top: 0;\\n  left: 0;\\n  background: rgba(0, 0, 0, 0.8);\\n  z-index: 10;\\n  display: none;\\n}\\n.download-guide .container[data-v-66d4396d] {\\n    position: absolute;\\n    top: 0;\\n    right: .23rem;\\n    padding-top: .23rem;\\n}\\n.download-guide .container .content[data-v-66d4396d] {\\n      padding-left: .66rem;\\n      padding-right: .16rem;\\n      height: .5rem;\\n      line-height: .5rem;\\n      border-radius: .05rem;\\n      background: #ffaf1a;\\n      font-size: .24rem;\\n}\\n\", \"\", {\"version\":3,\"sources\":[\"/./src/components/mobile/DownloadBar/index.scss\"],\"names\":[],\"mappings\":\";AAAA;EACE,YAAY;EACZ,eAAe;EACf,iBAAiB;EACjB,gBAAgB;EAChB,QAAQ;EACR,UAAU;EACV,qBAAqB;EACrB,iBAAiB;EACjB,0BAA0B;EAC1B,WAAW;CAAE;AACb;IACE,cAAc;IACd,eAAe;IACf,mBAAmB;IACnB,oDAA6C;IAC7C,sBAAsB;CAAE;AAC1B;IACE,kBAAkB;IAClB,iBAAiB;IACjB,mBAAmB;IACnB,oBAAoB;IACpB,YAAY;CAAE;AAChB;IACE,oBAAoB;IACpB,eAAe;IACf,oBAAoB;IACpB,kBAAkB;IAClB,iBAAiB;IACjB,qBAAqB;IACrB,4BAA4B;IAC5B,oBAAoB;CAAE;AACxB;IACE,eAAe;IACf,eAAe;IACf,oDAAqD;IACrD,sBAAsB;IACtB,eAAe;CAAE;AAErB;EACE,YAAY;EACZ,aAAa;EACb,gBAAgB;EAChB,OAAO;EACP,QAAQ;EACR,+BAA+B;EAC/B,YAAY;EACZ,cAAc;CAAE;AAChB;IACE,mBAAmB;IACnB,OAAO;IACP,cAAc;IACd,oBAAoB;CAAE;AACtB;MACE,qBAAqB;MACrB,sBAAsB;MACtB,cAAc;MACd,mBAAmB;MACnB,sBAAsB;MACtB,oBAAoB;MACpB,kBAAkB;CAAE\",\"file\":\"index.scss\",\"sourcesContent\":[\".download-bar {\\n  width: 100%;\\n  height: 1.4rem;\\n  background: #000;\\n  position: fixed;\\n  left: 0;\\n  bottom: 0;\\n  display: -webkit-box;\\n  overflow: hidden;\\n  -webkit-box-align: center;\\n  z-index: 5; }\\n  .download-bar .logo {\\n    width: .94rem;\\n    height: .94rem;\\n    margin-left: .2rem;\\n    background: url(./images/logo.png) no-repeat;\\n    background-size: 100%; }\\n  .download-bar .ip-name {\\n    font-size: .38rem;\\n    font-weight: 700;\\n    margin-left: .2rem;\\n    line-height: .47rem;\\n    color: #fff; }\\n  .download-bar .content {\\n    line-height: .47rem;\\n    color: #ffaf1a;\\n    margin-left: .22rem;\\n    font-size: .38rem;\\n    font-weight: 700;\\n    padding-left: .22rem;\\n    border-left: 1px solid #fff;\\n    -webkit-box-flex: 1; }\\n  .download-bar .btn {\\n    width: 2.52rem;\\n    height: 1.4rem;\\n    background: url(./images/download-btn.gif) no-repeat;\\n    background-size: 100%;\\n    display: block; }\\n\\n.download-guide {\\n  width: 100%;\\n  height: 100%;\\n  position: fixed;\\n  top: 0;\\n  left: 0;\\n  background: rgba(0, 0, 0, 0.8);\\n  z-index: 10;\\n  display: none; }\\n  .download-guide .container {\\n    position: absolute;\\n    top: 0;\\n    right: .23rem;\\n    padding-top: .23rem; }\\n    .download-guide .container .content {\\n      padding-left: .66rem;\\n      padding-right: .16rem;\\n      height: .5rem;\\n      line-height: .5rem;\\n      border-radius: .05rem;\\n      background: #ffaf1a;\\n      font-size: .24rem; }\\n\"],\"sourceRoot\":\"webpack://\"}]);\n\n// exports\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9tb2JpbGUvRG93bmxvYWRCYXIvaW5kZXguc2Nzcz80NmQ3Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7OztBQUdBO0FBQ0EsNERBQTRELGdCQUFnQixtQkFBbUIscUJBQXFCLG9CQUFvQixZQUFZLGNBQWMseUJBQXlCLHFCQUFxQiw4QkFBOEIsZUFBZSxHQUFHLHdDQUF3QyxvQkFBb0IscUJBQXFCLHlCQUF5QixpRUFBc0UsNEJBQTRCLEdBQUcsMkNBQTJDLHdCQUF3Qix1QkFBdUIseUJBQXlCLDBCQUEwQixrQkFBa0IsR0FBRywyQ0FBMkMsMEJBQTBCLHFCQUFxQiwwQkFBMEIsd0JBQXdCLHVCQUF1QiwyQkFBMkIsa0NBQWtDLDBCQUEwQixHQUFHLHVDQUF1QyxxQkFBcUIscUJBQXFCLGlFQUE4RSw0QkFBNEIscUJBQXFCLEdBQUcsb0NBQW9DLGdCQUFnQixpQkFBaUIsb0JBQW9CLFdBQVcsWUFBWSxtQ0FBbUMsZ0JBQWdCLGtCQUFrQixHQUFHLCtDQUErQyx5QkFBeUIsYUFBYSxvQkFBb0IsMEJBQTBCLEdBQUcsd0RBQXdELDZCQUE2Qiw4QkFBOEIsc0JBQXNCLDJCQUEyQiw4QkFBOEIsNEJBQTRCLDBCQUEwQixHQUFHLFVBQVUsa0dBQWtHLEtBQUssVUFBVSxVQUFVLFlBQVksYUFBYSxXQUFXLFVBQVUsWUFBWSxhQUFhLGFBQWEsV0FBVyxLQUFLLEtBQUssVUFBVSxVQUFVLFlBQVksYUFBYSxhQUFhLEtBQUssTUFBTSxZQUFZLGFBQWEsYUFBYSxhQUFhLFdBQVcsS0FBSyxNQUFNLFlBQVksV0FBVyxZQUFZLGFBQWEsYUFBYSxhQUFhLGFBQWEsYUFBYSxLQUFLLE1BQU0sVUFBVSxVQUFVLFlBQVksYUFBYSxXQUFXLEtBQUssTUFBTSxVQUFVLFVBQVUsWUFBWSxXQUFXLFVBQVUsWUFBWSxXQUFXLFVBQVUsS0FBSyxNQUFNLFlBQVksV0FBVyxVQUFVLFlBQVksS0FBSyxNQUFNLFlBQVksYUFBYSxXQUFXLFlBQVksYUFBYSxhQUFhLGFBQWEsNERBQTRELGdCQUFnQixtQkFBbUIscUJBQXFCLG9CQUFvQixZQUFZLGNBQWMseUJBQXlCLHFCQUFxQiw4QkFBOEIsZUFBZSxFQUFFLHlCQUF5QixvQkFBb0IscUJBQXFCLHlCQUF5QixtREFBbUQsNEJBQTRCLEVBQUUsNEJBQTRCLHdCQUF3Qix1QkFBdUIseUJBQXlCLDBCQUEwQixrQkFBa0IsRUFBRSw0QkFBNEIsMEJBQTBCLHFCQUFxQiwwQkFBMEIsd0JBQXdCLHVCQUF1QiwyQkFBMkIsa0NBQWtDLDBCQUEwQixFQUFFLHdCQUF3QixxQkFBcUIscUJBQXFCLDJEQUEyRCw0QkFBNEIscUJBQXFCLEVBQUUscUJBQXFCLGdCQUFnQixpQkFBaUIsb0JBQW9CLFdBQVcsWUFBWSxtQ0FBbUMsZ0JBQWdCLGtCQUFrQixFQUFFLGdDQUFnQyx5QkFBeUIsYUFBYSxvQkFBb0IsMEJBQTBCLEVBQUUsMkNBQTJDLDZCQUE2Qiw4QkFBOEIsc0JBQXNCLDJCQUEyQiw4QkFBOEIsNEJBQTRCLDBCQUEwQixFQUFFLCtCQUErQjs7QUFFNTVIIiwiZmlsZSI6IjI5LmpzIiwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzLy4wLjI1LjBAY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanNcIikoKTtcbi8vIGltcG9ydHNcblxuXG4vLyBtb2R1bGVcbmV4cG9ydHMucHVzaChbbW9kdWxlLmlkLCBcIlxcbi5kb3dubG9hZC1iYXJbZGF0YS12LTY2ZDQzOTZkXSB7XFxuICB3aWR0aDogMTAwJTtcXG4gIGhlaWdodDogMS40cmVtO1xcbiAgYmFja2dyb3VuZDogIzAwMDtcXG4gIHBvc2l0aW9uOiBmaXhlZDtcXG4gIGxlZnQ6IDA7XFxuICBib3R0b206IDA7XFxuICBkaXNwbGF5OiAtd2Via2l0LWJveDtcXG4gIG92ZXJmbG93OiBoaWRkZW47XFxuICAtd2Via2l0LWJveC1hbGlnbjogY2VudGVyO1xcbiAgei1pbmRleDogNTtcXG59XFxuLmRvd25sb2FkLWJhciAubG9nb1tkYXRhLXYtNjZkNDM5NmRdIHtcXG4gICAgd2lkdGg6IC45NHJlbTtcXG4gICAgaGVpZ2h0OiAuOTRyZW07XFxuICAgIG1hcmdpbi1sZWZ0OiAuMnJlbTtcXG4gICAgYmFja2dyb3VuZDogdXJsKFwiICsgcmVxdWlyZShcIi4vaW1hZ2VzL2xvZ28ucG5nXCIpICsgXCIpIG5vLXJlcGVhdDtcXG4gICAgYmFja2dyb3VuZC1zaXplOiAxMDAlO1xcbn1cXG4uZG93bmxvYWQtYmFyIC5pcC1uYW1lW2RhdGEtdi02NmQ0Mzk2ZF0ge1xcbiAgICBmb250LXNpemU6IC4zOHJlbTtcXG4gICAgZm9udC13ZWlnaHQ6IDcwMDtcXG4gICAgbWFyZ2luLWxlZnQ6IC4ycmVtO1xcbiAgICBsaW5lLWhlaWdodDogLjQ3cmVtO1xcbiAgICBjb2xvcjogI2ZmZjtcXG59XFxuLmRvd25sb2FkLWJhciAuY29udGVudFtkYXRhLXYtNjZkNDM5NmRdIHtcXG4gICAgbGluZS1oZWlnaHQ6IC40N3JlbTtcXG4gICAgY29sb3I6ICNmZmFmMWE7XFxuICAgIG1hcmdpbi1sZWZ0OiAuMjJyZW07XFxuICAgIGZvbnQtc2l6ZTogLjM4cmVtO1xcbiAgICBmb250LXdlaWdodDogNzAwO1xcbiAgICBwYWRkaW5nLWxlZnQ6IC4yMnJlbTtcXG4gICAgYm9yZGVyLWxlZnQ6IDFweCBzb2xpZCAjZmZmO1xcbiAgICAtd2Via2l0LWJveC1mbGV4OiAxO1xcbn1cXG4uZG93bmxvYWQtYmFyIC5idG5bZGF0YS12LTY2ZDQzOTZkXSB7XFxuICAgIHdpZHRoOiAyLjUycmVtO1xcbiAgICBoZWlnaHQ6IDEuNHJlbTtcXG4gICAgYmFja2dyb3VuZDogdXJsKFwiICsgcmVxdWlyZShcIi4vaW1hZ2VzL2Rvd25sb2FkLWJ0bi5naWZcIikgKyBcIikgbm8tcmVwZWF0O1xcbiAgICBiYWNrZ3JvdW5kLXNpemU6IDEwMCU7XFxuICAgIGRpc3BsYXk6IGJsb2NrO1xcbn1cXG4uZG93bmxvYWQtZ3VpZGVbZGF0YS12LTY2ZDQzOTZkXSB7XFxuICB3aWR0aDogMTAwJTtcXG4gIGhlaWdodDogMTAwJTtcXG4gIHBvc2l0aW9uOiBmaXhlZDtcXG4gIHRvcDogMDtcXG4gIGxlZnQ6IDA7XFxuICBiYWNrZ3JvdW5kOiByZ2JhKDAsIDAsIDAsIDAuOCk7XFxuICB6LWluZGV4OiAxMDtcXG4gIGRpc3BsYXk6IG5vbmU7XFxufVxcbi5kb3dubG9hZC1ndWlkZSAuY29udGFpbmVyW2RhdGEtdi02NmQ0Mzk2ZF0ge1xcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICAgIHRvcDogMDtcXG4gICAgcmlnaHQ6IC4yM3JlbTtcXG4gICAgcGFkZGluZy10b3A6IC4yM3JlbTtcXG59XFxuLmRvd25sb2FkLWd1aWRlIC5jb250YWluZXIgLmNvbnRlbnRbZGF0YS12LTY2ZDQzOTZkXSB7XFxuICAgICAgcGFkZGluZy1sZWZ0OiAuNjZyZW07XFxuICAgICAgcGFkZGluZy1yaWdodDogLjE2cmVtO1xcbiAgICAgIGhlaWdodDogLjVyZW07XFxuICAgICAgbGluZS1oZWlnaHQ6IC41cmVtO1xcbiAgICAgIGJvcmRlci1yYWRpdXM6IC4wNXJlbTtcXG4gICAgICBiYWNrZ3JvdW5kOiAjZmZhZjFhO1xcbiAgICAgIGZvbnQtc2l6ZTogLjI0cmVtO1xcbn1cXG5cIiwgXCJcIiwge1widmVyc2lvblwiOjMsXCJzb3VyY2VzXCI6W1wiLy4vc3JjL2NvbXBvbmVudHMvbW9iaWxlL0Rvd25sb2FkQmFyL2luZGV4LnNjc3NcIl0sXCJuYW1lc1wiOltdLFwibWFwcGluZ3NcIjpcIjtBQUFBO0VBQ0UsWUFBWTtFQUNaLGVBQWU7RUFDZixpQkFBaUI7RUFDakIsZ0JBQWdCO0VBQ2hCLFFBQVE7RUFDUixVQUFVO0VBQ1YscUJBQXFCO0VBQ3JCLGlCQUFpQjtFQUNqQiwwQkFBMEI7RUFDMUIsV0FBVztDQUFFO0FBQ2I7SUFDRSxjQUFjO0lBQ2QsZUFBZTtJQUNmLG1CQUFtQjtJQUNuQixvREFBNkM7SUFDN0Msc0JBQXNCO0NBQUU7QUFDMUI7SUFDRSxrQkFBa0I7SUFDbEIsaUJBQWlCO0lBQ2pCLG1CQUFtQjtJQUNuQixvQkFBb0I7SUFDcEIsWUFBWTtDQUFFO0FBQ2hCO0lBQ0Usb0JBQW9CO0lBQ3BCLGVBQWU7SUFDZixvQkFBb0I7SUFDcEIsa0JBQWtCO0lBQ2xCLGlCQUFpQjtJQUNqQixxQkFBcUI7SUFDckIsNEJBQTRCO0lBQzVCLG9CQUFvQjtDQUFFO0FBQ3hCO0lBQ0UsZUFBZTtJQUNmLGVBQWU7SUFDZixvREFBcUQ7SUFDckQsc0JBQXNCO0lBQ3RCLGVBQWU7Q0FBRTtBQUVyQjtFQUNFLFlBQVk7RUFDWixhQUFhO0VBQ2IsZ0JBQWdCO0VBQ2hCLE9BQU87RUFDUCxRQUFRO0VBQ1IsK0JBQStCO0VBQy9CLFlBQVk7RUFDWixjQUFjO0NBQUU7QUFDaEI7SUFDRSxtQkFBbUI7SUFDbkIsT0FBTztJQUNQLGNBQWM7SUFDZCxvQkFBb0I7Q0FBRTtBQUN0QjtNQUNFLHFCQUFxQjtNQUNyQixzQkFBc0I7TUFDdEIsY0FBYztNQUNkLG1CQUFtQjtNQUNuQixzQkFBc0I7TUFDdEIsb0JBQW9CO01BQ3BCLGtCQUFrQjtDQUFFXCIsXCJmaWxlXCI6XCJpbmRleC5zY3NzXCIsXCJzb3VyY2VzQ29udGVudFwiOltcIi5kb3dubG9hZC1iYXIge1xcbiAgd2lkdGg6IDEwMCU7XFxuICBoZWlnaHQ6IDEuNHJlbTtcXG4gIGJhY2tncm91bmQ6ICMwMDA7XFxuICBwb3NpdGlvbjogZml4ZWQ7XFxuICBsZWZ0OiAwO1xcbiAgYm90dG9tOiAwO1xcbiAgZGlzcGxheTogLXdlYmtpdC1ib3g7XFxuICBvdmVyZmxvdzogaGlkZGVuO1xcbiAgLXdlYmtpdC1ib3gtYWxpZ246IGNlbnRlcjtcXG4gIHotaW5kZXg6IDU7IH1cXG4gIC5kb3dubG9hZC1iYXIgLmxvZ28ge1xcbiAgICB3aWR0aDogLjk0cmVtO1xcbiAgICBoZWlnaHQ6IC45NHJlbTtcXG4gICAgbWFyZ2luLWxlZnQ6IC4ycmVtO1xcbiAgICBiYWNrZ3JvdW5kOiB1cmwoLi9pbWFnZXMvbG9nby5wbmcpIG5vLXJlcGVhdDtcXG4gICAgYmFja2dyb3VuZC1zaXplOiAxMDAlOyB9XFxuICAuZG93bmxvYWQtYmFyIC5pcC1uYW1lIHtcXG4gICAgZm9udC1zaXplOiAuMzhyZW07XFxuICAgIGZvbnQtd2VpZ2h0OiA3MDA7XFxuICAgIG1hcmdpbi1sZWZ0OiAuMnJlbTtcXG4gICAgbGluZS1oZWlnaHQ6IC40N3JlbTtcXG4gICAgY29sb3I6ICNmZmY7IH1cXG4gIC5kb3dubG9hZC1iYXIgLmNvbnRlbnQge1xcbiAgICBsaW5lLWhlaWdodDogLjQ3cmVtO1xcbiAgICBjb2xvcjogI2ZmYWYxYTtcXG4gICAgbWFyZ2luLWxlZnQ6IC4yMnJlbTtcXG4gICAgZm9udC1zaXplOiAuMzhyZW07XFxuICAgIGZvbnQtd2VpZ2h0OiA3MDA7XFxuICAgIHBhZGRpbmctbGVmdDogLjIycmVtO1xcbiAgICBib3JkZXItbGVmdDogMXB4IHNvbGlkICNmZmY7XFxuICAgIC13ZWJraXQtYm94LWZsZXg6IDE7IH1cXG4gIC5kb3dubG9hZC1iYXIgLmJ0biB7XFxuICAgIHdpZHRoOiAyLjUycmVtO1xcbiAgICBoZWlnaHQ6IDEuNHJlbTtcXG4gICAgYmFja2dyb3VuZDogdXJsKC4vaW1hZ2VzL2Rvd25sb2FkLWJ0bi5naWYpIG5vLXJlcGVhdDtcXG4gICAgYmFja2dyb3VuZC1zaXplOiAxMDAlO1xcbiAgICBkaXNwbGF5OiBibG9jazsgfVxcblxcbi5kb3dubG9hZC1ndWlkZSB7XFxuICB3aWR0aDogMTAwJTtcXG4gIGhlaWdodDogMTAwJTtcXG4gIHBvc2l0aW9uOiBmaXhlZDtcXG4gIHRvcDogMDtcXG4gIGxlZnQ6IDA7XFxuICBiYWNrZ3JvdW5kOiByZ2JhKDAsIDAsIDAsIDAuOCk7XFxuICB6LWluZGV4OiAxMDtcXG4gIGRpc3BsYXk6IG5vbmU7IH1cXG4gIC5kb3dubG9hZC1ndWlkZSAuY29udGFpbmVyIHtcXG4gICAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgICB0b3A6IDA7XFxuICAgIHJpZ2h0OiAuMjNyZW07XFxuICAgIHBhZGRpbmctdG9wOiAuMjNyZW07IH1cXG4gICAgLmRvd25sb2FkLWd1aWRlIC5jb250YWluZXIgLmNvbnRlbnQge1xcbiAgICAgIHBhZGRpbmctbGVmdDogLjY2cmVtO1xcbiAgICAgIHBhZGRpbmctcmlnaHQ6IC4xNnJlbTtcXG4gICAgICBoZWlnaHQ6IC41cmVtO1xcbiAgICAgIGxpbmUtaGVpZ2h0OiAuNXJlbTtcXG4gICAgICBib3JkZXItcmFkaXVzOiAuMDVyZW07XFxuICAgICAgYmFja2dyb3VuZDogI2ZmYWYxYTtcXG4gICAgICBmb250LXNpemU6IC4yNHJlbTsgfVxcblwiXSxcInNvdXJjZVJvb3RcIjpcIndlYnBhY2s6Ly9cIn1dKTtcblxuLy8gZXhwb3J0c1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+Ly4wLjI1LjBAY3NzLWxvYWRlcj9zb3VyY2VNYXAhLi9+Ly45LjkuNUB2dWUtbG9hZGVyL2xpYi9zdHlsZS1yZXdyaXRlci5qcz9pZD1kYXRhLXYtNjZkNDM5NmQmc2NvcGVkPXRydWUhLi9+Ly40LjAuMkBzYXNzLWxvYWRlciEuL3NyYy9jb21wb25lbnRzL21vYmlsZS9Eb3dubG9hZEJhci9pbmRleC5zY3NzXG4vLyBtb2R1bGUgaWQgPSAyOVxuLy8gbW9kdWxlIGNodW5rcyA9IDEiXSwic291cmNlUm9vdCI6IiJ9");

/***/ },
/* 30 */
/***/ function(module, exports, __webpack_require__) {

	eval("module.exports = __webpack_require__.p + \"/images/logo-050e53833b7e21639f84108336fc29ab.png\";//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9tb2JpbGUvRG93bmxvYWRCYXIvaW1hZ2VzL2xvZ28ucG5nP2EyMjYiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEiLCJmaWxlIjoiMzAuanMiLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IF9fd2VicGFja19wdWJsaWNfcGF0aF9fICsgXCIvaW1hZ2VzL2xvZ28tMDUwZTUzODMzYjdlMjE2MzlmODQxMDgzMzZmYzI5YWIucG5nXCI7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvY29tcG9uZW50cy9tb2JpbGUvRG93bmxvYWRCYXIvaW1hZ2VzL2xvZ28ucG5nXG4vLyBtb2R1bGUgaWQgPSAzMFxuLy8gbW9kdWxlIGNodW5rcyA9IDEiXSwic291cmNlUm9vdCI6IiJ9");

/***/ },
/* 31 */
/***/ function(module, exports, __webpack_require__) {

	eval("module.exports = __webpack_require__.p + \"/images/download-btn-c78d107a8b51cf4c4221c4cacbe73462.gif\";//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9tb2JpbGUvRG93bmxvYWRCYXIvaW1hZ2VzL2Rvd25sb2FkLWJ0bi5naWY/YmQ0YyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSIsImZpbGUiOiIzMS5qcyIsInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gX193ZWJwYWNrX3B1YmxpY19wYXRoX18gKyBcIi9pbWFnZXMvZG93bmxvYWQtYnRuLWM3OGQxMDdhOGI1MWNmNGM0MjIxYzRjYWNiZTczNDYyLmdpZlwiO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL2NvbXBvbmVudHMvbW9iaWxlL0Rvd25sb2FkQmFyL2ltYWdlcy9kb3dubG9hZC1idG4uZ2lmXG4vLyBtb2R1bGUgaWQgPSAzMVxuLy8gbW9kdWxlIGNodW5rcyA9IDEiXSwic291cmNlUm9vdCI6IiJ9");

/***/ },
/* 32 */
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _native = __webpack_require__(18);\n\nvar _native2 = _interopRequireDefault(_native);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nexports.default = {\n    name: 'download-bar',\n    methods: {\n        download: function download() {\n            _native2.default.download('404页面');\n        }\n    },\n    props: ['msg']\n}; //\n////# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vaW5kZXgudnVlP2U1MTYiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBSUE7Ozs7Ozs7VUFFQTs7c0NBRUE7c0NBQ0E7QUFFQTtBQUpBO1lBS0E7QUFQQSIsImZpbGUiOiIzMi5qcyIsInNvdXJjZXNDb250ZW50IjpbIjx0ZW1wbGF0ZSBsYW5nPVwiamFkZVwiIHNyYz1cIi4vaW5kZXguamFkZVwiPjwvdGVtcGxhdGU+XG48L3RlbXBsYXRlPlxuPHNjcmlwdD5cbmltcG9ydCBuYXRpdmUgZnJvbSAnLi4vLi4vLi4vdXRpbC9uYXRpdmUnO1xuICAgIGV4cG9ydCBkZWZhdWx0IHtcbiAgICAgICAgbmFtZTogJ2Rvd25sb2FkLWJhcicsXG4gICAgICAgIG1ldGhvZHM6IHtcbiAgICAgICAgICAgIGRvd25sb2FkKCkge1xuICAgICAgICAgICAgICAgIG5hdGl2ZS5kb3dubG9hZCgnNDA06aG16Z2iJylcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgcHJvcHM6IFsnbXNnJ11cbiAgICB9XG48L3NjcmlwdD5cbjxzdHlsZSBzY29wZWQgbGFuZz1cInNhc3NcIiBzcmM9XCIuL2luZGV4LnNjc3NcIj48L3N0eWxlPlxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIGluZGV4LnZ1ZT9jYTk3OTQxNiJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ },
/* 33 */
/***/ function(module, exports, __webpack_require__) {

	eval("module.exports={render:function (){var _vm=this;\n  return _vm._h('div', [_vm._h('div', {\n    staticClass: \"download-bar\"\n  }, [_vm._h('div', {\n    staticClass: \"logo\"\n  }), _vm._m(0), _vm._m(1), _vm._h('div', {\n    staticClass: \"btn\",\n    on: {\n      \"click\": _vm.download\n    }\n  })]), _vm._m(2)])\n},staticRenderFns: [function (){var _vm=this;\n  return _vm._h('div', {\n    staticClass: \"ip-name\"\n  }, [\"网易\", _vm._h('br'), \"菠萝\"])\n},function (){var _vm=this;\n  return _vm._h('div', {\n    staticClass: \"content\"\n  }, [\"双手下载\", _vm._h('br'), \"以示清白\"])\n},function (){var _vm=this;\n  return _vm._h('div', {\n    staticClass: \"download-guide\"\n  }, [_vm._h('div', {\n    staticClass: \"container\"\n  }, [_vm._h('div', {\n    staticClass: \"content\"\n  }, [\"请点击这里使用浏览器打开\"]), _vm._h('div', {\n    staticClass: \"triangle\"\n  }), _vm._h('div', {\n    staticClass: \"icon\"\n  })])])\n}]}\nif (false) {\n  module.hot.accept()\n  if (module.hot.data) {\n     require(\"vue-loader/node_modules/vue-hot-reload-api\").rerender(\"data-v-66d4396d\", module.exports)\n  }\n}//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9tb2JpbGUvRG93bmxvYWRCYXIvaW5kZXguamFkZT81MWI5Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLGdCQUFnQixtQkFBbUI7QUFDbkM7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDLCtCQUErQjtBQUNoQztBQUNBO0FBQ0EsR0FBRztBQUNILENBQUMsYUFBYTtBQUNkO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQyxhQUFhO0FBQ2Q7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSCxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6IjMzLmpzIiwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHM9e3JlbmRlcjpmdW5jdGlvbiAoKXt2YXIgX3ZtPXRoaXM7XG4gIHJldHVybiBfdm0uX2goJ2RpdicsIFtfdm0uX2goJ2RpdicsIHtcbiAgICBzdGF0aWNDbGFzczogXCJkb3dubG9hZC1iYXJcIlxuICB9LCBbX3ZtLl9oKCdkaXYnLCB7XG4gICAgc3RhdGljQ2xhc3M6IFwibG9nb1wiXG4gIH0pLCBfdm0uX20oMCksIF92bS5fbSgxKSwgX3ZtLl9oKCdkaXYnLCB7XG4gICAgc3RhdGljQ2xhc3M6IFwiYnRuXCIsXG4gICAgb246IHtcbiAgICAgIFwiY2xpY2tcIjogX3ZtLmRvd25sb2FkXG4gICAgfVxuICB9KV0pLCBfdm0uX20oMildKVxufSxzdGF0aWNSZW5kZXJGbnM6IFtmdW5jdGlvbiAoKXt2YXIgX3ZtPXRoaXM7XG4gIHJldHVybiBfdm0uX2goJ2RpdicsIHtcbiAgICBzdGF0aWNDbGFzczogXCJpcC1uYW1lXCJcbiAgfSwgW1wi572R5piTXCIsIF92bS5faCgnYnInKSwgXCLoj6DokJ1cIl0pXG59LGZ1bmN0aW9uICgpe3ZhciBfdm09dGhpcztcbiAgcmV0dXJuIF92bS5faCgnZGl2Jywge1xuICAgIHN0YXRpY0NsYXNzOiBcImNvbnRlbnRcIlxuICB9LCBbXCLlj4zmiYvkuIvovb1cIiwgX3ZtLl9oKCdicicpLCBcIuS7peekuua4heeZvVwiXSlcbn0sZnVuY3Rpb24gKCl7dmFyIF92bT10aGlzO1xuICByZXR1cm4gX3ZtLl9oKCdkaXYnLCB7XG4gICAgc3RhdGljQ2xhc3M6IFwiZG93bmxvYWQtZ3VpZGVcIlxuICB9LCBbX3ZtLl9oKCdkaXYnLCB7XG4gICAgc3RhdGljQ2xhc3M6IFwiY29udGFpbmVyXCJcbiAgfSwgW192bS5faCgnZGl2Jywge1xuICAgIHN0YXRpY0NsYXNzOiBcImNvbnRlbnRcIlxuICB9LCBbXCLor7fngrnlh7vov5nph4zkvb/nlKjmtY/op4jlmajmiZPlvIBcIl0pLCBfdm0uX2goJ2RpdicsIHtcbiAgICBzdGF0aWNDbGFzczogXCJ0cmlhbmdsZVwiXG4gIH0pLCBfdm0uX2goJ2RpdicsIHtcbiAgICBzdGF0aWNDbGFzczogXCJpY29uXCJcbiAgfSldKV0pXG59XX1cbmlmIChtb2R1bGUuaG90KSB7XG4gIG1vZHVsZS5ob3QuYWNjZXB0KClcbiAgaWYgKG1vZHVsZS5ob3QuZGF0YSkge1xuICAgICByZXF1aXJlKFwidnVlLWxvYWRlci9ub2RlX21vZHVsZXMvdnVlLWhvdC1yZWxvYWQtYXBpXCIpLnJlcmVuZGVyKFwiZGF0YS12LTY2ZDQzOTZkXCIsIG1vZHVsZS5leHBvcnRzKVxuICB9XG59XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+Ly45LjkuNUB2dWUtbG9hZGVyL2xpYi90ZW1wbGF0ZS1jb21waWxlci5qcz9pZD1kYXRhLXYtNjZkNDM5NmQhLi9+Ly45LjkuNUB2dWUtbG9hZGVyL2xpYi90ZW1wbGF0ZS1sb2FkZXIuanM/cmF3JmVuZ2luZT1qYWRlIS4vc3JjL2NvbXBvbmVudHMvbW9iaWxlL0Rvd25sb2FkQmFyL2luZGV4LmphZGVcbi8vIG1vZHVsZSBpZCA9IDMzXG4vLyBtb2R1bGUgY2h1bmtzID0gMSJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ },
/* 34 */
/***/ function(module, exports, __webpack_require__) {

	eval("module.exports={render:function (){var _vm=this;\n  return _vm._h('div', {\n    staticClass: \"wrapper\"\n  }, [_vm._h('div', {\n    staticClass: \"android-btn\",\n    on: {\n      \"click\": _vm.downloadByAndroid\n    }\n  }), _vm._h('div', {\n    staticClass: \"ios-btn\",\n    on: {\n      \"click\": _vm.downloadByIOS\n    }\n  }), _vm._h('download-bar', {\n    attrs: {\n      \"msg\": _vm.msg\n    }\n  })])\n},staticRenderFns: []}\nif (false) {\n  module.hot.accept()\n  if (module.hot.data) {\n     require(\"vue-loader/node_modules/vue-hot-reload-api\").rerender(\"data-v-6e751231\", module.exports)\n  }\n}//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvcGFnZXMvbW9iaWxlL3BhZ2Utbm90Zm91bmQvaW5kZXguamFkZT9jY2RkIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLGdCQUFnQixtQkFBbUI7QUFDbkM7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiIzNC5qcyIsInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzPXtyZW5kZXI6ZnVuY3Rpb24gKCl7dmFyIF92bT10aGlzO1xuICByZXR1cm4gX3ZtLl9oKCdkaXYnLCB7XG4gICAgc3RhdGljQ2xhc3M6IFwid3JhcHBlclwiXG4gIH0sIFtfdm0uX2goJ2RpdicsIHtcbiAgICBzdGF0aWNDbGFzczogXCJhbmRyb2lkLWJ0blwiLFxuICAgIG9uOiB7XG4gICAgICBcImNsaWNrXCI6IF92bS5kb3dubG9hZEJ5QW5kcm9pZFxuICAgIH1cbiAgfSksIF92bS5faCgnZGl2Jywge1xuICAgIHN0YXRpY0NsYXNzOiBcImlvcy1idG5cIixcbiAgICBvbjoge1xuICAgICAgXCJjbGlja1wiOiBfdm0uZG93bmxvYWRCeUlPU1xuICAgIH1cbiAgfSksIF92bS5faCgnZG93bmxvYWQtYmFyJywge1xuICAgIGF0dHJzOiB7XG4gICAgICBcIm1zZ1wiOiBfdm0ubXNnXG4gICAgfVxuICB9KV0pXG59LHN0YXRpY1JlbmRlckZuczogW119XG5pZiAobW9kdWxlLmhvdCkge1xuICBtb2R1bGUuaG90LmFjY2VwdCgpXG4gIGlmIChtb2R1bGUuaG90LmRhdGEpIHtcbiAgICAgcmVxdWlyZShcInZ1ZS1sb2FkZXIvbm9kZV9tb2R1bGVzL3Z1ZS1ob3QtcmVsb2FkLWFwaVwiKS5yZXJlbmRlcihcImRhdGEtdi02ZTc1MTIzMVwiLCBtb2R1bGUuZXhwb3J0cylcbiAgfVxufVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi8uOS45LjVAdnVlLWxvYWRlci9saWIvdGVtcGxhdGUtY29tcGlsZXIuanM/aWQ9ZGF0YS12LTZlNzUxMjMxIS4vfi8uOS45LjVAdnVlLWxvYWRlci9saWIvdGVtcGxhdGUtbG9hZGVyLmpzP3JhdyZlbmdpbmU9amFkZSEuL3NyYy9wYWdlcy9tb2JpbGUvcGFnZS1ub3Rmb3VuZC9pbmRleC5qYWRlXG4vLyBtb2R1bGUgaWQgPSAzNFxuLy8gbW9kdWxlIGNodW5rcyA9IDEiXSwic291cmNlUm9vdCI6IiJ9");

/***/ },
/* 35 */
/***/ function(module, exports) {

	eval("'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nvar remHelper = {\n    originWidth: 750,\n    maxWidth: null,\n    remResize: function remResize() {\n        var screenWidth = document.documentElement.clientWidth;\n        if (this.maxWidth && screenWidth > this.maxWidth) screenWidth = this.maxWidth;\n        document.documentElement.style.fontSize = screenWidth / this.originWidth * 100 + 'px';\n        console.log('ok');\n    }\n};\n\nexports.default = {\n    init: function init(originWidth, maxWidth) {\n        originWidth && (remHelper.originWidth = originWidth);\n        maxWidth && (remHelper.maxWidth = maxWidth);\n        remHelper.remResize();\n        window.onresize = remHelper.remResize.bind(remHelper);\n    }\n};//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9FOi9naXRfcHJvL2V4cHJlc3Mtd2VicGFjay12dWUvc3JjL3V0aWwvcmVtSGVscGVyLmpzP2RmYWQiXSwibmFtZXMiOlsicmVtSGVscGVyIiwib3JpZ2luV2lkdGgiLCJtYXhXaWR0aCIsInJlbVJlc2l6ZSIsInNjcmVlbldpZHRoIiwiZG9jdW1lbnQiLCJkb2N1bWVudEVsZW1lbnQiLCJjbGllbnRXaWR0aCIsInN0eWxlIiwiZm9udFNpemUiLCJjb25zb2xlIiwibG9nIiwiaW5pdCIsIndpbmRvdyIsIm9ucmVzaXplIiwiYmluZCJdLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQSxJQUFJQSxZQUFZO0FBQ1pDLGlCQUFhLEdBREQ7QUFFWkMsY0FBVSxJQUZFO0FBR1pDLGVBQVcscUJBQVc7QUFDbEIsWUFBSUMsY0FBY0MsU0FBU0MsZUFBVCxDQUF5QkMsV0FBM0M7QUFDQSxZQUFHLEtBQUtMLFFBQUwsSUFBaUJFLGNBQWMsS0FBS0YsUUFBdkMsRUFBaURFLGNBQWMsS0FBS0YsUUFBbkI7QUFDakRHLGlCQUFTQyxlQUFULENBQXlCRSxLQUF6QixDQUErQkMsUUFBL0IsR0FBNENMLGNBQWMsS0FBS0gsV0FBcEIsR0FBbUMsR0FBcEMsR0FBMkMsSUFBckY7QUFDQVMsZ0JBQVFDLEdBQVIsQ0FBWSxJQUFaO0FBQ0g7QUFSVyxDQUFoQjs7a0JBV2U7QUFDWEMsVUFBTSxjQUFTWCxXQUFULEVBQXNCQyxRQUF0QixFQUFnQztBQUNsQ0Qsd0JBQWdCRCxVQUFVQyxXQUFWLEdBQXdCQSxXQUF4QztBQUNBQyxxQkFBYUYsVUFBVUUsUUFBVixHQUFxQkEsUUFBbEM7QUFDQUYsa0JBQVVHLFNBQVY7QUFDQVUsZUFBT0MsUUFBUCxHQUFrQmQsVUFBVUcsU0FBVixDQUFvQlksSUFBcEIsQ0FBeUJmLFNBQXpCLENBQWxCO0FBQ0g7QUFOVSxDIiwiZmlsZSI6IjM1LmpzIiwic291cmNlc0NvbnRlbnQiOlsidmFyIHJlbUhlbHBlciA9IHtcclxuICAgIG9yaWdpbldpZHRoOiA3NTAsXHJcbiAgICBtYXhXaWR0aDogbnVsbCxcclxuICAgIHJlbVJlc2l6ZTogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgdmFyIHNjcmVlbldpZHRoID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudFdpZHRoO1xyXG4gICAgICAgIGlmKHRoaXMubWF4V2lkdGggJiYgc2NyZWVuV2lkdGggPiB0aGlzLm1heFdpZHRoKSBzY3JlZW5XaWR0aCA9IHRoaXMubWF4V2lkdGg7XHJcbiAgICAgICAgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlLmZvbnRTaXplID0gKChzY3JlZW5XaWR0aCAvIHRoaXMub3JpZ2luV2lkdGgpICogMTAwKSArICdweCc7XHJcbiAgICAgICAgY29uc29sZS5sb2coJ29rJyk7XHJcbiAgICB9XHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuICAgIGluaXQ6IGZ1bmN0aW9uKG9yaWdpbldpZHRoLCBtYXhXaWR0aCkge1xyXG4gICAgICAgIG9yaWdpbldpZHRoICYmIChyZW1IZWxwZXIub3JpZ2luV2lkdGggPSBvcmlnaW5XaWR0aCk7XHJcbiAgICAgICAgbWF4V2lkdGggJiYgKHJlbUhlbHBlci5tYXhXaWR0aCA9IG1heFdpZHRoKTtcclxuICAgICAgICByZW1IZWxwZXIucmVtUmVzaXplKCk7XHJcbiAgICAgICAgd2luZG93Lm9ucmVzaXplID0gcmVtSGVscGVyLnJlbVJlc2l6ZS5iaW5kKHJlbUhlbHBlcik7XHJcbiAgICB9XHJcbn1cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9FOi9naXRfcHJvL2V4cHJlc3Mtd2VicGFjay12dWUvc3JjL3V0aWwvcmVtSGVscGVyLmpzIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ }
/******/ ]);